<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>周小白</title>
  
  
  <link href="http://baixiaozhou.github.io/atom.xml" rel="self"/>
  
  <link href="http://baixiaozhou.github.io/"/>
  <updated>2024-09-03T09:11:58.536Z</updated>
  <id>http://baixiaozhou.github.io/</id>
  
  <author>
    <name>baixiaozhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pacemaker+Corosync使用简介</title>
    <link href="http://baixiaozhou.github.io/p/Pacemaker-Corosync%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://baixiaozhou.github.io/p/Pacemaker-Corosync%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2024-08-30T09:59:26.000Z</published>
    <updated>2024-09-03T09:11:58.536Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">参考文档</span><span class="empty"></span></p></div><p><a href="https://docs.redhat.com/zh_hans/documentation/red_hat_enterprise_linux/7/html/high_availability_add-on_reference/index">红帽官方文档</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pacemaker 和 corosync是两种开源软件组件，通常结合使用以构建高可用性（HA）集群。</p><h2 id="Pacemaker"><a href="#Pacemaker" class="headerlink" title="Pacemaker"></a>Pacemaker</h2><p>Pacemaker 是一个集群资源管理器，负责管理集群中所有资源的启动、停止、迁移等操作。它通过与 Corosync 协作，确保在节点故障或服务异常时，资源能够自动在其他健康节点上接管。从这里我们就可以发现，pacemaker 的核心在于管理</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>pacemaker 主要包括以下组件:</p><ul><li>   CIB (Cluster Information Base)：存储集群的配置信息，包括资源、约束、节点等。</li><li>   CRM (Cluster Resource Manager)：决定如何在集群中分配和管理资源。</li><li>   PEngine (Policy Engine)：根据集群状态和配置策略做出决策。</li><li>   Fencing：通过 STONITH（Shoot The Other Node In The Head）机制来隔离失效的节点，防止脑裂。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>   管理集群中的各种资源（如虚拟 IP、数据库服务、文件系统等）。</li><li>   确保服务的高可用性，在故障发生时自动切换资源到其他节点。</li></ul><h2 id="Corosync"><a href="#Corosync" class="headerlink" title="Corosync"></a>Corosync</h2><p>Corosync 是一个集群通信引擎，负责在集群节点之间提供消息传递、组成员资格管理、心跳检测等功能。它确保集群中所有节点之间的信息同步，监控节点的健康状况，并在节点故障时通知 pacemaker。</p><h3 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h3><ul><li>   组通信：用于确保集群中所有节点保持一致的视图。</li><li>   故障检测：通过心跳机制监控节点状态，当节点失联时，通知 Pacemaker。</li><li>   配置管理：管理集群节点的配置和成员资格。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>   集群中节点间的实时通信。</li><li>   监控节点的可用性，并在节点失效时做出响应。</li></ul><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ol><li>在集群的所有节点上安装相关依赖:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcs pacemaker corosync # Centos</span><br></pre></td></tr></table></figure></li><li>启动相关服务并设置服务开机自启动:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start pcsd </span><br><span class="line">systemctl enable pcsd</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>设置<code>hacluster</code>用户的密码(此用户在包安装的过程中会自动创建)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd hacluster</span><br></pre></td></tr></table></figure></li><li>在 <code>/etc/hosts</code> 中加入节点配置，例如:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2 node2</span><br><span class="line">192.168.1.3 node3</span><br></pre></td></tr></table></figure></li></ol><h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><p>集群的命令行操作基本上都是通过 pcs 进行，pcs 提供了如下一些命令:</p><table><thead><tr><th>命令</th><th>说明</th><th>示例命令</th></tr></thead><tbody><tr><td><code>cluster</code></td><td>配置集群选项和节点</td><td><code>pcs cluster start</code> 启动集群</td></tr><tr><td><code>resource</code></td><td>管理集群资源</td><td><code>pcs resource create myresource ocf:heartbeat:IPaddr2 ip=192.168.1.1</code> 创建一个资源</td></tr><tr><td><code>stonith</code></td><td>管理 fence 设备</td><td><code>pcs stonith create myfence fence_ipmilan ipaddr=192.168.1.100 login=admin passwd=password lanplus=1</code> 创建 STONITH 设备</td></tr><tr><td><code>constraint</code></td><td>管理资源约束</td><td><code>pcs constraint location myresource prefers node1=100</code> 设置资源约束</td></tr><tr><td><code>property</code></td><td>管理 Pacemaker 属性</td><td><code>pcs property set stonith-enabled=false</code> 禁用 STONITH</td></tr><tr><td><code>acl</code></td><td>管理 Pacemaker 访问控制列表</td><td><code>pcs acl role create readonly</code> 创建只读角色</td></tr><tr><td><code>qdevice</code></td><td>管理本地主机上的仲裁设备提供程序</td><td><code>pcs qdevice add model net</code> 添加网络仲裁设备</td></tr><tr><td><code>quorum</code></td><td>管理集群仲裁设置</td><td><code>pcs quorum status</code> 查看仲裁状态</td></tr><tr><td><code>booth</code></td><td>管理 booth (集群票据管理器)</td><td><code>pcs booth status</code> 查看 booth 状态</td></tr><tr><td><code>status</code></td><td>查看集群状态</td><td><code>pcs status</code> 查看集群运行状态</td></tr><tr><td><code>config</code></td><td>查看和管理集群配置</td><td><code>pcs config show</code> 显示集群配置</td></tr><tr><td><code>pcsd</code></td><td>管理 pcs 守护进程</td><td><code>pcs pcsd status</code> 查看 pcsd 服务状态</td></tr><tr><td><code>node</code></td><td>管理集群节点</td><td><code>pcs node standby node1</code> 将节点设置为备用</td></tr><tr><td><code>alert</code></td><td>管理 Pacemaker 警报</td><td><code>pcs alert create node=node1 severity=critical</code> 创建警报</td></tr><tr><td><code>client</code></td><td>管理 pcsd 客户端配置</td><td><code>pcs client cert-key-gen --force</code> 生成新的客户端证书</td></tr></tbody></table><h2 id="节点认证和集群创建"><a href="#节点认证和集群创建" class="headerlink" title="节点认证和集群创建"></a>节点认证和集群创建</h2><p>在集群中的任意一个节点上执行:</p><ol><li><p>认证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs cluster auth node2 node3 -u hacluster</span><br></pre></td></tr></table></figure></li><li><p>认证完整后创建集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs cluster setup --name mycluster node2 node3 (同时添加所有节点)</span><br></pre></td></tr></table></figure><p>创建完成后，会生成 corosync 的配置文件，默认位置<code>/etc/corosync/corosync.conf</code>, 其中的内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">totem <span class="punctuation">&#123;</span></span><br><span class="line">    version<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    cluster_name<span class="punctuation">:</span> mycluster</span><br><span class="line">    secauth<span class="punctuation">:</span> off</span><br><span class="line">    transport<span class="punctuation">:</span> udpu</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">nodelist <span class="punctuation">&#123;</span></span><br><span class="line">    node <span class="punctuation">&#123;</span></span><br><span class="line">        ring0_addr<span class="punctuation">:</span> node2</span><br><span class="line">        nodeid<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    node <span class="punctuation">&#123;</span></span><br><span class="line">        ring0_addr<span class="punctuation">:</span> node3</span><br><span class="line">        nodeid<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">quorum <span class="punctuation">&#123;</span></span><br><span class="line">    provider<span class="punctuation">:</span> corosync_votequorum</span><br><span class="line">    two_node<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">logging <span class="punctuation">&#123;</span></span><br><span class="line">    to_logfile<span class="punctuation">:</span> yes</span><br><span class="line">    logfile<span class="punctuation">:</span> /var/log/cluster/corosync.log</span><br><span class="line">    to_syslog<span class="punctuation">:</span> yes</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pcs cluster start --all <span class="comment"># 这里启动失败的话，可以后面加上 --debug参数查看更详细的信息，可能会因为防火墙等问题导致启动失败</span></span><br><span class="line">pcs cluster <span class="built_in">enable</span> --all <span class="comment"># 设置自启动</span></span><br></pre></td></tr></table></figure></li><li><p>查看集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs status</span><br></pre></td></tr></table></figure><p>我们看下输出情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Cluster name: mycluster</span><br><span class="line"></span><br><span class="line">WARNINGS:</span><br><span class="line">No stonith devices and stonith-enabled is not false</span><br><span class="line"></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (version 1.1.23-1.el7_9.1-9acf116022) - partition with quorum</span><br><span class="line">Last updated: Mon Sep  2 18:43:57 2024</span><br><span class="line">Last change: Mon Sep  2 18:35:08 2024 by hacluster via crmd on node2</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">0 resource instances configured</span><br><span class="line"></span><br><span class="line">Online: [ node2 node3 ]</span><br><span class="line"></span><br><span class="line">No resources</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Daemon Status:</span><br><span class="line">  corosync: active/disabled</span><br><span class="line">  pacemaker: active/disabled</span><br><span class="line">  pcsd: active/enabled</span><br></pre></td></tr></table></figure><p>这里我们可以看到集群的总体情况，包括节点状态、服务状态（有两个服务还处于 disabled 状态， 通过<code>systemctl enable corosync pacemaker</code> 设置开机启动）、资源信息（还没有添加 resource）等</p></li></ol><h2 id="stonith-配置"><a href="#stonith-配置" class="headerlink" title="stonith 配置"></a>stonith 配置</h2><p>在上文集群的状态输出中还包括了一个告警信息: <code>No stonith devices and stonith-enabled is not false</code>, 这里的 stonith（Shoot The Other Node In The Head） 是一种防止“脑裂” (split-brain) 的机制。当集群中的一个节点失去与其他节点的连接时，stonith 设备可以强制重启或关闭这个失联的节点，避免两个或多个节点同时操作同一个资源，导致数据损坏。想要消除这个告警，有两种解决方案:</p><ol><li>禁用 stonith: 如果是自己的测试环境，那么可以禁用掉 stonith 来消除告警，操作方法为:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs property <span class="built_in">set</span> stonith-enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li>配置 stonith 设备: 在生产环境中，建议配置 stonith</li></ol><p>我们先根据官方文档的指示看一下stonith 有哪些可用代理:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 corosync]# pcs stonith list</span><br><span class="line">Error: No stonith agents available. Do you have fence agents installed?</span><br></pre></td></tr></table></figure><p>这里提示没有代理的 agent 可用，所以我们首先需要安装<code>fence agent</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y fence-agents</span><br></pre></td></tr></table></figure><p>我们再 list 一下，就可以看到支持的代理了</p><table><thead><tr><th>Fence Agent</th><th>描述</th></tr></thead><tbody><tr><td><code>fence_amt_ws</code></td><td>适用于 AMT (WS) 的 Fence 代理</td></tr><tr><td><code>fence_apc</code></td><td>通过 telnet&#x2F;ssh 控制 APC 的 Fence 代理</td></tr><tr><td><code>fence_apc_snmp</code></td><td>适用于 APC 和 Tripplite PDU 的 SNMP Fence 代理</td></tr><tr><td><code>fence_bladecenter</code></td><td>适用于 IBM BladeCenter 的 Fence 代理</td></tr><tr><td><code>fence_brocade</code></td><td>通过 telnet&#x2F;ssh 控制 HP Brocade 的 Fence 代理</td></tr><tr><td><code>fence_cisco_mds</code></td><td>适用于 Cisco MDS 的 Fence 代理</td></tr><tr><td><code>fence_cisco_ucs</code></td><td>适用于 Cisco UCS 的 Fence 代理</td></tr><tr><td><code>fence_compute</code></td><td>用于自动复活 OpenStack 计算实例的 Fence 代理</td></tr><tr><td><code>fence_drac5</code></td><td>适用于 Dell DRAC CMC&#x2F;5 的 Fence 代理</td></tr><tr><td><code>fence_eaton_snmp</code></td><td>适用于 Eaton 的 SNMP Fence 代理</td></tr><tr><td><code>fence_emerson</code></td><td>适用于 Emerson 的 SNMP Fence 代理</td></tr><tr><td><code>fence_eps</code></td><td>适用于 ePowerSwitch 的 Fence 代理</td></tr><tr><td><code>fence_evacuate</code></td><td>用于自动复活 OpenStack 计算实例的 Fence 代理</td></tr><tr><td><code>fence_heuristics_ping</code></td><td>基于 ping 进行启发式 Fencing 的代理</td></tr><tr><td><code>fence_hpblade</code></td><td>适用于 HP BladeSystem 的 Fence 代理</td></tr><tr><td><code>fence_ibmblade</code></td><td>通过 SNMP 控制 IBM BladeCenter 的 Fence 代理</td></tr><tr><td><code>fence_idrac</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_ifmib</code></td><td>适用于 IF MIB 的 Fence 代理</td></tr><tr><td><code>fence_ilo</code></td><td>适用于 HP iLO 的 Fence 代理</td></tr><tr><td><code>fence_ilo2</code></td><td>适用于 HP iLO2 的 Fence 代理</td></tr><tr><td><code>fence_ilo3</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_ilo3_ssh</code></td><td>通过 SSH 控制 HP iLO3 的 Fence 代理</td></tr><tr><td><code>fence_ilo4</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_ilo4_ssh</code></td><td>通过 SSH 控制 HP iLO4 的 Fence 代理</td></tr><tr><td><code>fence_ilo5</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_ilo5_ssh</code></td><td>通过 SSH 控制 HP iLO5 的 Fence 代理</td></tr><tr><td><code>fence_ilo_moonshot</code></td><td>适用于 HP Moonshot iLO 的 Fence 代理</td></tr><tr><td><code>fence_ilo_mp</code></td><td>适用于 HP iLO MP 的 Fence 代理</td></tr><tr><td><code>fence_ilo_ssh</code></td><td>通过 SSH 控制 HP iLO 的 Fence 代理</td></tr><tr><td><code>fence_imm</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_intelmodular</code></td><td>适用于 Intel Modular 的 Fence 代理</td></tr><tr><td><code>fence_ipdu</code></td><td>通过 SNMP 控制 iPDU 的 Fence 代理</td></tr><tr><td><code>fence_ipmilan</code></td><td>适用于 IPMI 的 Fence 代理</td></tr><tr><td><code>fence_kdump</code></td><td>与 kdump 崩溃恢复服务一起使用的 Fence 代理</td></tr><tr><td><code>fence_mpath</code></td><td>用于多路径持久保留的 Fence 代理</td></tr><tr><td><code>fence_redfish</code></td><td>适用于 Redfish 的 I&#x2F;O Fencing 代理</td></tr><tr><td><code>fence_rhevm</code></td><td>适用于 RHEV-M REST API 的 Fence 代理</td></tr><tr><td><code>fence_rsa</code></td><td>适用于 IBM RSA 的 Fence 代理</td></tr><tr><td><code>fence_rsb</code></td><td>适用于 Fujitsu-Siemens RSB 的 I&#x2F;O Fencing 代理</td></tr><tr><td><code>fence_sbd</code></td><td>适用于 SBD 的 Fence 代理</td></tr><tr><td><code>fence_scsi</code></td><td>用于 SCSI 持久保留的 Fence 代理</td></tr><tr><td><code>fence_virt</code></td><td>适用于虚拟机的 Fence 代理</td></tr><tr><td><code>fence_vmware_rest</code></td><td>适用于 VMware REST API 的 Fence 代理</td></tr><tr><td><code>fence_vmware_soap</code></td><td>通过 SOAP API 控制 VMware 的 Fence 代理</td></tr><tr><td><code>fence_wti</code></td><td>适用于 WTI 的 Fence 代理</td></tr><tr><td><code>fence_xvm</code></td><td>适用于虚拟机的 Fence 代理</td></tr></tbody></table><p>想查看代理的具体用法，可以使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs stonith describe stonith_agent</span><br></pre></td></tr></table></figure><p>使用 <code>fence_heuristics_ping</code> 作为代理，先通过<code>pcs stonith describe fence_heuristics_ping</code> 看下具体的用法和配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">fence_heuristics_ping - Fence agent for ping-heuristic based fencing</span><br><span class="line"></span><br><span class="line">fence_heuristics_ping uses ping-heuristics to control execution of another fence agent on the same fencing level.</span><br><span class="line"></span><br><span class="line">This is not a fence agent by itself! Its only purpose is to enable/disable another fence agent that lives on the same fencing level but after fence_heuristics_ping.</span><br><span class="line"></span><br><span class="line">Stonith options:</span><br><span class="line">  method: Method to fence</span><br><span class="line">  ping_count: The number of ping-probes that is being sent per target</span><br><span class="line">  ping_good_count: The number of positive ping-probes required to account a target as available</span><br><span class="line">  ping_interval: The interval in seconds between ping-probes</span><br><span class="line">  ping_maxfail: The number of failed ping-targets to still account as overall success</span><br><span class="line">  ping_targets (required): A comma separated list of ping-targets (optionally prepended by &#x27;inet:&#x27; or &#x27;inet6:&#x27;) to be probed</span><br><span class="line">  ping_timeout: The timeout in seconds till an individual ping-probe is accounted as lost</span><br><span class="line">  quiet: Disable logging to stderr. Does not affect --verbose or --debug-file or logging to syslog.</span><br><span class="line">  verbose: Verbose mode</span><br><span class="line">  debug: Write debug information to given file</span><br><span class="line">  delay: Wait X seconds before fencing is started</span><br><span class="line">  login_timeout: Wait X seconds for cmd prompt after login</span><br><span class="line">  power_timeout: Test X seconds for status change after ON/OFF</span><br><span class="line">  power_wait: Wait X seconds after issuing ON/OFF</span><br><span class="line">  shell_timeout: Wait X seconds for cmd prompt after issuing command</span><br><span class="line">  retry_on: Count of attempts to retry power on</span><br><span class="line">  pcmk_host_map: A mapping of host names to ports numbers for devices that do not support host names. Eg. node1:1;node2:2,3 would tell the cluster to use port 1 for node1 and ports 2 and 3</span><br><span class="line">                 for node2</span><br><span class="line">  pcmk_host_list: A list of machines controlled by this device (Optional unless pcmk_host_check=static-list).</span><br><span class="line">  pcmk_host_check: How to determine which machines are controlled by the device. Allowed values: dynamic-list (query the device via the &#x27;list&#x27; command), static-list (check the pcmk_host_list</span><br><span class="line">                   attribute), status (query the device via the &#x27;status&#x27; command), none (assume every device can fence every machine)</span><br><span class="line">  pcmk_delay_max: Enable a random delay for stonith actions and specify the maximum of random delay. This prevents double fencing when using slow devices such as sbd. Use this to enable a</span><br><span class="line">                  random delay for stonith actions. The overall delay is derived from this random delay value adding a static delay so that the sum is kept below the maximum delay.</span><br><span class="line">  pcmk_delay_base: Enable a base delay for stonith actions and specify base delay value. This prevents double fencing when different delays are configured on the nodes. Use this to enable a</span><br><span class="line">                   static delay for stonith actions. The overall delay is derived from a random delay value adding this static delay so that the sum is kept below the maximum delay.</span><br><span class="line">  pcmk_action_limit: The maximum number of actions can be performed in parallel on this device Pengine property concurrent-fencing=true needs to be configured first. Then use this to specify</span><br><span class="line">                     the maximum number of actions can be performed in parallel on this device. -1 is unlimited.</span><br><span class="line"></span><br><span class="line">Default operations:</span><br><span class="line">  monitor: interval=60s</span><br></pre></td></tr></table></figure><p>这里我们进行创建(其他参数都有默认值，按需修改即可):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pcs stonith create my_ping_fence_device fence_heuristics_ping \</span><br><span class="line">    ping_targets=<span class="string">&quot;node2,node3&quot;</span></span><br></pre></td></tr></table></figure><p>创建完成后<code>pcs status</code>查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Cluster name: mycluster</span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (version 1.1.23-1.el7_9.1-9acf116022) - partition with quorum</span><br><span class="line">Last updated: Tue Sep  3 14:40:56 2024</span><br><span class="line">Last change: Tue Sep  3 14:35:39 2024 by root via cibadmin on node2</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">1 resource instance configured</span><br><span class="line"></span><br><span class="line">Online: [ node2 node3 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> my_ping_fence_device(stonith:fence_heuristics_ping):Started node2</span><br><span class="line"></span><br><span class="line">Failed Fencing Actions:</span><br><span class="line">* reboot of my_apc_fence_device failed: delegate=, client=stonith_admin.40341, origin=node2,</span><br><span class="line">    last-failed=&#x27;Tue Sep  3 14:12:23 2024&#x27;</span><br><span class="line"></span><br><span class="line">Daemon Status:</span><br><span class="line">  corosync: active/enabled</span><br><span class="line">  pacemaker: active/enabled</span><br><span class="line">  pcsd: active/enabled</span><br></pre></td></tr></table></figure><p>验证 stonith 是否生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 cluster]# pcs stonith fence node3</span><br><span class="line">Node: node3 fenced</span><br></pre></td></tr></table></figure><p>执行完这个操作后，节点会离线，pcs 服务会停止，想要加回来的话，在停止的节点上重新启动集群即可:<code>pcs cluster start &amp;&amp; pcs cluster enable</code></p><h1 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h1><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>上文中，我们构建了一个两节点的集群，我们可以尝试增加一个节点，构建一个三节点的集群</p><ol><li>首先在新节点上安装各种依赖，设置密码等。</li><li>在原集群上认证新 node</li><li>在原集群上添加 node：<code>pcs cluster node add node4</code></li><li>在 node4 上执行：<code>pcs cluster start &amp;&amp; pcs cluster enable</code></li></ol><p>再通过<code>pcs status</code>就可以看到新的节点已经加入</p><p>添加完之后还需要更新新节点的一些配置，比如上文提到的 stonith：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pcs stonith update my_ping_fence_device fence_heuristics_ping \</span><br><span class="line">    ping_targets=<span class="string">&quot;node2,node3,node4&quot;</span></span><br></pre></td></tr></table></figure><h2 id="配置-resource"><a href="#配置-resource" class="headerlink" title="配置 resource"></a>配置 resource</h2><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>创建 resource 的基本格式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs resource create resource-name ocf:heartbeat:apache [--options]</span><br></pre></td></tr></table></figure><p>这里的 ocf:heartbeat:apache 第一个部分ocf，指明了这个资源采用的标准(类型)，第二个部分标明这个资源脚本的在ocf中的名字空间，在这个例子中是heartbeat。最后一个部分指明了资源脚本的名称。</p><p>我们先看下有哪些标准类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 ~]# pcs resource standards</span><br><span class="line">lsb</span><br><span class="line">ocf</span><br><span class="line">service</span><br><span class="line">systemd</span><br></pre></td></tr></table></figure><p>查看可用的ocf资源提供者:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 ~]# pcs resource providers</span><br><span class="line">heartbeat</span><br><span class="line">openstack</span><br><span class="line">pacemaker</span><br></pre></td></tr></table></figure><p>查看特定标准下所支持的脚本，例：ofc:heartbeat 下的脚本(列举了部分)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 ~]# pcs resource agents ocf:heartbeat</span><br><span class="line">aliyun-vpc-move-ip</span><br><span class="line">apache</span><br><span class="line">aws-vpc-move-ip</span><br><span class="line">aws-vpc-route53</span><br><span class="line">awseip</span><br><span class="line">awsvip</span><br><span class="line">azure-events</span><br><span class="line">azure-lb</span><br><span class="line">clvm</span><br><span class="line">conntrackd</span><br><span class="line">CTDB</span><br><span class="line">db2</span><br><span class="line">Delay</span><br><span class="line">dhcpd</span><br><span class="line">docker</span><br><span class="line">Dummy</span><br><span class="line">ethmonitor</span><br><span class="line">exportfs</span><br><span class="line">Filesystem</span><br><span class="line">galera</span><br><span class="line">garbd</span><br><span class="line">iface-vlan</span><br><span class="line">IPaddr</span><br><span class="line">IPaddr2</span><br></pre></td></tr></table></figure><h3 id="设置虚拟-ip"><a href="#设置虚拟-ip" class="headerlink" title="设置虚拟 ip"></a>设置虚拟 ip</h3><p>虚拟 IP（Virtual IP）是在高可用性集群中使用的一种技术，通过为服务提供一个不依赖于特定物理节点的 IP 地址来实现服务的高可用性。当集群中的某个节点出现故障时，虚拟 IP 可以迅速转移到另一个健康的节点上，从而保证服务的连续性。</p><p>虚拟 IP 的使用场景</p><ol><li>高可用性：虚拟 IP 最常见的使用场景是高可用性集群（如 Pacemaker 或 Keepalived），它允许一个服务在集群中的多个节点之间进行切换，而不会更改客户端访问的 IP 地址。</li><li>负载均衡：虚拟 IP 可以结合负载均衡器使用，将来自客户端的请求分配到多个后端服务器，以实现流量的均匀分布。</li><li>灾难恢复：在灾难恢复场景中，虚拟 IP 可以用于快速恢复服务，将业务流量从故障节点转移到备用节点上</li></ol><p>在 pcs 集群中，我们可以通过以下方式增加一个虚拟 ip:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs resource create virtual_ip ocf:heartbeat:IPaddr2 ip=x.x.x.x cidr_netmask=32 nic=bond1 op monitor interval=30s</span><br></pre></td></tr></table></figure><p>执行完成后，通过<code>pcs status</code>就可以看到 ip 绑定在哪里:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual_ip(ocf::heartbeat:IPaddr2):Started node3</span><br></pre></td></tr></table></figure><p>当我们关停 node3 的服务时，就会发现这个虚拟ip 绑定到了其他节点的 bond1 网卡上。</p><h3 id="增加服务"><a href="#增加服务" class="headerlink" title="增加服务"></a>增加服务</h3><p>我们以 httpd 服务为例，在集群中创建资源,首先安装对应服务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install httpd -y</span><br><span class="line">sudo systemctl start httpd</span><br><span class="line">sudo systemctl enable httpd</span><br></pre></td></tr></table></figure><p>创建 resource:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs resource create WebService ocf:heartbeat:apache configfile=/etc/httpd/conf/httpd.conf op monitor interval=30s</span><br></pre></td></tr></table></figure><h3 id="结合-LVS-进行使用"><a href="#结合-LVS-进行使用" class="headerlink" title="结合 LVS 进行使用"></a>结合 LVS 进行使用</h3>]]></content>
    
    
    <summary type="html">Pacemaker+Corosync使用简介</summary>
    
    
    
    <category term="高可用" scheme="http://baixiaozhou.github.io/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    
    <category term="Linux" scheme="http://baixiaozhou.github.io/tags/Linux/"/>
    
    <category term="Pacemaker" scheme="http://baixiaozhou.github.io/tags/Pacemaker/"/>
    
    <category term="Corosync" scheme="http://baixiaozhou.github.io/tags/Corosync/"/>
    
    <category term="高可用方案" scheme="http://baixiaozhou.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="http://baixiaozhou.github.io/p/%E5%B7%A5%E4%BD%9C%E9%9A%8F%E8%AE%B0/"/>
    <id>http://baixiaozhou.github.io/p/%E5%B7%A5%E4%BD%9C%E9%9A%8F%E8%AE%B0/</id>
    <published>2024-08-21T10:28:27.000Z</published>
    <updated>2024-08-21T11:17:13.380Z</updated>
    
    <content type="html"><![CDATA[<!-- Your content starts here --><ul><li><a href="#centos-%E5%AE%89%E8%A3%85-ebpf">Centos 安装 EBPF</a></li></ul><h2 id="Centos-安装-EBPF"><a href="#Centos-安装-EBPF" class="headerlink" title="Centos 安装 EBPF"></a>Centos 安装 EBPF</h2><p>安装必要工具和依赖:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install python3 python3-pip python3-devel gcc gcc-c++ make bcc bcc-tools bcc-devel</span><br></pre></td></tr></table></figure><p>安装 BCC Python 模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install bcc</span><br></pre></td></tr></table></figure><p>离线安装的方式如下：</p><ol><li>下载 bcc 和 Python 模块源包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 bcc 的源码包</span></span><br><span class="line">wget https://github.com/iovisor/bcc/archive/refs/tags/v0.22.0.tar.gz -O bcc.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 bcc 的 Python 模块源代码包</span></span><br><span class="line"><span class="comment"># 可以去这里 https://pypi.org/project/bcc/#files 进行查找</span></span><br><span class="line">wget https://files.pythonhosted.org/packages/38/dc/3ca34874926789f8df53f3c1d1c38e77ebf876f43760e8745316bb8bd1c0/bcc-0.1.10.tar.gz</span><br></pre></td></tr></table></figure></li><li>上传文件到离线环境上,解压并进行安装:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf bcc.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bcc-0.22.0  <span class="comment"># 目录名可能会有所不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统依赖（可能需要根权限）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y gcc gcc-c++ make bpfcc-tools  <span class="comment"># CentOS/RHEL</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y gcc g++ make bpfcc-tools  <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译和安装 bcc</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></li><li>安装 bcc Python 模块<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压下载的 Python 模块源代码包</span></span><br><span class="line">tar -xzf bcc-python.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bcc-python  <span class="comment"># 目录名可能会有所不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Python 模块</span></span><br><span class="line">pip3 install .</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">记录工作中的一些日常操作</summary>
    
    
    
    <category term="工作随记" scheme="http://baixiaozhou.github.io/categories/%E5%B7%A5%E4%BD%9C%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="http://baixiaozhou.github.io/tags/Linux/"/>
    
    <category term="ebpf" scheme="http://baixiaozhou.github.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>ansible详细介绍</title>
    <link href="http://baixiaozhou.github.io/p/ansible%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://baixiaozhou.github.io/p/ansible%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2024-08-19T11:09:34.000Z</published>
    <updated>2024-08-22T08:28:14.361Z</updated>
    
    <content type="html"><![CDATA[<!-- Your content starts here --><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">官方文档</span><span class="empty"></span></p></div><p><a href="https://docs.ansible.com/ansible/latest/index.html">英文文档</a><br><a href="http://www.ansible.com.cn/docs/intro_adhoc.html">中文文档</a></p><h1 id="ansible-介绍"><a href="#ansible-介绍" class="headerlink" title="ansible 介绍"></a>ansible 介绍</h1><p>我们先看一下 ansible 的相关介绍:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. https://docs.ansible.com.</span><br></pre></td></tr></table></figure><p>这里有几点核心:</p><ol><li>ansible 是一个自动化平台</li><li>ansible 使用 ssh 协议（通过密码或者密钥等方式进行访问），部署简单，没有客户端，只需在主控端部署 Ansible 环境，无需在远程系统上安装代理程序</li><li>模块化：调用特定的模块，完成特定任务</li><li>支持自定义扩展</li></ol><p>每开发一个工具或者平台的时候，这些工具和平台提供了各种各样的功能，那么我们能用 ansible 来干什么呢？ 下面就是一些 ansible 核心的功能介绍：</p><table><thead><tr><th>功能</th><th>描述</th><th>常见场景示例</th></tr></thead><tbody><tr><td>配置管理</td><td>自动化管理服务器和设备的配置，确保它们处于期望的状态。</td><td>自动化安装和配置 Web 服务器，确保所有服务器配置一致。</td></tr><tr><td>应用部署</td><td>自动化应用程序的部署过程，从代码库拉取到在服务器上部署和配置应用。</td><td>自动部署多层 Web 应用程序，包括数据库设置、应用服务部署、负载均衡配置等。</td></tr><tr><td>持续交付与持续集成（CI&#x2F;CD）</td><td>与 CI&#x2F;CD 工具集成，实现自动化的构建、测试和部署流程。</td><td>代码提交后自动执行测试、构建容器镜像，并部署到 Kubernetes 集群中。</td></tr><tr><td>基础设施即代码（IaC）</td><td>编写和管理基础设施的配置文件，使其像管理代码一样。</td><td>使用 Ansible Playbooks 定义云环境资源配置，实现可重复的基础设施部署。</td></tr><tr><td>云管理</td><td>自动化云服务资源的管理，包括虚拟机、存储、网络等的创建和配置。</td><td>自动化创建和管理 AWS EC2 实例、配置 VPC 和安全组。</td></tr><tr><td>网络自动化</td><td>管理和配置网络设备，使得大规模的网络设备配置变得简单和一致。</td><td>自动化配置多台交换机的 VLAN 设置和路由协议。</td></tr><tr><td>安全与合规</td><td>自动化安全补丁的部署、系统安全配置的强化以及合规性检查。</td><td>自动化应用系统安全补丁，配置防火墙规则，执行安全扫描和合规性检查。</td></tr><tr><td>多平台环境管理</td><td>支持多种操作系统，在混合环境中统一管理平台上的配置和应用。</td><td>在混合的 Linux 和 Windows 服务器环境中，统一部署和配置监控软件。</td></tr><tr><td>灾难恢复</td><td>自动化灾难恢复流程，如备份、数据恢复和服务恢复。</td><td>自动化数据库备份并在需要时恢复和重建数据库服务。</td></tr><tr><td>任务调度与批量操作</td><td>通过 Playbooks 调度定期任务或对大量服务器执行批量操作。</td><td>定期清理服务器上的临时文件或批量更新多个服务器的操作系统。</td></tr></tbody></table><h2 id="ansible的工作机制"><a href="#ansible的工作机制" class="headerlink" title="ansible的工作机制"></a>ansible的工作机制</h2><p>Ansible 在管理节点将 Ansible 模块通过 SSH 协议推送到被管理端执行，执行完之后自动删除，可以使用 SVN 等来管理自定义模块及编排</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/ansible-diagram.png" alt="ansible结构" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">ansible结构</span></div></div><p>从这张图中我们可以看到，ansible 由以下模块组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ansible： ansible的核心模块</span><br><span class="line">Host Inventory：主机清单，也就是被管理的主机列表</span><br><span class="line">Playbooks：ansible的剧本，可想象为将多个任务放置在一起，一块执行</span><br><span class="line">Core Modules：ansible的核心模块</span><br><span class="line">Custom Modules：自定义模块</span><br><span class="line">Connection Plugins：连接插件，用于与被管控主机之间基于SSH建立连接关系</span><br><span class="line">Plugins：其他插件，包括记录日志等</span><br></pre></td></tr></table></figure><h2 id="ansible-安装"><a href="#ansible-安装" class="headerlink" title="ansible 安装"></a>ansible 安装</h2><p>在 centos 环境下，我们可以通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ansible -y 进行安装</span><br></pre></td></tr></table></figure><p>安装完成后我们看下 ansible 提供了哪些命令:</p><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>ansible</code></td><td>用于在一个或多个主机上运行单个模块（通常用于临时命令）。</td><td><code>ansible all -m ping</code></td></tr><tr><td><code>ansible-playbook</code></td><td>用于运行 Ansible playbook 文件，是 Ansible 的核心命令之一。</td><td><code>ansible-playbook site.yml</code></td></tr><tr><td><code>ansible-galaxy</code></td><td>用于管理 Ansible 角色和集合。可以下载、创建和分享角色。</td><td><code>ansible-galaxy install geerlingguy.apache</code></td></tr><tr><td><code>ansible-vault</code></td><td>用于加密和解密敏感数据（如密码、密钥）。</td><td><code>ansible-vault encrypt secrets.yml</code></td></tr><tr><td><code>ansible-doc</code></td><td>显示 Ansible 模块的文档和示例用法。</td><td><code>ansible-doc -l</code></td></tr><tr><td><code>ansible-config</code></td><td>用于查看、验证和管理 Ansible 配置文件。</td><td><code>ansible-config list</code></td></tr><tr><td><code>ansible-inventory</code></td><td>管理和检索 Ansible inventory 信息。</td><td><code>ansible-inventory --list -i inventory.yml</code></td></tr><tr><td><code>ansible-pull</code></td><td>用于从远程版本控制系统（如 Git）拉取 playbook 并在本地执行，常用于自动化部署。</td><td><code>ansible-pull -U https://github.com/username/repo.git</code></td></tr><tr><td><code>ansible-console</code></td><td>提供一个交互式命令行接口，可用于动态执行 Ansible 任务和命令。</td><td><code>ansible-console</code></td></tr></tbody></table><p>对两个比较常用的命令:<code>ansible</code> 和 <code>ansible-plabook</code> 做一下具体的介绍:</p><h3 id="ansible-命令"><a href="#ansible-命令" class="headerlink" title="ansible 命令"></a>ansible 命令</h3><p>命令格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible 组名 -m 模块名 -a <span class="string">&#x27;参数&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的组名是自定义的一系列组信息，组的定义在后面会讲到。</p><p>模块名是ansible提供的一些列支持模块，默认模块是 command，查看 ansible 支持的模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc -l <span class="comment">#大概有 3000 多个</span></span><br></pre></td></tr></table></figure><p>ansible涉及到的模块非常非常多，按照实际需要使用，初步先掌握一些比较常用的就可以</p><p>查看模块描述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc -s 模块名称</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看webserver 组机器的时间信息</span></span><br><span class="line">ansible webserver -m shell -a <span class="string">&quot;date&quot;</span> <span class="comment"># 这里的组就是 webserver，shell 是模块名（比较常用的模块）date 是具体执行的命令</span></span><br><span class="line"><span class="comment"># 将本机的/tmp/test.sh 拷贝到其他机器上的 /etc目录下</span></span><br><span class="line">ansible webserver -m copy -a <span class="string">&quot;src=/tmp/test.sh dest=/etc/test.sh&quot;</span> <span class="comment"># 这里的 copy 是模块名，里面的 src 是源路径，dest 是目标路径</span></span><br></pre></td></tr></table></figure><h3 id="ansible-playbook命令"><a href="#ansible-playbook命令" class="headerlink" title="ansible-playbook命令"></a>ansible-playbook命令</h3><p>用于执行 Ansible Playbooks。Playbooks 是一系列任务的集合，用于自动化配置管理、应用部署、任务执行等操作。<br>基本语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook [options] playbook.yml</span><br></pre></td></tr></table></figure><p>命令帮助:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">positional arguments:</span><br><span class="line">  playbook              Playbook(s)</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  --ask-vault-pass      ask for vault password</span><br><span class="line">  --flush-cache         clear the fact cache for every host in inventory</span><br><span class="line">  --force-handlers      run handlers even if a task fails</span><br><span class="line">  --list-hosts          outputs a list of matching hosts; does not execute</span><br><span class="line">                        anything else</span><br><span class="line">  --list-tags           list all available tags</span><br><span class="line">  --list-tasks          list all tasks that would be executed</span><br><span class="line">  --skip-tags SKIP_TAGS</span><br><span class="line">                        only run plays and tasks whose tags do not match these</span><br><span class="line">                        values</span><br><span class="line">  --start-at-task START_AT_TASK</span><br><span class="line">                        start the playbook at the task matching this name</span><br><span class="line">  --step                one-step-at-a-time: confirm each task before running</span><br><span class="line">  --syntax-check        perform a syntax check on the playbook, but do not</span><br><span class="line">                        execute it</span><br><span class="line">  --vault-id VAULT_IDS  the vault identity to use</span><br><span class="line">  --vault-password-file VAULT_PASSWORD_FILES</span><br><span class="line">                        vault password file</span><br><span class="line">  --version             show program&#x27;s version number, config file location,</span><br><span class="line">                        configured module search path, module location,</span><br><span class="line">                        executable location and exit</span><br><span class="line">  -C, --check           don&#x27;t make any changes; instead, try to predict some</span><br><span class="line">                        of the changes that may occur</span><br><span class="line">  -D, --diff            when changing (small) files and templates, show the</span><br><span class="line">                        differences in those files; works great with --check</span><br><span class="line">  -M MODULE_PATH, --module-path MODULE_PATH</span><br><span class="line">                        prepend colon-separated path(s) to module library (def</span><br><span class="line">                        ault=~/.ansible/plugins/modules:/usr/share/ansible/plu</span><br><span class="line">                        gins/modules)</span><br><span class="line">  -e EXTRA_VARS, --extra-vars EXTRA_VARS</span><br><span class="line">                        set additional variables as key=value or YAML/JSON, if</span><br><span class="line">                        filename prepend with @</span><br><span class="line">  -f FORKS, --forks FORKS</span><br><span class="line">                        specify number of parallel processes to use</span><br><span class="line">                        (default=64)</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY</span><br><span class="line">                        specify inventory host path or comma separated host</span><br><span class="line">                        list. --inventory-file is deprecated</span><br><span class="line">  -l SUBSET, --limit SUBSET</span><br><span class="line">                        further limit selected hosts to an additional pattern</span><br><span class="line">  -t TAGS, --tags TAGS  only run plays and tasks tagged with these values</span><br><span class="line">  -v, --verbose         verbose mode (-vvv for more, -vvvv to enable</span><br><span class="line">                        connection debugging)</span><br><span class="line"></span><br><span class="line">Connection Options:</span><br><span class="line">  control as whom and how to connect to hosts</span><br><span class="line"></span><br><span class="line">  --private-key PRIVATE_KEY_FILE, --key-file PRIVATE_KEY_FILE</span><br><span class="line">                        use this file to authenticate the connection</span><br><span class="line">  --scp-extra-args SCP_EXTRA_ARGS</span><br><span class="line">                        specify extra arguments to pass to scp only (e.g. -l)</span><br><span class="line">  --sftp-extra-args SFTP_EXTRA_ARGS</span><br><span class="line">                        specify extra arguments to pass to sftp only (e.g. -f,</span><br><span class="line">                        -l)</span><br><span class="line">  --ssh-common-args SSH_COMMON_ARGS</span><br><span class="line">                        specify common arguments to pass to sftp/scp/ssh (e.g.</span><br><span class="line">                        ProxyCommand)</span><br><span class="line">  --ssh-extra-args SSH_EXTRA_ARGS</span><br><span class="line">                        specify extra arguments to pass to ssh only (e.g. -R)</span><br><span class="line">  -T TIMEOUT, --timeout TIMEOUT</span><br><span class="line">                        override the connection timeout in seconds</span><br><span class="line">                        (default=10)</span><br><span class="line">  -c CONNECTION, --connection CONNECTION</span><br><span class="line">                        connection type to use (default=smart)</span><br><span class="line">  -k, --ask-pass        ask for connection password</span><br><span class="line">  -u REMOTE_USER, --user REMOTE_USER</span><br><span class="line">                        connect as this user (default=None)</span><br><span class="line"></span><br><span class="line">Privilege Escalation Options:</span><br><span class="line">  control how and which user you become as on target hosts</span><br><span class="line"></span><br><span class="line">  --become-method BECOME_METHOD</span><br><span class="line">                        privilege escalation method to use (default=sudo), use</span><br><span class="line">                        `ansible-doc -t become -l` to list valid choices.</span><br><span class="line">  --become-user BECOME_USER</span><br><span class="line">                        run operations as this user (default=root)</span><br><span class="line">  -K, --ask-become-pass</span><br><span class="line">                        ask for privilege escalation password</span><br><span class="line">  -b, --become          run operations with become (does not imply password</span><br><span class="line">                        prompting)</span><br></pre></td></tr></table></figure><h1 id="ansible-基本使用"><a href="#ansible-基本使用" class="headerlink" title="ansible 基本使用"></a>ansible 基本使用</h1><p>我们先看一个最基本的 ansible 组成:</p><div class="tag-plugin image"><div class="image-bg"><img src="https://docs.ansible.com/ansible/latest/_images/ansible_inv_start.svg" alt="ansible基本组成" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">ansible基本组成</span></div></div><p>如上图所示，大部分的 ansible 环境都包含以下三个组件:</p><ol><li>控制节点:安装了Ansible的系统。可以在控制节点上运行Ansible命令，例如ansible或ansible-inventory。</li><li>Inventory: 按逻辑组织的托管节点的列表。可以在控制节点上创建一个清单，以向Ansible描述主机部署。</li><li>被管理节点: Ansible控制的远程系统或主机。</li></ol><h2 id="Inventory文件"><a href="#Inventory文件" class="headerlink" title="Inventory文件"></a>Inventory文件</h2><p>inventory 主要包括主机和组两个概念, 默认文件 <code>/etc/ansible/hosts</code></p><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>主机是 Ansible 可以管理的单个设备或虚拟机。主机可以是物理服务器、虚拟机、容器，甚至是网络设备（如路由器和交换机）。每个主机都有一个唯一的标识（通常是主机名或 IP 地址），并且可以通过 Ansible 的 inventory 文件或其他动态方法来定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 定义单个主机</span><br><span class="line">web1.example.com</span><br><span class="line"></span><br><span class="line"># 定义多个主机</span><br><span class="line">web2.example.com</span><br><span class="line">192.168.1.10</span><br><span class="line"></span><br><span class="line"># 主机变量</span><br><span class="line">[atlanta]</span><br><span class="line">host1 http_port=80 maxRequestsPerChild=808</span><br><span class="line">host2 http_port=303 maxRequestsPerChild=909</span><br></pre></td></tr></table></figure><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>组是主机的集合，可以对一组主机应用相同的配置或操作。组允许用户在多个主机上批量执行任务。一个主机可以属于多个组。组之间还可以嵌套，例如，你可以将所有 Web 服务器放在一个组中，然后将该组嵌套在一个更大的生产环境组中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一下所有节点的信息</span></span><br><span class="line"><span class="section">[all_hosts]</span></span><br><span class="line">node1 <span class="attr">public_ip</span>=<span class="number">192.168</span>.<span class="number">1.101</span> ansible_host=<span class="number">192.168</span>.<span class="number">1.101</span> ansible_user=your_user ansible_ssh_pass=your_password ansible_port=<span class="number">22</span></span><br><span class="line">node2 <span class="attr">public_ip</span>=<span class="number">192.168</span>.<span class="number">1.102</span> ansible_host=<span class="number">192.168</span>.<span class="number">1.102</span> ansible_user=your_user ansible_ssh_pass=your_password ansible_port=<span class="number">22</span></span><br><span class="line">node3 <span class="attr">public_ip</span>=<span class="number">192.168</span>.<span class="number">1.103</span> ansible_host=<span class="number">192.168</span>.<span class="number">1.103</span> ansible_user=your_user ansible_ssh_pass=your_password ansible_port=<span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 mysql 组，假如要在 node1 和 node2上部署 mysql</span></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 nginx 组，假如要在 node1 和 node3上部署 nginx</span></span><br><span class="line"><span class="section">[nginx]</span></span><br><span class="line">node1</span><br><span class="line">node3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如我们还想部署一个 redis 组，mysql 部署在那里，redis 就部署在那里，重新写一遍很麻烦，那么我们可以把 redis 当做 mysql 的子集</span></span><br><span class="line"><span class="comment"># 这里有一个疑问，我们既然用一个一模一样的组再了，为啥搞个 children，直接用原来的组不行吗，这里可以是可以，但是从模块划分来看，做一下区分易于后续的管理</span></span><br><span class="line"><span class="section">[redis:children]</span></span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义组变量</span></span><br><span class="line"><span class="section">[atlanta:vars]</span></span><br><span class="line"><span class="attr">ntp_server</span>=ntp.atlanta.example.com</span><br><span class="line"><span class="attr">proxy</span>=proxy.atlanta.example.com</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>在我们了解完 inventory 之后，我们开始做一些简单的模拟:</p><ol><li>在 node1 上安装 ansible，作为控制节点，在&#x2F;etc&#x2F;ansbile&#x2F;hosts中加入三个节点的信息</li><li>如果是通过密码连接的话，需要在 ansible_ssh_pass中输入机器密码，如果是通过密钥链接，这里可不填；配置 ssh 免密登录，可以自行百度，这里只需要配置 node1 到所有节点的免密（包括 node1 到 node1 自己）</li><li>免密配置完成后，我们可以做一下简单的操作:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 mysql 组机器的时间信息</span></span><br><span class="line">ansilbe mysql -m shell -a <span class="string">&quot;date&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 nginx 组机器的启动时间</span></span><br><span class="line">ansible nginx -m shell -a <span class="string">&quot;uptime&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="playbooks"><a href="#playbooks" class="headerlink" title="playbooks"></a>playbooks</h1><p>playbook是由一个或多个play组成的列表，play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓的task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联合起来按事先编排的机制完成某一任务</p><h2 id="playbook语法"><a href="#playbook语法" class="headerlink" title="playbook语法:"></a>playbook语法:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">playbook使用yaml语法格式，后缀可以是yaml,也可以是yml。</span><br><span class="line"></span><br><span class="line">在单个playbook文件中，可以连续三个连子号(---)区分多个play。还有选择性的连续三个点好(...)用来表示play的结尾，也可省略。</span><br><span class="line"></span><br><span class="line">次行开始正常写playbook的内容，一般都会写上描述该playbook的功能。</span><br><span class="line"></span><br><span class="line">使用#号注释代码。</span><br><span class="line"></span><br><span class="line">缩进必须统一，不能空格和tab混用。</span><br><span class="line"></span><br><span class="line">缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行实现的。</span><br><span class="line"></span><br><span class="line">YAML文件内容和Linux系统大小写判断方式保持一致，是区分大小写的，k/v的值均需大小写敏感</span><br><span class="line"></span><br><span class="line">k/v的值可同行写也可以换行写。同行使用:分隔。</span><br><span class="line"></span><br><span class="line">v可以是个字符串，也可以是一个列表</span><br><span class="line"></span><br><span class="line">一个完整的代码块功能需要最少元素包括 name: task</span><br></pre></td></tr></table></figure><h2 id="playbook核心元素"><a href="#playbook核心元素" class="headerlink" title="playbook核心元素"></a>playbook核心元素</h2><h3 id="1-Play"><a href="#1-Play" class="headerlink" title="1. Play"></a>1. Play</h3><p>Play 是 Playbook 的基本单元，用于定义在一组主机上执行的一系列任务。一个 Playbook 可以包含多个 Play，每个 Play 在不同的主机或组上执行不同的任务。</p><p>关键字：</p><ul><li>hosts: 指定要在哪些主机或主机组上执行 Play。</li><li>tasks: 包含一系列任务，这些任务会按顺序执行。</li><li>vars: 定义在 Play 中使用的变量。</li><li>roles: 指定要应用的角色。</li><li>gather_facts: 控制是否收集主机的事实信息（默认 true）。</li><li>become: 是否使用 sudo 或其他特权提升执行任务。</li></ul><h3 id="2-Tasks"><a href="#2-Tasks" class="headerlink" title="2. Tasks"></a>2. Tasks</h3><p>Tasks 是 Play 中的核心部分，定义了要执行的具体操作。每个 Task 通常使用一个 Ansible 模块，并可包含条件、循环、错误处理等。</p><p>关键字：</p><ul><li>name: 任务的描述性名称（可选，但推荐使用）。</li><li>   action 或模块名称: 具体执行的操作，如 apt、yum、copy 等。</li><li>   when: 定义条件，满足时才会执行任务。</li><li>   with_items: 用于循环执行任务。</li><li>   register: 保存任务的结果到变量。</li><li>   ignore_errors: 忽略任务执行失败（设为 yes 时）。</li></ul><h3 id="3-Variables"><a href="#3-Variables" class="headerlink" title="3. Variables"></a>3. Variables</h3><p>Variables 是 Playbook 中的动态值，用于提高复用性和灵活性。可以在多个地方定义变量，如 vars、group_vars、host_vars、inventory 文件，或通过命令行传递。</p><p>关键字：<br>-vars: 在 Play 或 Task 中定义变量。<br>-vars_files: 引入外部变量文件。<br>-vars_prompt: 运行时提示用户输入变量值。</p><h3 id="4-Handlers"><a href="#4-Handlers" class="headerlink" title="4. Handlers"></a>4. Handlers</h3><p>Handlers 是一种特殊类型的 Task，只会在被触发时执行。通常用于在配置更改后执行动作，如重启服务。比如我要等服务重启完检查端口监听，就可以用handler</p><p>关键字：<br>-name: Handler 的名称。<br>-notify: 在普通 Task 中调用 notify 触发对应的 Handler。</p><h3 id="5-Roles"><a href="#5-Roles" class="headerlink" title="5. Roles"></a>5. Roles</h3><p>Roles 是 Playbook 中组织和复用任务、变量、文件、模板等的一种方式。Roles 使得 Playbook 更加模块化和可维护。举个例子，我现在要在服务器上部署各种各样的组件，webserver、mysql、redis、ng 等等，我们就可以用这个不同的 roles 来管理，我们可以在创建四个文件夹，分别对应起名 webserver、mysql、redis、ng，然后在这些文件夹里面添加服务部署或者更新需要的东西。</p><p>角色的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_role/</span><br><span class="line">├── tasks/</span><br><span class="line">│   └── main.yml</span><br><span class="line">├── handlers/</span><br><span class="line">│   └── main.yml</span><br><span class="line">├── templates/</span><br><span class="line">├── files/</span><br><span class="line">├── vars/</span><br><span class="line">│   └── main.yml</span><br><span class="line">├── defaults/</span><br><span class="line">│   └── main.yml</span><br><span class="line">└── meta/</span><br><span class="line">    └── main.yml</span><br></pre></td></tr></table></figure><p>roles内各自目录含义：</p><ul><li>files用来存放copy模块或script模块调用的文件</li><li>templates用来存放jinjia2模板，template模块会自动在此目录中寻找jinjia2模板文件</li><li>tasks此目录应当包含一个main.yml文件，用于定义此角色的任务列表，此文件可以使用include包含其它的位于此目录的task文件</li><li>handlers此目录应当包含一个main.yml文件，用于定义此角色中触发条件时执行的动作</li><li>vars此目录应当包含一个main.yml文件，用于定义此角色用到的变量</li><li>defailts此目录应当包含一个main.yml文件，用于为当前角色设定默认变量</li><li>meta此目录应当包含一个main.yml文件，用于定义此角色的特殊设及其依赖关系</li></ul><h3 id="6-Includes-and-Imports"><a href="#6-Includes-and-Imports" class="headerlink" title="6. Includes and Imports"></a>6. Includes and Imports</h3><p>Includes 和 Imports 用于在 Playbook 中包含其他任务、变量、文件等。import_tasks 和 include_tasks 的区别在于，import_tasks 在解析 Playbook 时执行，而 include_tasks 在运行时执行。</p><h3 id="7-Templates"><a href="#7-Templates" class="headerlink" title="7. Templates"></a>7. Templates</h3><p>Templates 是使用 Jinja2 模板引擎的文件，用于动态生成配置文件或其他文件。模板通常存放在 templates&#x2F; 目录下，并通过 template 模块应用到目标主机</p><h3 id="8-Tags"><a href="#8-Tags" class="headerlink" title="8. Tags"></a>8. Tags</h3><p>标签是用于对 play 进行标注，当你写了一个很长的playbook，其中有很多的任务，这并没有什么问题，不过在实际使用这个剧本时，你可能只是想要执行其中的一部分任务而已，或者，你只想要执行其中一类任务而已，而并非想要执行整个剧本中的全部任务，这时，我们可以借助tags模块为任务进行打标签操作，任务存在标签后，我们可以在执行playbook时利用标签，指定执行哪些任务，或者不执行哪些任务</p><p>比如说在实际线上环境中，我们有更新二进制包的操作，那么我们可以在更新二进制的相关 task 中添加名为bin 的 tags，有更新配置文件的操作，那么可以在相关的 tasks 中添加 conf 的 tags</p><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>我们通过一个安装 nginx 的操作来完整演示一下:</p><p>设置项目目录结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ansible.cfg</span><br><span class="line">├── inventory</span><br><span class="line">├── playbook.yml</span><br><span class="line">└── roles</span><br><span class="line">    └── nginx</span><br><span class="line">        ├── tasks</span><br><span class="line">        │   ├── main.yml</span><br><span class="line">        │   └── install.yml</span><br><span class="line">        ├── handlers</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        ├── templates</span><br><span class="line">        │   └── nginx.conf.j2</span><br><span class="line">        ├── files</span><br><span class="line">        ├── vars</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        └── defaults</span><br><span class="line">            └── main.yml</span><br></pre></td></tr></table></figure><p>inventory配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[webservers]</span></span><br><span class="line">192.168.1.101 <span class="attr">ansible_ssh_user</span>=your_user ansible_ssh_pass=your_password ansible_host=<span class="number">203.0</span>.<span class="number">113.1</span></span><br></pre></td></tr></table></figure><p>playbook.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Update</span> <span class="string">and</span> <span class="string">Install</span> <span class="string">Nginx</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">webservers</span>  <span class="comment">#引用组</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span>        <span class="comment">#开启 sudo</span></span><br><span class="line">  <span class="attr">roles:</span>             </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">nginx</span>    <span class="comment">#角色是nginx，对应到  roles/nginx 目录</span></span><br><span class="line">      <span class="attr">tags:</span>          <span class="comment">#两个 tags</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">conf</span></span><br></pre></td></tr></table></figure><p>任务文件 roles&#x2F;nginx&#x2F;tasks&#x2F;main.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 包含其他任务文件, 这里直接用 install.yml里面的文件内容肯定也是没问题的，但是我们可以通过这样的方式更好的进行管理</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include_tasks:</span> <span class="string">install.yml</span></span><br></pre></td></tr></table></figure><p>安装任务 roles&#x2F;nginx&#x2F;tasks&#x2F;install.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 更新安装 Nginx</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Update</span> <span class="string">apt</span> <span class="string">cache</span> <span class="string">and</span> <span class="string">install</span> <span class="string">Nginx</span></span><br><span class="line">  <span class="attr">apt:</span>                  <span class="comment">#安装nginx 相关包, 不同平台不太一样，比如 centos 可以使用 package</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">latest</span></span><br><span class="line">    <span class="attr">update_cache:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bin</span>               <span class="comment">#这里添加了 bin 的 tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署 Nginx 配置文件</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Nginx</span> <span class="string">configuration</span> <span class="string">from</span> <span class="string">template</span></span><br><span class="line">  <span class="attr">template:</span>              <span class="comment">#这里是更新 nginx 配置文件</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">nginx.conf.j2</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">&#x27;0644&#x27;</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Nginx</span>   <span class="comment">#这里配合handler 使用，handlers 里面会有一个名称为 “Restart Nginx”的操作</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">conf</span>                <span class="comment">#这里添加了 conf 的 tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 Nginx 是否监听正确端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">Nginx</span> <span class="string">is</span> <span class="string">listening</span> <span class="string">on</span> <span class="string">port</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">ss</span> <span class="string">-tuln</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">:80</span>    <span class="comment">#通过 command 模块，ss 命令监听 80 端口是否启动</span></span><br><span class="line">  <span class="attr">register:</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">ignore_errors:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">Nginx</span> <span class="string">listening</span> <span class="string">port</span> <span class="string">check</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; result.stdout &#125;&#125;</span>&quot;</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">result.rc</span> <span class="string">==</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>处理程序 roles&#x2F;nginx&#x2F;handlers&#x2F;main.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 当配置文件变更时，重启 Nginx, 和上面的 notify 是对应的</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Nginx</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>模板文件 roles&#x2F;nginx&#x2F;templates&#x2F;nginx.conf.j2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen &#123;&#123; nginx_port &#125;&#125;;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认变量 roles&#x2F;nginx&#x2F;defaults&#x2F;main.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">nginx_port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>当我们更新安装时,可以通过(在正式执行前，可以在后面加-C -D 做测试使用):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook playbook.yml </span><br></pre></td></tr></table></figure><p>后续有二进制更新时，可以通过:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook playbook.yml -t bin</span><br></pre></td></tr></table></figure><p>后续有配置文件更新时，可以通过:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook playbook.yml -t conf</span><br></pre></td></tr></table></figure><h2 id="逻辑控制语句"><a href="#逻辑控制语句" class="headerlink" title="逻辑控制语句"></a>逻辑控制语句</h2><h3 id="条件语句when"><a href="#条件语句when" class="headerlink" title="条件语句when"></a>条件语句when</h3><p>when条件支持多种判断类型，主要用于根据某些条件决定是否执行某个任务。这些判断类型通常基于Python的语法，因为Ansible的任务是用Python编写的</p><p>主要支持的判断类型:</p><ul><li>比较运算符：&#x3D;&#x3D;, !&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 用于比较两个值。</li><li>字符串方法：.startswith(), .endswith(), .find(), .contains() 等字符串方法可以用来检查字符串的特性。</li><li>逻辑运算符：and, or, not 用于组合多个条件。</li><li>Jinja2模板表达式：由于Ansible使用Jinja2作为模板引擎，因此你也可以在when条件中使用Jinja2的表达式和过滤器。</li><li>Ansible事实（facts）和变量：你可以使用Ansible收集的主机事实（facts）和定义的变量来进行条件判断。</li><li>函数和内置方法：Python的内置函数和方法也可以在when条件中使用，比如isinstance(), len(), 等等。</li><li>正则表达式：使用Python的正则表达式模块（如re）进行更复杂的字符串匹配。</li></ul><p>其中facts涉及到的判断条件非常多，可以通过如下形式获取</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">show</span> <span class="string">ansible</span> <span class="string">facts</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">ansible_facts</span></span><br></pre></td></tr></table></figure><p>执行以上yml文件之后，会输出一个json串，我们就可以获取到所有的fact信息了.</p><p>示例：假如我们想在ip为 192.168.0.102 的机器上创建文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">when测试练习</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">文件测试创建</span></span><br><span class="line">      <span class="attr">file:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/tmp/when.txt</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">&quot;&#x27;192.168.0.102&#x27; in ansible_all_ipv4_addresses&quot;</span></span><br></pre></td></tr></table></figure><h3 id="循环语句loop"><a href="#循环语句loop" class="headerlink" title="循环语句loop"></a>循环语句loop</h3><p>用于在任务中循环执行操作</p><p>示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">multiple</span> <span class="string">packages</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">packages</span></span><br><span class="line">      <span class="attr">apt:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">      <span class="attr">loop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">git</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">curl</span></span><br></pre></td></tr></table></figure><p>上面的示例就是循环装包</p><h3 id="块语句block"><a href="#块语句block" class="headerlink" title="块语句block"></a>块语句block</h3><p>在 Ansible 中，block 关键字允许你将多个任务组合成一个逻辑块，并对这个块应用一些条件或错误处理逻辑。这是 Ansible 2.5 版本及以后引入的一个功能，它提供了更高级的任务组织方式。简单来说，block任务块就是一组逻辑的tasks。使用block可以将多个任务合并为一个组。</p><p>playbook会定义三种块，三种块的作用分别如下:</p><ul><li>block: block里的tasks,如果运行正确,则不会运行rescue；</li><li>rescue：block里的tasks,如果运行失败,才会运行rescue里的tasks</li><li>always：block和rescue里的tasks无论是否运行成功，都会运行always里的tasks</li></ul>]]></content>
    
    
    <summary type="html">本文将对 ansible 工具的具体使用做一个详细的介绍</summary>
    
    
    
    <category term="运维工具" scheme="http://baixiaozhou.github.io/categories/%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="ansible" scheme="http://baixiaozhou.github.io/tags/ansible/"/>
    
    <category term="运维工具" scheme="http://baixiaozhou.github.io/tags/%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>线上故障排查方法和工具介绍</title>
    <link href="http://baixiaozhou.github.io/p/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://baixiaozhou.github.io/p/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2024-08-15T03:12:21.000Z</published>
    <updated>2024-08-29T02:33:03.003Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><div class="tag-plugin quot"><p class="content" type="text"><span class="empty"></span><span class="text">参考文档</span><span class="empty"></span></p></div><p><a href="https://www.linuxjournal.com/article/9001">Examining Load Average</a><br><a href="https://community.tenable.com/s/article/What-is-CPU-Load-Average">What-is-CPU-Load-Average</a><br><a href="www.brendangregg.com">Brendan Gregg个人网站</a></p><ul><li><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a></li><li><a href="#linux%E6%80%A7%E8%83%BD%E8%B0%B1%E5%9B%BE">Linux性能谱图</a></li><li><a href="#cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87">CPU使用率飙升</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E8%AE%A9cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87">如何让CPU使用率飙升</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%92%8C%E5%8F%91%E7%8E%B0cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87">如何判断和发现CPU使用率飙升</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E9%A3%99%E5%8D%87%E7%9A%84%E6%A0%B9%E6%BA%90">如何确定CPU飙升的根源</a><ul><li><a href="#perf%E5%91%BD%E4%BB%A4">perf命令</a></li><li><a href="#jstack">jstack</a></li><li><a href="#%E7%81%AB%E7%84%B0%E5%9B%BE">火焰图</a></li></ul></li></ul></li><li><a href="#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87">负载飙升</a><ul><li><a href="#%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%B4%9F%E8%BD%BD">负载的定义以及如何查看负载</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%A3%99%E9%AB%98">如何让系统负载飙高</a><ul><li><a href="#%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D">纯计算任务对负载的影响</a></li><li><a href="#%E7%A3%81%E7%9B%98-io-%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D">磁盘 IO 对负载的影响</a></li><li><a href="#%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C-io-%E6%A8%A1%E6%8B%9F-d-%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E8%A7%82%E5%AF%9F%E8%B4%9F%E8%BD%BD%E5%BD%B1%E5%93%8D">通过网络 IO 模拟 D 状态进程观察负载影响</a></li></ul></li><li><a href="#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5">负载飙升如何排查</a></li></ul></li><li><a href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98">内存占用过高</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98">如何判断内存占用过高</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98">如何定位内存占用高</a><ul><li><a href="#java-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98">JAVA 占用内存过高</a><ul><li><a href="#%E5%A0%86%E5%86%85%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">堆内内存分析</a></li><li><a href="#%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">本地内存分析</a></li><li><a href="#%E5%85%B6%E4%BB%96%E9%9D%9E%E5%A0%86%E5%86%85%E5%AD%98">其他非堆内存</a></li></ul></li><li><a href="#golang%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E9%AB%98">golang程序占用内存高</a></li><li><a href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8D%A0%E7%94%A8">基于内存的文件系统占用</a></li></ul></li></ul></li><li><a href="#%E7%A3%81%E7%9B%98%E9%97%AE%E9%A2%98">磁盘问题</a><ul><li><a href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3">磁盘空间不足</a></li><li><a href="#%E7%A3%81%E7%9B%98io%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">磁盘IO性能问题</a></li></ul></li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在很多文章中，每当提到去解决线上问题的时候，大部分的处理方式就是登录环境，哐哐各种敲命令。操作本身没什么问题，但是对于很多人而言，我觉得这种做法其实是本末倒置的，过于在乎去快速抓住重点问题，而忽略了从全局去看问题。那么如果最开始不去操作各种命令，那应该干什么呢？</p><p><em><strong>看监控！！！！</strong></em></p><p>首先不要觉得这个是废话，对于很多场景来说，业务规模是不断变化的，有的时候并发超过了极限的性能，那么这种情况下都没有必要去后台进行各种查询。举个简单的例子，假如说某套业务系统，本身只能支持 500 并发，现在实际上的量到了 2000，导致线上各种内存、CPU、负载的告警，这种情况下还有必要去后台敲<code>top</code>、<code>free</code>吗？答案当然是否定的，这种情况下，就需要考虑对业务系统进行快速的扩容等。</p><p>看监控的意义在于尽可能的找到更多的性能瓶颈或者异常的点，从全局出发，对系统当前存在的问题和异常点有全面的了解。</p><p>监控系统多种多样，从较早的 zabbix 到现在比较流行的prometheus+grafana（举两个常用的例子），对于系统业务都有比较完善的监控，可以帮助我们更加具体的了解到系统运行全貌。如果你对这些都不喜欢，那么你自己写一个监控系统也没什么问题。</p><p>当我们看完监控之后（假设你真的看了），接下来进入实际操作环节，我会从这些指标的详细含义出发，然后尽可能地将各种处理方式分享给大家。</p><h2 id="Linux性能谱图"><a href="#Linux性能谱图" class="headerlink" title="Linux性能谱图"></a>Linux性能谱图</h2><p>在分析问题前，我们首先需要明确 Linux 有哪些性能分析工具，我们先上一下LINUX 性能专家 Brendan Gregg 总结的图（大家如果对性能分析等感兴趣的话，可以认真看下这位大佬的个人网站）:</p><div class="tag-plugin image"><div class="image-bg"><img src="https://www.brendangregg.com/Perf/linux_observability_tools.png" alt="Linux Performance Observability Tool" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">Linux Performance Observability Tool</span></div></div><p>上面这张图是引用大佬文章的图，原文链接在这里: <a href="https://www.brendangregg.com/linuxperf.html">https://www.brendangregg.com/linuxperf.html</a></p><h2 id="CPU使用率飙升"><a href="#CPU使用率飙升" class="headerlink" title="CPU使用率飙升"></a>CPU使用率飙升</h2><h3 id="如何让CPU使用率飙升"><a href="#如何让CPU使用率飙升" class="headerlink" title="如何让CPU使用率飙升"></a>如何让CPU使用率飙升</h3><p>这个问题其实很简单，只要有计算任务一直存在，让 CPU 一直处于繁忙之中，那么 CPU 必然飙升。我们可以通过一系列的工具去模拟这个情况。</p><p><a href="https://github.com/baixiaozhou/SysStress">github SysStress</a> 这是我自己用 golang 写的压测工具(还在开发中，可以点个 star 让我更有动力😂)</p><p>使用方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sysstress cpu --cpu-number 10 --duration 10m</span><br></pre></td></tr></table></figure><p>这个就是模拟占用 10 核心的 CPU 并持续 10min，当然大家也可以用其他的压测工具，比如<code>stress-ng</code></p><h3 id="如何判断和发现CPU使用率飙升"><a href="#如何判断和发现CPU使用率飙升" class="headerlink" title="如何判断和发现CPU使用率飙升"></a>如何判断和发现CPU使用率飙升</h3><p>首先我们先看一下，跟 CPU 使用率相关的有哪些指标。我们通过 <code>top</code> 命令就可以看到具体的信息</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/top.png" alt="top" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">top</span></div></div><!-- ![top](../images/top.png) --><p>这些输出中有一行是 <code>%Cpu(s)</code>, 这行展示了 CPU 的整体使用情况，是一个百分比的形式，我们详细阐述下这几个字段的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">us, user    : time running un-niced user processes   未降低优先级的用户进程所占用的时间</span><br><span class="line">sy, system  : time running kernel processes          内核进程所占用的时间</span><br><span class="line">ni, nice    : time running niced user processes      降低优先级的用户进程所占用的时间</span><br><span class="line">id, idle    : time spent in the kernel idle handler  空闲的时间</span><br><span class="line">wa, IO-wait : time waiting for I/O completion        等待 I/O 操作完成所花费的时间</span><br><span class="line">hi : time spent servicing hardware interrupts        处理硬件中断所花费的时间</span><br><span class="line">si : time spent servicing software interrupts        处理软件中断所花费的时间</span><br><span class="line">st : time stolen from this vm by the hypervisor      被虚拟机管理程序从此虚拟机中窃取的时间</span><br></pre></td></tr></table></figure><p>在这些指标中，一般关注的比较多的就是 us、sy、id、wa（其他几个指标很高的情况我个人目前基本上没有遇到过）</p><p>上述指标反映了系统整体的 CPU 情况。而程序在操作系统中实际上是以一个个的进程存在的，那我们如何确定到占用 CPU 高的进程呢？让我们的目光从 top 的头部信息往下移动，下面就展示了详细的进程信息</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/top-process.png" data-fancybox="true"/></div></div><!-- !cess](../imagescess.png) --><p>这些程序默认是按照 CPU 的使用率从高到底进行排序的，当然你也可以通过在<code>top</code>的时候输入<code>P</code>进行排序，这样我们就可以看到系统中消耗 CPU 资源的详细进程信息</p><p>上面是我通过 <code>./sysstress cpu --cpu-number 10 --duration 10m</code> 压测程序跑出来的，可以看到这里的 sysstress 程序占用了 1002 的 %CPU，也就是说基本上是 10 个核心，那我们跑一个更高的，将<code>--cpu-number</code>加到 60 看看发生了什么</p><!-- ![stress-cpu](../images/stress-cpu.png) --><div class="tag-plugin image"><div class="image-bg"><img src="/images/stress-cpu.png" alt="stress-cpu" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">stress-cpu</span></div></div><p>我们可以看到这次%CPU打到了 6000，那很多人就好奇我日常的程序跑到多高算高呢？</p><p>这里我们需要明确一点，现在的服务器绝大部分都是多核心 CPU（1C2G这种自己用来玩的忽略），CPU 的核心数决定了我们程序在同一时间能够执行多少个线程，也就是说，这个高不高是相对于机器配置而言的。如果你的机器只有 16C，那么单个进程占用的 %CPU 到 1000，那么其实已经算是比较高了。如果是 256C 的CPU（土豪级配置），那么单个进程占用的 %CPU 到 6000，对于系统的稳定性影响就没有那么大了。</p><p>上述我们说的情况是进程占用 CPU 对整个系统的影响，那么进程占用的 CPU 对系统的影响不大就代表这个程序一定没有问题吗？答案显然是未必的。</p><p>我们还是要回归到业务本身，如果进程的 CPU 占用在业务变动不大的情况下，发生了异常波动，或者正常情况下业务不会消耗这么高的 CPU，那么我们就需要继续排查了。</p><h3 id="如何确定CPU飙升的根源"><a href="#如何确定CPU飙升的根源" class="headerlink" title="如何确定CPU飙升的根源"></a>如何确定CPU飙升的根源</h3><p>这个问题的 核心是 CPU 上在运行什么东西。 多核心CPU 下，每个核心都可以执行不同的程序，我们如何确定一个进程中那些方法在消耗 CPU 呢？从而引申下面详细的问题:</p><ol><li>程序的调用栈是什么样的？</li><li>调用栈信息中哪些是需要关注的，那些是可以忽略的？</li><li>热点函数是什么？</li></ol><p>老话说得好，”工欲善其事，必先利其器”, 我们需要这些东西，就必须了解到什么样的工具可以拿到上面我提到的一些信息。接下来我将通过常用的后端语言：<code>golang</code> 和 <code>java</code> 为例构造一些高 CPU 的程序来进行展示。</p><h4 id="perf命令"><a href="#perf命令" class="headerlink" title="perf命令"></a>perf命令</h4><p><strong>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。</strong></p><p>安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install perf   #Centos</span><br></pre></td></tr></table></figure><p>安装完成后，我们可以首先看下 <code>perf</code>的用法，这里不展开具体用法，只列出我平常使用的几个命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top        System profiling tool.               #对系统性能进行实时分析。</span><br><span class="line">record     Run a command and record its profile into perf.data     #收集采样信息</span><br><span class="line">report     Read perf.data (created by perf record) and display the profile  #分析采样信息，和record配合使用</span><br></pre></td></tr></table></figure><p>record 和 report 的使用更多在于 dump 当前环境的信息用于后续分析，如果在自己环境上测试，可以用 top 进行一些简单的实时分析（类似于 top 命令）。</p><p>还是用之前的压测工具，我们模拟一个 10 核心的 10min 的压测场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./sysstress cpu --cpu-number 10 --duration 10m &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>执行这个语句，让压测程序在后台执行，然后我们通过<code>perf top</code>查看具体的情况（可以通过-p 指定 pid）</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/perftop.png" alt="perf top," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">perf top,</span></div></div><!-- ![perf top](../images/perftop.png) --><p>从截图的信息中我们可以看到占用资源最多的一些方法，包括 sysstress 进程的各种方法(从图片中基本上就可以确定高消耗的方法在哪里)以及底层的 <code>__vdso_clock_gettime</code>, 那再结合压测工具的代码分析下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">burnCpu</span><span class="params">(wg *sync.WaitGroup, start time.Time, durSec <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = <span class="number">1</span> * <span class="number">1</span></span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="keyword">if</span> now.Sub(start) &gt; time.Duration(durSec)*time.Second &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是方法的核心，其实就是做无意义的计算，外加时间的判断，超过 duration 就结束。这样和上面的 perf top 信息就能对应起来。</p><p>然后我们用 java 写一个同样的程序，再看看 <code>perf top</code>的情况:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/javaperftop.png" alt="perf top," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">perf top,</span></div></div><!-- ![perf top](../images/javaperftop.png) --><p>从这一大段显示来看，是不是看的一脸懵逼，很难发现到底是什么程序在占用CPU 资源。大家可以看一下源程序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        Math.sin(Math.random());</span><br><span class="line">                        <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的程序也是非常简单，启动 10 个线程，做一个无意义的数学运算，然后获取当前时间。从这段代码中是不是很难和上面<code>perf top</code>的显示关联起来？ 原因也非常简单， 像Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。那我们好能通过 perf 去看到 java 相关的堆栈吗？答案是可以的。</p><p>可以借助 <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a> 这样的开源工具，去生成和<code>perf</code> 工具一起使用的方法映射，但是需要做额外的一些配置。这里的方法大家可以自己探究，为什么不详细的讲这个呢，原因也简单，排查问题的工具多种多样，没必要在一棵树上吊死。</p><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>既然 perf top 去查看 JAVA 的调用栈不太方便，我们就直接上 java 提供的 jstack 工具去分析。</p><ul><li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li><li>kill -3， jstack 用不了的情况下可以使用 kill -3 pid 的形式，堆栈会输出在系统日志中。</li></ul><p>具体的操作步骤:</p><ol><li><code>top -Hp $pid</code> 找到占用 CPU 的具体线程</li><li><code>jstack -l $pid &gt; /tmp/$pid.jstack</code> 或者 <code>kill -3 $pid</code>将 java 进程的堆栈情况输出的日志中，然后根据 <code>top -Hp</code> 看到的线程信息在输出的堆栈日志中进行查找（<code>top -Hp</code> 输出的是 10 进制的 id，<code>jstack</code> 输出的是 16 进制的，在查找时注意进制转换）</li></ol><p>我们看下上面 java 程序的堆栈的信息:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-08</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">15</span>:<span class="number">40</span></span><br><span class="line">Full thread <span class="built_in">dump</span> Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (<span class="number">25.221</span>-b11 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Attach Listener&quot;</span> #<span class="number">35</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f52b4001000</span> nid=<span class="number">0x71f4</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DestroyJavaVM&quot;</span> #<span class="number">34</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e0009800</span> nid=<span class="number">0x1693</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> #<span class="number">25</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e015a800</span> nid=<span class="number">0x16d9</span> runnable [<span class="number">0x00007f52f64e3000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class="line">at java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class="number">755</span>)</span><br><span class="line">at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class="number">938</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class="number">267</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class="number">227</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class="number">120</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">411</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">359</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">315</span>)</span><br><span class="line">at java.util.TimeZone.toZoneId(TimeZone.java:<span class="number">556</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.systemDefault(ZoneId.java:<span class="number">274</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.Clock.systemDefaultZone(Clock.java:<span class="number">178</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.LocalDateTime.now(LocalDateTime.java:<span class="number">180</span>)</span><br><span class="line">at Main$<span class="number">1.</span>run(Main.java:<span class="number">12</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> #<span class="number">24</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e0159000</span> nid=<span class="number">0x16d8</span> runnable [<span class="number">0x00007f52f65e4000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class="line">at java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class="number">755</span>)</span><br><span class="line">at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class="number">938</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class="number">267</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class="number">227</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class="number">120</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">411</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">359</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.of(ZoneId.java:<span class="number">315</span>)</span><br><span class="line">at java.util.TimeZone.toZoneId(TimeZone.java:<span class="number">556</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.ZoneId.systemDefault(ZoneId.java:<span class="number">274</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.Clock.systemDefaultZone(Clock.java:<span class="number">178</span>)</span><br><span class="line">at java.<span class="built_in">time</span>.LocalDateTime.now(LocalDateTime.java:<span class="number">180</span>)</span><br><span class="line">at Main$<span class="number">1.</span>run(Main.java:<span class="number">12</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"> <span class="comment">--- 10 个 thread</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Service Thread&quot;</span> #<span class="number">23</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e0143800</span> nid=<span class="number">0x16d6</span> runnable [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;C2 CompilerThread1&quot;</span> #<span class="number">6</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e010e000</span> nid=<span class="number">0x16c5</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"> <span class="comment">--- 一大堆 C2 CompilerThread</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;C2 CompilerThread0&quot;</span> #<span class="number">5</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e010b000</span> nid=<span class="number">0x16c4</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Signal Dispatcher&quot;</span> #<span class="number">4</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e0109800</span> nid=<span class="number">0x16c3</span> runnable [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Finalizer&quot;</span> #<span class="number">3</span> daemon prio=<span class="number">8</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e00d8800</span> nid=<span class="number">0x16c2</span> <span class="keyword">in</span> Object.wait() [<span class="number">0x00007f52f7bfa000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;<span class="number">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.<span class="built_in">remove</span>(ReferenceQueue.java:<span class="number">144</span>)</span><br><span class="line">- locked &lt;<span class="number">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.<span class="built_in">remove</span>(ReferenceQueue.java:<span class="number">165</span>)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">216</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Reference Handler&quot;</span> #<span class="number">2</span> daemon prio=<span class="number">10</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e00d3800</span> nid=<span class="number">0x16c1</span> <span class="keyword">in</span> Object.wait() [<span class="number">0x00007f52f7cfb000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;<span class="number">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">- locked &lt;<span class="number">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;VM Thread&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e00ca000</span> nid=<span class="number">0x16c0</span> runnable</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e001f000</span> nid=<span class="number">0x1694</span> runnable</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 一大堆 GC task thread</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f53e0146000</span> nid=<span class="number">0x16d7</span> waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: <span class="number">202</span></span><br></pre></td></tr></table></figure><p>我们通过 top -Hp 的信息就可以快速定位到 Thread-[0-9] 这几个线程，而每个线程的调用栈都是 <code>java.time.LocalDateTime.now</code>, 也说明了这个方法在不停消耗 CPU。（但是 jstack 只能捕获短时间或者瞬时的堆栈信息，没法处理长时间的，所以我们在获取时可以多打印几次或者使用其他方法）</p><p>至于 jstack 的详细用法，请参考我的另一篇博客：<a href="https://baixiaozhou.github.io/2024/08/13/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">java问题定位</a></p><p>除此之外，还有非常多的分析工具，pstack\gstack\strace\gdb等等，大家可以自行探索使用</p><h4 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h4><p>上面我们介绍了很多操作的命令和方法，那么有没有一种比较直观的方式能够直接看到各种方法执行的耗时比重等情况呢？火焰图就是为了解决这种情况而生的。</p><p>火焰图的分类有很多，常用的包括:</p><ol><li>CPU 火焰图 (CPU Flame Graph)<ul><li>   描述：展示 CPU 在不同方法上的消耗情况，显示每个方法调用所占用的 CPU 时间。</li><li>   用途：用于分析 CPU 性能瓶颈，识别哪些方法消耗了最多的 CPU 资源。</li><li>   应用：Java、C++ 等多种编程语言的性能分析。</li></ul></li><li>内存火焰图 (Memory Flame Graph)<ul><li>描述：展示内存分配情况，显示每个方法调用分配的内存量。</li><li>用途：用于检测内存泄漏、过度内存分配问题，帮助优化内存使用。</li><li>应用：常用于分析内存密集型应用，如 Java 应用的堆内存分析。</li></ul></li><li>I&#x2F;O 火焰图 (I&#x2F;O Flame Graph)<ul><li>   描述：展示 I&#x2F;O 操作的耗时情况，显示不同方法的 I&#x2F;O 操作占用的时间。</li><li>   用途：用于分析应用程序的 I&#x2F;O 性能，识别慢速或频繁的 I&#x2F;O 操作。</li><li>   应用：数据库查询、文件系统操作、网络通信等场景的性能调优。</li></ul></li></ol><p>我们这里通过 <a href="https://github.com/async-profiler/async-profiler">async-profiler</a> 对文章上面的java压测程序进行抓取(这个工具只能抓 java 的, 对于 golang 程序，可以利用 golang 提供的 pprof)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf async-profiler-3.0-linux-x64.tar.gz</span><br><span class="line">cd async-profiler-3.0-linux-x64/bin</span><br><span class="line">./asprof -d 60 pid -f /tmp/javastress.html</span><br></pre></td></tr></table></figure><p>我们用浏览器打开生成的 html 文件，可以看到如下的火焰图信息（可以在网页进行点击，查看更细节的方法）</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/javafire.png" alt="java 程序的火焰图," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">java 程序的火焰图,</span></div></div><!-- ![java 程序的火焰图](../images/javafire.png) --><p>这样看起来就比 jstack这些信息更加直观一点。</p><h2 id="负载飙升"><a href="#负载飙升" class="headerlink" title="负载飙升"></a>负载飙升</h2><h3 id="负载的定义以及如何查看负载"><a href="#负载的定义以及如何查看负载" class="headerlink" title="负载的定义以及如何查看负载"></a>负载的定义以及如何查看负载</h3><p>我们先看下系统负载的官方描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in arunnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access,eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs ina  system,  so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.</span><br></pre></td></tr></table></figure><p>系统负载平均值表示处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。处于不可中断状态的进程正在等待某些 I&#x2F;O 访问，例如等待磁盘。这里的核心概念就是 loadavg 这个数值体现了某些特定状态进程的数量。</p><p>那引申出两个问题:</p><ol><li>进程的状态有哪些？ 如何在 Linux 上查看进程状态</li><li>可运行和不可中断状态的进程具体含义是什么</li></ol><p>查看的方式，我们可以通过 ps 命令进行查看，比如通过<code>ps -auxf</code>, 我么可以看到有一列为 <code>STAT</code>,这列就代表该进程的状态:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/psauxf.png" alt="进程状态" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">进程状态</span></div></div><p>进程的状态和具体含义:</p><ul><li>D    uninterruptible sleep (usually IO)</li><li>R    running or runnable (on run queue)</li><li>S    interruptible sleep (waiting for an event to complete)</li><li>T    stopped by job control signal</li><li>t    stopped by debugger during the tracing</li><li>W    paging (not valid since the 2.6.xx kernel)</li><li>X    dead (should never be seen) </li><li>Z    defunct (“zombie”) process, terminated but not reaped by its parent</li></ul><p>这里我们看到处于不可中断的状态的进程和正在运行的进程分别为 <code>D</code> 和 <code>R</code>,换个说法，也就是说造成负载升高的原因也就是这两个状态的进程引起的。</p><p>（插个题外话，按照官方的说法，X 状态的进程应该是不应该被看到的， 但是之前在腾讯云做ES的时候，偶然间碰到了一次，当时还截了个图用做留念😂，但是没有捕获到具体的信息）</p><p>负载的指标可以通过 <code>top</code> 以及 <code>uptime</code> 指令获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23:35:00 up 1 day, 46 min,  1 user,  load average: 49.16, 18.35, 7.87</span><br></pre></td></tr></table></figure><p>这里展示了 loadavg 的三个数值: 分别代表的含义是 1min、5min、15min 的系统平均负载</p><p>那我们如何判断系统的负载是高是低呢？</p><p>这里一般有个经验值，我们一般和 CPU 和核心数进行对比，一般负载在 CPU 核心的 70% 左右以及以下，对系统一般没什么影响，超过 70%，系统可能收到影响。但是这里还需要注意的一点就是，负载的比例在 70% 以下时不一定代表系统就没问题，举个简单的例子，如果一个系统上基本上没有业务在运行，那么负载基本上就在零点几左右，那么这种情况下，负载有升高不一定是合理的（后面举一个简单的例子）</p><h3 id="如何让系统负载飙高"><a href="#如何让系统负载飙高" class="headerlink" title="如何让系统负载飙高"></a>如何让系统负载飙高</h3><h4 id="纯计算任务对负载的影响"><a href="#纯计算任务对负载的影响" class="headerlink" title="纯计算任务对负载的影响"></a>纯计算任务对负载的影响</h4><p>既然说正在运行的进程会引起负载的变化，那么跑一些程序，让程序不停运行，那么自然而然就能构造出持续运行的进程了。<br>我这里找了三台机器(64C)，用我的压测工具先跑一些纯 CPU 的运算，然后观察下效果：</p><p>测试分为三组，测试前关闭不必要的服务和进程:</p><ol><li>10 并发 30min<ul><li><code>nohup ./sysstress cpu --cpu-number 10 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li></ul></li><li>30 并发 30min<ul><li><code>nohup ./sysstress cpu --cpu-number 30 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li></ul></li><li>60 并发 30min<ul><li><code>nohup ./sysstress cpu --cpu-number 60 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li></ul></li></ol><p>效果如下:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/load10.png" alt="10并发负载," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">10并发负载,</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/images/load30.png" alt="30并发负载," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">30并发负载,</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/images/load60.png" alt="60并发负载," data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">60并发负载,</span></div></div><!-- ![10并发负载](../images/load10.png)![30并发负载](../images/load30.png)![60并发负载](../images/load60.png) --><p>从上述测试过程中，我们可以发现，在纯运算这种场景下，并发的量基本上和负载是对应的。也就是说随着 CPU的使用量 上涨，负载也会不断变高。</p><h4 id="磁盘-IO-对负载的影响"><a href="#磁盘-IO-对负载的影响" class="headerlink" title="磁盘 IO 对负载的影响"></a>磁盘 IO 对负载的影响</h4><p>在刚才的例子中，我们看到了纯运算对负载的影响（R 进程的代表），然后在关于 D 进程的说明中，我们可以看到有一个比较明显的说明 <code>(usually IO)</code> ,即通常是 IO 引起的，那么接下来我们通过磁盘 IO 来测试一下</p><p>测试分为三组，测试前关闭不必要的服务和进程:</p><ol><li>10 并发 15min<ul><li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 10 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li></ul></li><li>30 并发 15min<ul><li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 30 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li></ul></li><li>60 并发 15min<ul><li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 60 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li></ul></li></ol><p>效果如下:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/ioload10.png" alt="10并发负载" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">10并发负载</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/images/ioload30.png" alt="30并发负载" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">30并发负载</span></div></div><div class="tag-plugin image"><div class="image-bg"><img src="/images/ioload60.png" alt="60并发负载" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">60并发负载</span></div></div><p>我们也顺便看一下，60 并发下 CPU 的情况:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/io60c.png" alt="60并发系统整体情况" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">60并发系统整体情况</span></div></div><p>这里我们可以观察到，系统的 CPU 基本上已经跑满了。us 和 sy 都占的比较多，但是这种读取非常有可能走到缓存中，我们想测绕过缓存，可以通过 DIRECT 的方式。</p><p>但是上面的例子其实也证明了一件事，IO 的操作也是会导致负载产生飙升。</p><p>那么问题来了，磁盘IO 和 CPU 操作都会导致系统负载飙升，那么负载飙升一定会是这两个原因吗？答案也是未必的，因为上述我们曾经提到过 D 状态的进程，到目前为止我们好像还没介绍过，那么我们来继续模拟，既然 D 状态的进程是 IO 操作引起的，普通的磁盘读写 IO 很难模拟，那我们就换个 IO 场景继续模拟 – 网络 IO。</p><h4 id="通过网络-IO-模拟-D-状态进程观察负载影响"><a href="#通过网络-IO-模拟-D-状态进程观察负载影响" class="headerlink" title="通过网络 IO 模拟 D 状态进程观察负载影响"></a>通过网络 IO 模拟 D 状态进程观察负载影响</h4><p>这里直接上一个模拟方法:</p><ul><li>A 机器开启 NFS Server</li><li>B 机器作为客户端进行挂载</li><li>断开网络</li><li>疯狂 df -h</li></ul><p>详细的操作步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Centos</span><br><span class="line">sudo yum install nfs-utils</span><br><span class="line"></span><br><span class="line"># 服务端配置</span><br><span class="line">sudo mkdir -p /mnt/nfs_share</span><br><span class="line">sudo chown nobody:nogroup /mnt/nfs_share</span><br><span class="line">sudo chmod 755 /mnt/nfs_share</span><br><span class="line">## 打开 /etc/exports 配置，添加一行来定义共享目录及其权限。例如，将 /mnt/nfs_share 共享给网络 192.168.1.0/24，并提供读写权限：</span><br><span class="line">/mnt/nfs_share 192.168.1.0/24(rw,sync,no_subtree_check)</span><br><span class="line"></span><br><span class="line">## 启动 NFS</span><br><span class="line">sudo exportfs -a</span><br><span class="line">sudo systemctl restart nfs-kernel-server</span><br><span class="line">sudo systemctl enable nfs-kernel-server</span><br><span class="line"></span><br><span class="line"># 客户端配置</span><br><span class="line">sudo mkdir -p /mnt/nfs_client</span><br><span class="line">sudo mount -t nfs 192.168.1.100(server ip):/mnt/nfs_share /mnt/nfs_client</span><br><span class="line">## 验证</span><br><span class="line">df -h /mnt/nfs_client</span><br><span class="line"></span><br><span class="line"># 断网模拟(客户端)</span><br><span class="line">iptables -I INPUT -s serverip -j DROP</span><br><span class="line"></span><br><span class="line"># 持续(疯狂)执行：</span><br><span class="line">du -sh /mnt/nfs_client</span><br></pre></td></tr></table></figure><p>因为网络已经断掉，所以<code>du -sh /mnt/nfs_client</code>,而且这个程序没有自动退出或者报错，这样就导致程序无法顺利执行下去，继而阻塞住就变成了 D 状态的进程。</p><p>基于这种模拟方法大家可以自行测试下，笔者之前做过一个场景，将一个两核心的 CPU负载干到了 200 多，但是因为<strong>这种情况下更多是阻塞在网络中，所以此时的负载虽高，并不一定影响系统运行</strong>。</p><p>当然这只是其中一个例子，笔者曾经也因为见过 ping 操作阻塞导致的负载飙升，所以这种场景是多种多样的😂，大家有更多的例子也可以在下方留言，共同学习进步。</p><h3 id="负载飙升如何排查"><a href="#负载飙升如何排查" class="headerlink" title="负载飙升如何排查"></a>负载飙升如何排查</h3><p>基于上面的例子和场景模拟，我们其实应该已经有一套基本的排查方法了，下面这张图是我个人的一些总结(图还会不断完善)</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/loadhigh.png" alt="负载高排查导图" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">负载高排查导图</span></div></div><h2 id="内存占用过高"><a href="#内存占用过高" class="headerlink" title="内存占用过高"></a>内存占用过高</h2><p>我们先来了解一下有哪些常用的内存性能工具:</p><table><thead><tr><th>工具</th><th>功能</th><th>用法</th><th>常用选项</th></tr></thead><tbody><tr><td><code>free</code></td><td>显示系统的内存使用情况</td><td><code>free -h</code></td><td><code>-h</code>：以人类可读的格式显示</td></tr><tr><td><code>top</code></td><td>实时显示系统的进程和内存使用情况</td><td><code>top</code></td><td>无</td></tr><tr><td><code>htop</code></td><td>提供更友好的用户界面的进程监控工具</td><td><code>htop</code></td><td>无</td></tr><tr><td><code>vmstat</code></td><td>报告虚拟内存、进程、CPU 活动等统计信息</td><td><code>vmstat 1</code></td><td><code>1</code>：每秒更新一次数据</td></tr><tr><td><code>ps</code></td><td>查看系统中进程的内存使用情况</td><td><code>ps aux --sort=-%mem</code></td><td><code>aux</code>：显示所有用户的进程， <code>--sort=-%mem</code>：按内存使用量降序排列</td></tr><tr><td><code>pmap</code></td><td>显示进程的内存映射</td><td><code>pmap -x &lt;pid&gt;</code></td><td><code>-x</code>：显示详细信息</td></tr><tr><td><code>smem</code></td><td>提供详细的内存使用报告</td><td><code>smem -r</code></td><td>无</td></tr><tr><td><code>/proc</code></td><td>提供系统和进程的详细内存信息</td><td><code>cat /proc/meminfo</code><br><code>cat /proc/&lt;pid&gt;/status</code></td><td>无</td></tr></tbody></table><h3 id="如何判断内存占用过高"><a href="#如何判断内存占用过高" class="headerlink" title="如何判断内存占用过高"></a>如何判断内存占用过高</h3><p>系统内存的使用情况可以通过 <code>top</code> 以及 <code>free</code> 命令进行查看，以 <code>free -m</code>为例:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/free.png" alt="free查看内存信息" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">free查看内存信息</span></div></div><p>字段说明：</p><ul><li>total:  系统总内存（RAM）或交换空间（Swap）的总量。</li><li>used:   已用内存或交换空间的量。这包括正在使用的内存以及系统缓存（对于内存）或已经使用的交换空间。</li><li>free:   空闲的内存或交换空间的量。表示当前未被任何进程使用的内存或交换空间。</li><li>shared: 被多个进程共享的内存量（对于内存）。通常是共享库和进程间通信的内存。</li><li>buff&#x2F;cache: 用作文件系统缓存和缓冲区的内存量。这包括缓存的文件数据（cache）和缓冲区（buff）。这些内存可以被系统用作其他用途。</li><li>available: 可以分配给新启动的应用程序的内存量，而不需要交换到磁盘。这个数字更能反映系统的实际可用内存</li></ul><p>这里我们需要关注下，一般可用内存我们就是以 avaible 为准。当 avaible 的指标越来越小时，我们就需要关注系统内存的整体使用情况。</p><p>这里还有一个需要关注的点：Swap，我们先看一下详细介绍:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system </span><br><span class="line">needs more memory resources and the RAM is full, inactive pages in memory are moved to the </span><br><span class="line">swap space. While swap space can help machines with a small amount of RAM, it should not be </span><br><span class="line">considered a replacement for more RAM. Swap space is located on hard drives, which have a </span><br><span class="line">slower access time than physical memory.Swap space can be a dedicated swap partition (recommended),</span><br><span class="line"> a swap file, or a combination of swap partitions and swap files.</span><br></pre></td></tr></table></figure><p>SWAP意思是交换，顾名思义，当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT。当某进程又需要这些数据且OS发现还有空闲物理内存时，又会把SWAP分区中的数据交换回物理内存中，这个过程称为SWAP IN。<br>简单来说，就是物理内存不足时，把磁盘空间当作 swap 分区，解决容量不足的问题。</p><p>这里我们其实会发现一个问题，物理内存的读写性能肯定要比磁盘强不少，使用了磁盘空间作为内存存储，本身读写的性能就不高，还涉及到频繁的交换，反而增加了系统的负载，所以在线上环境中我们一般建议关闭 swap，具体的关闭方法请自行百度。</p><h3 id="如何定位内存占用高"><a href="#如何定位内存占用高" class="headerlink" title="如何定位内存占用高"></a>如何定位内存占用高</h3><p>针对内存的占用，常规情况下(当然也有非常规情况)，我们需要找到占用内存高的具体进程，详细的操作方式是:<br><code>top</code>的时候输入<code>M</code>进行排序，这样我们就可以看到系统中进程消耗内存的详细占比了:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/top-process.png" data-fancybox="true"/></div></div><p>这里我们重点关注两列: <code>%MEM</code> 和 <code>RES</code>, 前者是这个进程占用系统内存的百分比，后者是占用实际内存的大小。</p><p>我们还是以 JAVA 和 GOLANG 程序为例来分析内存高该如何排查</p><h4 id="JAVA-占用内存过高"><a href="#JAVA-占用内存过高" class="headerlink" title="JAVA 占用内存过高"></a>JAVA 占用内存过高</h4><p>Java 应用的内存管理依赖于 JVM (Java Virtual Machine)，通常会涉及到堆内存（Heap）、非堆内存（Non-Heap）以及本地内存（Native Memory）。</p><h5 id="堆内内存分析"><a href="#堆内内存分析" class="headerlink" title="堆内内存分析"></a>堆内内存分析</h5><ol><li>查看 JVM 启动参数，尤其是 -Xms 和 -Xmx 选项，这两个参数分别设置了初始堆内存大小和最大堆内存大小。可以通过 ps 命令查看这些参数：<code>ps -auxf | grep 程序名称</code></li><li>使用 jstat 查看 gc 情况, 实例：<code>jstat -gc pid 1000</code><div class="tag-plugin image"><div class="image-bg"><img src="/images/gc.png" alt="gc 信息" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">gc 信息</span></div></div>如果 GC 频繁，那么我们需要进一步进行分析</li><li>通过 jmap 生成进程的堆内存快照 (在 JVM启动时，建议添加 OOM 时自动生成 heap dump: <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dumpfile</code>)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heapdump.hprof &lt;pid&gt;</span><br></pre></td></tr></table></figure></li><li>拿到快照文件后，我们可以通过 MAT 或者 Jprofiler 这样的工具去具体分析<br>以 MAT 为例：</li></ol><div class="tag-plugin image"><div class="image-bg"><img src="/images/mat.jpeg" alt="MAT 分析 JAVA内存" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">MAT 分析 JAVA内存</span></div></div><h5 id="本地内存分析"><a href="#本地内存分析" class="headerlink" title="本地内存分析"></a>本地内存分析</h5><p>NMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。<br>NMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。</p><p>启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。<br>启动命令： <code>-XX:NativeMemoryTracking=[off | summary | detail]</code>。</p><ul><li>off：NMT 默认是关闭的；</li><li>summary：只收集子系统的内存使用的总计数据；</li><li>detail：收集每个调用点的内存使用数据。</li></ul><p>开启后，我们可以通过如下命令访问 NMT 内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</span><br></pre></td></tr></table></figure><h5 id="其他非堆内存"><a href="#其他非堆内存" class="headerlink" title="其他非堆内存"></a>其他非堆内存</h5><p>主要包括：</p><ul><li>JVM 自身运行占用的空间；</li><li>线程栈分配占用的系统内存；</li><li>DirectByteBuffer 占用的内存；</li><li>JNI 里分配的内存；</li><li>Java 8 开始的元数据空间；</li><li>NIO 缓存</li><li>Unsafe 调用分配的内存；</li><li>codecache</li></ul><p>对于这些问题，遇到内存升高的情况较少，所以也没有进行过详细的排查，如果有读者朋友有做过类似的排查，可以在下面留言讨论。</p><h4 id="golang程序占用内存高"><a href="#golang程序占用内存高" class="headerlink" title="golang程序占用内存高"></a>golang程序占用内存高</h4><p>golang 内置了 pprof 性能分析工具，支持 CPU、内存（Heap）、栈、协程等的分析。可以通过 HTTP 服务暴露 pprof 接口，并使用浏览器或 go tool pprof 进行分析：<br>在代码中引入 net&#x2F;http&#x2F;pprof 包：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 你的应用代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动应用后，通过浏览器访问 <code>http://localhost:6060/debug/pprof/heap</code> 下载堆内存快照，并使用以下命令分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=:8080 heap.prof</span><br></pre></td></tr></table></figure><p>这将启动一个 Web 界面，供你分析内存占用的热点。<br>具体的使用方式大家可以自行研究。</p><h4 id="基于内存的文件系统占用"><a href="#基于内存的文件系统占用" class="headerlink" title="基于内存的文件系统占用"></a>基于内存的文件系统占用</h4><p>在上文中，我们说了常规情况下的排查，那来个非常规的，先上张图：</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/tmp-mem.png" alt="内存占用模拟" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">内存占用模拟</span></div></div><p>这里大家看看到，内存总量大概有 250 个 G，可用内存只有 126G，但是我们通过 top 看内存占比跟实际的数值相差甚远。</p><p>这种场景是不是非常奇怪呢？没有进程占用内存，但是内存被消耗了，这种情况下，很有可能跟基于内存的文件系统有关。</p><p>这里我说一下模拟方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># systemd 的包中会默认自带一个 tmp.mount服务，这个服务默认是关闭的（默认是总内存的一半）</span><br><span class="line"># 这个服务本质上是一个基于内存的文件系统（把内存当磁盘使，在上面可以创建文件）</span><br><span class="line">systemctl start tmp.mount</span><br><span class="line"></span><br><span class="line"># 然后我们通过 df -h /tmp 可以看到</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs           126G  111G   16G  88% /tmp</span><br><span class="line"></span><br><span class="line">这里挂载了/tmp 目录，文件系统是 tmpfs</span><br><span class="line"></span><br><span class="line"># 然后我们进入 /tmp目录</span><br><span class="line"># 模拟文件创建</span><br><span class="line">dd if=/dev/zero of=test.txt bs=G count=100</span><br><span class="line"></span><br><span class="line"># 然后我们就可以看到文件创建成功，然后 free -g 就可以看到内存成功消耗了100G😂</span><br></pre></td></tr></table></figure><p>这种场景也是我之前在排查问题的时候遇到的，大家有其他类似场景也可以进行补充</p><h2 id="磁盘问题"><a href="#磁盘问题" class="headerlink" title="磁盘问题"></a>磁盘问题</h2><p>线上的磁盘问题，除了磁盘故障(坏块、文件系统损坏、RAID 等)之外，常见的比较多的问题可以分为两大类：磁盘空间不足和 IO 性能问题</p><h3 id="磁盘空间不足"><a href="#磁盘空间不足" class="headerlink" title="磁盘空间不足"></a>磁盘空间不足</h3><p>对于这类问题，一般情况下，本身可能就是数据文件、日志信息等过多导致的<strong>真实占用</strong>，还有一类是文件句柄泄露导致磁盘没有释放从而占据了多余的磁盘空间</p><p>对于这类问题我们一般通过以下手段进行排查，假如说我们现在接到告警 说根目录的磁盘空间不足了</p><ol><li>通过<code>df -h</code>命令查看磁盘分区的使用情况。</li><li>进入 <code>&quot;/&quot;</code> 目录下，可以对常用的目录进行 <code>du -sh</code>操作，然后进行简单的相加<ul><li>如果加起来的磁盘空间，和分区使用的磁盘空间相差不多，那就基本上说明磁盘空间是被真实占用的，找到占用高的目录继续通过<code>du -sh</code> 目录，不断递归。或者想快速找到磁盘中超过 1G 的文件，可以通过<code>find 目录 -type f -size +1G</code> 这样的方式。<br>如果想快速统计到所有子目录的磁盘信息，那么可以通过这样的方式进行操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah / 2&gt;/dev/null | grep -E &#x27;^([0-9]+([KMGT]?)|([0-9]+(\.[0-9]+)?[KMGT]))&#x27; | sort -rh | head -10</span><br></pre></td></tr></table></figure></li><li>如果加起来的磁盘空间，和分区使用的磁盘空间相差的比较大，那么可能存在句柄泄露，比如日志文件本身被删掉，但是句柄没有释放，可以通过一下方式: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#列出进打开文件最多的 10 个进程；</span><br><span class="line">lsof +L1 | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -rn | head -n 10</span><br><span class="line"></span><br><span class="line"># 查看某个进程的占用</span><br><span class="line">lsof -p $pid (查看是否存在已经删除的文件句柄没有释放，可以通过 grep deleted 过滤)</span><br><span class="line"></span><br><span class="line"># 或者 ls /proc/$pid/fd 进行查看</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="磁盘IO性能问题"><a href="#磁盘IO性能问题" class="headerlink" title="磁盘IO性能问题"></a>磁盘IO性能问题</h3><p>我们可以通过 iostat 看下磁盘整体的读写情况:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/iostat.png" alt="iostat" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">iostat</span></div></div><p>详细的介绍如下：</p><ol><li>CPU 使用情况</li></ol><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody><tr><td>%user</td><td>用户模式下消耗的 CPU 时间百分比</td></tr><tr><td>%nice</td><td>调整优先级的用户模式下的 CPU 时间百分比</td></tr><tr><td>%system</td><td>内核模式下消耗的 CPU 时间百分比</td></tr><tr><td>%iowait</td><td>CPU 等待 I&#x2F;O 操作完成的时间百分比</td></tr><tr><td>%steal</td><td>等待虚拟 CPU 被实际 CPU 服务的时间百分比</td></tr><tr><td>%idle</td><td>CPU 空闲时间百分比</td></tr></tbody></table><ol start="2"><li>设备 I&#x2F;O 使用情况</li></ol><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody><tr><td>Device</td><td>设备名称</td></tr><tr><td>tps</td><td>每秒传输数（I&#x2F;O 请求数）</td></tr><tr><td>kB_read&#x2F;s</td><td>每秒读取的 kB 数</td></tr><tr><td>kB_wrtn&#x2F;s</td><td>每秒写入的 kB 数</td></tr><tr><td>kB_read</td><td>读取的 kB 总数</td></tr><tr><td>kB_wrtn</td><td>写入的 kB 总数</td></tr><tr><td>rrqm&#x2F;s</td><td>每秒进行的合并读请求数</td></tr><tr><td>wrqm&#x2F;s</td><td>每秒进行的合并写请求数</td></tr><tr><td>r&#x2F;s</td><td>每秒完成的读请求数</td></tr><tr><td>w&#x2F;s</td><td>每秒完成的写请求数</td></tr><tr><td>rMB&#x2F;s</td><td>每秒读取的 MB 数</td></tr><tr><td>wMB&#x2F;s</td><td>每秒写入的 MB 数</td></tr><tr><td>avgrq-sz</td><td>平均每次 I&#x2F;O 请求的数据大小</td></tr><tr><td>avgqu-sz</td><td>平均 I&#x2F;O 队列长度</td></tr><tr><td>await</td><td>平均每次 I&#x2F;O 操作的等待时间</td></tr><tr><td>svctm</td><td>平均每次 I&#x2F;O 操作的服务时间</td></tr><tr><td>%util</td><td>设备 I&#x2F;O 活动时间百分比（表示设备忙碌度）</td></tr></tbody></table><p>通过这个我们就可以获取到磁盘的整体情况。</p><p>当我们想查看进程占用的 io 情况时，可以通过 <code>iotop</code>命令进行查看，如下:</p><div class="tag-plugin image"><div class="image-bg"><img src="/images/iotop.png" alt="iotop" data-fancybox="true"/></div><div class="image-meta"><span class="image-caption center">iotop</span></div></div><p>结合上文讲的一些堆栈分析工具，推测到进程具体在做那些操作然后针对性进行处理。</p>]]></content>
    
    
    <summary type="html">线上故障问题的排查方法和工具介绍，包括 CPU、内存、负载、磁盘、IO、网络等</summary>
    
    
    
    <category term="问题排查" scheme="http://baixiaozhou.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Linux" scheme="http://baixiaozhou.github.io/tags/Linux/"/>
    
    <category term="Java" scheme="http://baixiaozhou.github.io/tags/Java/"/>
    
    <category term="Golang" scheme="http://baixiaozhou.github.io/tags/Golang/"/>
    
    <category term="commands" scheme="http://baixiaozhou.github.io/tags/commands/"/>
    
  </entry>
  
  <entry>
    <title>JAVA问题定位</title>
    <link href="http://baixiaozhou.github.io/p/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://baixiaozhou.github.io/p/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</id>
    <published>2024-07-30T07:32:13.000Z</published>
    <updated>2024-08-17T15:11:14.404Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="一、JAVA-相关命令"><a href="#一、JAVA-相关命令" class="headerlink" title="一、JAVA 相关命令"></a>一、JAVA 相关命令</h1><h2 id="1-jps"><a href="#1-jps" class="headerlink" title="1.jps"></a>1.jps</h2><p>jps - Lists the instrumented Java Virtual Machines (JVMs) on the target system. This command is experimental and unsupported.</p><p>相关参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS</span><br><span class="line">       The jps command supports a number of options that modify the output of the command. These options are subject to change or removal in the future.</span><br><span class="line">       -q</span><br><span class="line">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class="line">       -m</span><br><span class="line">              Displays the arguments passed to the main method. The output may be null for embedded JVMs.</span><br><span class="line">       -l</span><br><span class="line">              Displays the full package name for the application&#x27;s main class or the full path name to the application&#x27;s JAR file.</span><br><span class="line">       -v</span><br><span class="line">              Displays the arguments passed to the JVM.</span><br><span class="line">       -V</span><br><span class="line">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class="line">       -Joption</span><br><span class="line">              Passes option to the JVM, where option is one of the options described on the reference page for the Java application launcher. For example, -J-Xms48m sets the</span><br><span class="line">              startup memory to 48 MB. See java(1).</span><br></pre></td></tr></table></figure><h2 id="2-jinfo"><a href="#2-jinfo" class="headerlink" title="2.jinfo"></a>2.jinfo</h2><p>jinfo（Java Virtual Machine Configuration Information）是JDK提供的一个可以实时查看Java虚拟机各种配置参数和系统属性的命令行工具。使用jps命令的-v参数可以查看Java虚拟机启动时显式指定的配置参数，如果想查看没有显式指定的配置参数就可以使用jinfo命令进行查看。另外，jinfo命令还可以查询Java虚拟机进程的System.getProperties()的内容。</p><p>以tomcat进程为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 2045, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.242-b08</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.vendor = Huawei Technologies Co., Ltd</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">catalina.base = /usr/share/tomcat</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">sun.nio.ch.bugLevel = </span><br><span class="line">catalina.useNaming = true</span><br><span class="line">jnidispatch.path = /var/cache/tomcat/temp/jna--903012287/jna4240128671455089550.tmp</span><br><span class="line">os.name = Linux</span><br><span class="line">sun.boot.class.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/classes</span><br><span class="line">java.vm.specification.vendor = Oracle Corporation</span><br><span class="line">java.runtime.version = 1.8.0_242-b08</span><br><span class="line">jna.loaded = true</span><br><span class="line">user.name = xxx</span><br><span class="line">tomcat.util.scan.StandardJarScanFilter.jarsToScan = taglibs-standard-impl*.jar</span><br><span class="line">shared.loader = </span><br><span class="line">tomcat.util.buf.StringCache.byte.enabled = true</span><br><span class="line">user.language = en</span><br><span class="line">java.naming.factory.initial = org.apache.naming.java.javaURLContextFactory</span><br><span class="line">sun.boot.library.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64</span><br><span class="line">java.version = 1.8.0_242</span><br><span class="line">java.util.logging.manager = org.apache.juli.ClassLoaderLogManager</span><br><span class="line">user.timezone = Asia/Shanghai</span><br><span class="line">sun.arch.data.model = 64</span><br><span class="line">java.util.concurrent.ForkJoinPool.common.threadFactory = org.apache.catalina.startup.SafeForkJoinWorkerThreadFactory</span><br><span class="line">java.endorsed.dirs = </span><br><span class="line">sun.cpu.isalist = </span><br><span class="line">sun.jnu.encoding = UTF-8</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">package.access = sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.</span><br><span class="line">file.separator = /</span><br><span class="line">java.specification.name = Java Platform API Specification</span><br><span class="line">java.class.version = 52.0</span><br><span class="line">user.country = US</span><br><span class="line">java.home = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre</span><br><span class="line">java.vm.info = mixed mode</span><br><span class="line">os.version = 4.19.90-24.4.v2101.ky10.x86_64</span><br><span class="line">sun.font.fontmanager = sun.awt.X11FontManager</span><br><span class="line">path.separator = :</span><br><span class="line">java.vm.version = 25.242-b08</span><br><span class="line">jboss.i18n.generate-proxies = true</span><br><span class="line">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class="line">sun.io.unicode.encoding = UnicodeLittle</span><br><span class="line">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class="line">package.definition = sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.</span><br><span class="line">java.naming.factory.url.pkgs = org.apache.naming</span><br><span class="line">mail.mime.splitlongparameters = false</span><br><span class="line">java.security.egd = file:/dev/./urandom</span><br><span class="line">user.home = /home/shterm</span><br><span class="line">java.specification.vendor = Oracle Corporation</span><br><span class="line">tomcat.util.scan.StandardJarScanFilter.jarsToSkip = activ*.jar,amqp-client.jar,annotations-api.jar,ant-junit*.jar,ant-launcher.jar,ant.jar,antlr.jar,aopalliance.jar,asm-*.jar,aspectj*.jar,bcp*.jar,bootstrap.jar,catalina-ant.jar,catalina-ha.jar,catalina-jmx-remote.jar,catalina-storeconfig.jar,catalina-tribes.jar,catalina-ws.jar,catalina.jar,cglib-*.jar,classmate.jar,cobertura-*.jar,commons-*.jar,compress-lzf.jar,curator-*.jar,db2-jdbc.jar,dom4j-*.jar,easymock-*.jar,ecj-*.jar,el-api.jar,elasticsearch.jar,geronimo-spec-jaxrpc*.jar,groovy-all.jar,guava.jar,h2*.jar,hamcrest-*.jar,hibernate*.jar,hppc.jar,http*.jar,icu4j-*.jar,itext*.jar,jackson-*.jar,jandex.jar,jasper-el.jar,jasper.jar,jasperreports*.jar,jaspic-api.jar,javamail.jar,javassist.jar,jaxb-*.jar,jaxen*.jar,jboss*.jar,jc*.jar,jdom-*.jar,jedis.jar,jetty-*.jar,jfreechart.jar,jgit.jar,jline.jar,jmx-tools.jar,jmx.jar,jna.jar,joda-time.jar,jr-*.jar,jsch.jar,json*.jar,jsoup.jar,jsp-api.jar,jsr166e.jar,jstl.jar,jta*.jar,junit-*.jar,junit.jar,liquibase-*.jar,log4j*.jar,lucene*.jar,mail*.jar,mariadb-jdbc.jar,mssql-jdbc.jar,mybatis.jar,netty.jar,nmap4j.jar,objenesis*.jar,olap4j.jar,opc*.jar,oracle-jdbc.jar,oraclepki.jar,oro-*.jar,poi*.jar,postgresql-jdbc.jar,quartz.jar,servlet-api-*.jar,servlet-api.jar,slf4j*.jar,snakeyaml.jar,snmp4j.jar,spring*.jar,sshd-core.jar,taglibs-standard-spec-*.jar,tagsoup-*.jar,t-digest.jar,tomcat-api.jar,tomcat-coyote.jar,tomcat-dbcp.jar,tomcat-i18n-*.jar,tomcat-jdbc.jar,tomcat-jni.jar,tomcat-juli-adapters.jar,tomcat-juli.jar,tomcat-util-scan.jar,tomcat-util.jar,tomcat-websocket.jar,tools.jar,validation-api.jar,velocypack.jar,websocket-api.jar,wl*.jar,wsdl4j*.jar,xercesImpl.jar,xml-apis.jar,xmlbeans.jar,xmlParserAPIs-*.jar,xmlParserAPIs.jar,xom-*.jar,xz.jar,zip4j.jar,zookeeper.jar</span><br><span class="line">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line">java.vendor.url = http://jdk.rnd.huawei.com/</span><br><span class="line">java.vm.vendor = Huawei Technologies Co., Ltd</span><br><span class="line">common.loader = &quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span><br><span class="line">java.runtime.name = OpenJDK Runtime Environment</span><br><span class="line">sun.java.command = org.apache.catalina.startup.Bootstrap start</span><br><span class="line">java.class.path = /usr/share/tomcat/bin/bootstrap.jar:/usr/share/tomcat/bin/tomcat-juli.jar:/usr/lib/java/commons-daemon.jar</span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class="line">java.vm.specification.version = 1.8</span><br><span class="line">catalina.home = /usr/share/tomcat</span><br><span class="line">sun.cpu.endian = little</span><br><span class="line">sun.os.patch.level = unknown</span><br><span class="line">java.awt.headless = true</span><br><span class="line">java.io.tmpdir = /var/cache/tomcat/temp</span><br><span class="line">java.vendor.url.bug = http://jdk.rnd.huawei.com/</span><br><span class="line">server.loader = </span><br><span class="line">java.rmi.server.hostname = 127.0.0.1</span><br><span class="line">jna.platform.library.path = /usr/lib64:/lib64:/usr/lib:/lib:/usr/lib64/tracker-miners-2.0:/usr/lib64/tracker-2.0:/usr/lib64/dyninst:/usr/libexec/sudo:/usr/lib64/sssd:/usr/pgsql-9.6/lib:/usr/lib64/perl5/CORE:/usr/lib64/opencryptoki:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64/jli:/usr/lib64/bind9-export</span><br><span class="line">os.arch = amd64</span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class="line">java.ext.dirs = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line">user.dir = /usr/share/tomcat</span><br><span class="line">line.separator = </span><br><span class="line"></span><br><span class="line">java.vm.name = OpenJDK 64-Bit Server VM</span><br><span class="line">log4j.configurationFile = /etc/tomcat/log4j2.xml</span><br><span class="line">file.encoding = UTF-8</span><br><span class="line">com.sun.jndi.ldap.object.disableEndpointIdentification = </span><br><span class="line">java.specification.version = 1.8</span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:GCLogFileSize=20971520 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=243269632 -XX:MaxHeapSize=1610612736 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=80740352 -XX:NumberOfGCLogFiles=15 -XX:OldSize=162529280 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRotation -XX:+UseParallelGC </span><br><span class="line">Command line:  -Xmx1536m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/tomcat -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=20m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/var/log/tomcat/tomcat-gc-%t.log -Dcom.sun.jndi.ldap.object.disableEndpointIdentification -Dcatalina.base=/usr/share/tomcat -Dcatalina.home=/usr/share/tomcat -Djava.endorsed.dirs= -Djava.io.tmpdir=/var/cache/tomcat/temp -Dlog4j.configurationFile=/etc/tomcat/log4j2.xml -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br></pre></td></tr></table></figure><h2 id="3-jstat"><a href="#3-jstat" class="headerlink" title="3.jstat"></a>3.jstat</h2><p>命令参数说明：</p><ul><li>generalOptions：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：</li><li>-help：显示帮助信息。</li><li>-options：显示outputOptions参数的列表。</li><li>outputOptions：输出选项，指定显示某一种Java虚拟机信息。</li><li>-t：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。</li><li>-h n：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。</li><li>vmid：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。</li><li>interval：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每隔这段时间显示一次统计信息。</li><li>count：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。<br>输出选项<br>如果不指定通用选项（generalOptions），则可以指定输出选项（outputOptions）。输出选项决定jstat命令显示的内容和格式，具体如下：</li><li>-class：显示类加载、卸载数量、总空间和装载耗时的统计信息。</li><li>-compiler：显示即时编译的方法、耗时等信息。</li><li>-gc：显示堆各个区域内存使用和垃圾回收的统计信息。</li><li>-gccapacity：显示堆各个区域的容量及其对应的空间的统计信息。</li><li>-gcutil：显示有关垃圾收集统计信息的摘要。</li><li>-gccause：显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因。</li><li>-gcnew：显示新生代的垃圾回收统计信息。</li><li>-gcnewcapacity：显示新生代的大小及其对应的空间的统计信息。</li><li>-gcold: 显示老年代和元空间的垃圾回收统计信息。</li><li>-gcoldcapacity：显示老年代的大小统计信息。</li><li>-gcmetacapacity：显示元空间的大小的统计信息。</li><li>-printcompilation：显示即时编译方法的统计信息。</li></ul><h1 id="二、线程堆栈"><a href="#二、线程堆栈" class="headerlink" title="二、线程堆栈"></a>二、线程堆栈</h1><h2 id="1-输出"><a href="#1-输出" class="headerlink" title="1.输出"></a>1.输出</h2><p>Java虚拟机提供了线程转储(Thread dump)的后门，通过这个后门，可以将线程堆栈打印出来。这个后门就是通过向Java进程发送一个QUIT信号，Java虚拟机收到该信号之后，将系统当前的JAVA线程调用堆栈打印出来。</p><p>打印方法：</p><ul><li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li><li>kill -3<br><em><strong>同时请确保Java命令行中没有DISABLE_JAVADUMP运行选项</strong></em></li></ul><h2 id="2-线程分析"><a href="#2-线程分析" class="headerlink" title="2.线程分析"></a>2.线程分析</h2><p>通过输出堆栈进行分析 <code>jstack -l $(jps | grep xxx | awk &#39;&#123;print $1&#125;&#39;)</code> &gt; &#x2F;tmp&#x2F;xxx.jstack</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;SYS_STATUS_CHECKER&quot;</span> #<span class="number">14</span> daemon prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f5e047bf000</span> nid=<span class="number">0xe15</span> waiting on condition [<span class="number">0x00007f5dd43d1000</span>]</span><br><span class="line">    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">ru        at com.xxx.xxx.SystemStatusChecker.run(SystemStatusChecker.java:xx)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)        </span><br><span class="line">    Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">                </span><br><span class="line"><span class="string">&quot;RMI Reaper&quot;</span> #<span class="number">39</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f5e04e4c800</span> nid=<span class="number">0xf0b</span> <span class="keyword">in</span> Object.wait() [<span class="number">0x00007f5dae2c4000</span>]</span><br><span class="line">    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.<span class="built_in">remove</span>(ReferenceQueue.java:<span class="number">144</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.<span class="built_in">remove</span>(ReferenceQueue.java:<span class="number">165</span>)</span><br><span class="line">        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:<span class="number">351</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">    Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">        </span><br><span class="line"><span class="string">&quot;main&quot;</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f5e0400a000</span> nid=<span class="number">0xdcb</span> runnable [<span class="number">0x00007f5e0b393000</span>]</span><br><span class="line">    java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">        at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br><span class="line">        at com.xxx.common.xxx.await(CommonMain.java:<span class="number">244</span>)</span><br><span class="line">        at com.xxx.common.xxx.startup(CommonMain.java:<span class="number">207</span>)</span><br><span class="line">        at com.xxx.common.xxx.main(CommonMain.java:<span class="number">147</span>)</span><br><span class="line">    Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><p>在RMI线程中可以看到 “ - locked &lt;0x00000000c0c88d20&gt; (a java.lang.ref.ReferenceQueue$Lock)” 表示该线程已经使用了ID为”0x00000000c0c88d2”的锁，锁的ID由系统自动产生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;  prio=5     os_prio=0          tid=0x00007f5e0400a000 nid=0xdcb      runnable [0x00007f5e0b393000]</span><br><span class="line">|       |          |                  |                      |              |         |</span><br><span class="line">线程名称 线程优先级   操作系统级别的优先级   线程id                 对应的本地线程ID  状态      线程占用内存地址</span><br></pre></td></tr></table></figure><p>其中”线程对应的本地线程id号”所指的”本地线程”是指该Java线程所对应的虚拟机中的本地线程。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是 依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。</p><p>Java代码 中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix&#x2F;Linux下，我们可以通 如下方式把Java虚拟机的本地线程打印出来：</p><ul><li>使用ps -ef | grep java 获得Java进程ID。</li><li>使用pstack <java pid>获得Java虚拟机的本地线程的堆栈<br>其中本地线程各项含义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread 56 (Thread 0x7f5e0b394700 (LWP 3531))</span><br><span class="line">|                 |                 |</span><br><span class="line">|                 |                 +----本地线程id(另一种表示,LWP-light weight process)</span><br><span class="line">|                 +-------------------本地线程id</span><br><span class="line">+------------------------------线程名称</span><br></pre></td></tr></table></figure>而通过jstack输出的main本地线程ID为0xdcb，其10进制正好为3531。</li></ul><p>“runnable”表示当前线程处于运行状态。这个runnable状态是从虚拟机的角度来看的, 表示这个线程正在运行</p><p><strong>⚠️ NOTE:</strong> 但是处于Runnable状态的线程不一定真的消耗CPU. 处于Runnable的线程只能说明该线程没有阻塞在java的wait或者sleep方法上，同时也没等待在锁上面。但是如果该线程调用了本地方法，而本地方法处于等待状态，这个时候虚拟机是不知道本地代码中发生 了什么（但操作系统是知道的，pstack就是操作提供的一个命令，它知道当前线程正在执行的本地代码上下文），此时尽管当前线程实际上也是阻塞的状态，但实际上显示出来的还是runnable状态， 这种情况下是不消耗CPU的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 处于waittig和blocked状态的线程都不会消耗CPU </span><br><span class="line">2. 线程频繁地挂起和唤醒需要消耗CPU, 而且代价颇大</span><br></pre></td></tr></table></figure><ul><li>TIMED_WAITING(on object monitor) 表示当前线程被挂起一段时间,说明该线程正在 执行obj.wait(int time)方法.</li><li>TIMED_WAITING(sleeping) 表示当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法. </li><li>TIMED_WAITING(parking) 当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法.</li><li>WAINTING(on object monitor) 当前线程被挂起，即正在执行obj.wait()方法(无参数的wait()方法).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.</span><br><span class="line">• 如果是纯Java运算代码，则消耗CPU.</span><br><span class="line">• 如果是网络IO,很少消耗CPU.</span><br><span class="line">• 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)， 如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消 耗CPU。</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、相关的排查方法"><a href="#三、相关的排查方法" class="headerlink" title="三、相关的排查方法"></a>三、相关的排查方法</h1><h2 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.CPU"></a>1.CPU</h2><p>生产环境中往往会出现CPU飙高的情况，对于JAVA应用而言，此类问题相对较好确定问题方向。</p><h3 id="1-1-使用jstack确定CPU占用高的线程"><a href="#1-1-使用jstack确定CPU占用高的线程" class="headerlink" title="1.1 使用jstack确定CPU占用高的线程\"></a>1.1 使用jstack确定CPU占用高的线程\</h3><p>通过<code>top</code>指令，可以看到进程占用的一些基础资源信息，然后“P”键可以按照CPU使用率进行排序，“M”键可以按照内存占用情况进行排序</p><p>找到CPU占用高的进程pid，然后将jstack信息定向到一个文件中去，通过<code>top -Hp pid</code>查看具体的情况。</p><p>通过 <code>printf &#39;%x\n&#39; pid</code>将pid转换为16进制，然后在jstack文件中根据对应的数字进行查找，然后针对性的进行分析</p><h3 id="1-2-频繁GC"><a href="#1-2-频繁GC" class="headerlink" title="1.2 频繁GC"></a>1.2 频繁GC</h3><p>有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，<code>S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU</code>分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。<code>YGC/YGT、FGC/FGCT、GCT</code>则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。<br><img src="/../images/gc.png" alt="alt text"></p><h3 id="1-3-频繁上下文切换"><a href="#1-3-频繁上下文切换" class="headerlink" title="1.3 频繁上下文切换"></a>1.3 频繁上下文切换</h3><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看<br><img src="/../images/vmstat.png" alt="alt text"><br>cs(context switch)一列则代表了上下文切换的次数。</p><p>如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。</p><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h2><p>对于JAVA应用，涉及到的内存问题主要包括OOM、GC问题和堆外内存。</p><h3 id="2-1-OOM"><a href="#2-1-OOM" class="headerlink" title="2.1 OOM"></a>2.1 OOM</h3><p>JVM中的内存不足，OOM大致可以分为以下几种情况</p><ul><li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</code> 这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.confnofile</code>和<code>nproc</code>来增大os对线程的限制</li><li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space </code> 这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</li><li><code>Caused by: java.lang.OutOfMemoryError: Meta space</code> 这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整</li><li><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code> 表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。</li></ul><h3 id="2-2-GC问题"><a href="#2-2-GC问题" class="headerlink" title="2.2 GC问题"></a>2.2 GC问题</h3><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常等。</p><p>线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code></p><h3 id="2-3-堆外内存"><a href="#2-3-堆外内存" class="headerlink" title="2.3 堆外内存"></a>2.3 堆外内存</h3><p>JVM 的堆外内存主要包括：</p><ul><li>JVM 自身运行占用的空间；</li><li>线程栈分配占用的系统内存；</li><li>DirectByteBuffer 占用的内存；</li><li>JNI 里分配的内存；</li><li>Java 8 开始的元数据空间；</li><li>NIO 缓存</li><li>Unsafe 调用分配的内存；</li><li>codecache</li></ul><p>冰山对象：冰山对象是指在 JVM 堆里占用的内存很小，但其实引用了一块很大的本地内存。DirectByteBuffer 和 线程都属于这类对象。</p><h4 id="2-3-1NMT分析堆外内存"><a href="#2-3-1NMT分析堆外内存" class="headerlink" title="2.3.1NMT分析堆外内存"></a>2.3.1NMT分析堆外内存</h4><p>NMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。</p><p>NMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。</p><h4 id="2-3-2-开启-NMT"><a href="#2-3-2-开启-NMT" class="headerlink" title="2.3.2 开启 NMT"></a>2.3.2 开启 NMT</h4><p>启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。<br>启动命令： <code>-XX:NativeMemoryTracking=[off | summary | detail]</code>。</p><ul><li>off：NMT 默认是关闭的；</li><li>summary：只收集子系统的内存使用的总计数据；</li><li>detail：收集每个调用点的内存使用数据。</li></ul><h4 id="2-3-3-jcmd-访问-NMT-数据"><a href="#2-3-3-jcmd-访问-NMT-数据" class="headerlink" title="2.3.3 jcmd 访问 NMT 数据"></a>2.3.3 jcmd 访问 NMT 数据</h4><p>命令：<br><code>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</code></p>]]></content>
    
    
    <summary type="html">java常见问题和排查的基本方法和工具介绍</summary>
    
    
    
    <category term="问题排查" scheme="http://baixiaozhou.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="JAVA" scheme="http://baixiaozhou.github.io/tags/JAVA/"/>
    
    <category term="Linux" scheme="http://baixiaozhou.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
