{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/stellar/source/css/darkmode.css","path":"css/darkmode.css","modified":0,"renderable":1},{"_id":"themes/stellar/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/darkmode.js","path":"js/darkmode.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/plugins/copycode.js","path":"js/plugins/copycode.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/fcircle.js","path":"js/services/fcircle.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/friends.js","path":"js/services/friends.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/ghinfo.js","path":"js/services/ghinfo.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/mdrender.js","path":"js/services/mdrender.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/memos.js","path":"js/services/memos.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/siteinfo.js","path":"js/services/siteinfo.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/sites.js","path":"js/services/sites.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/timeline.js","path":"js/services/timeline.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/services/weibo.js","path":"js/services/weibo.js","modified":0,"renderable":1},{"_id":"source/liuyanban.jpeg","path":"liuyanban.jpeg","modified":0,"renderable":0},{"_id":"source/images/dark.jpeg","path":"images/dark.jpeg","modified":0,"renderable":0},{"_id":"source/images/gc.png","path":"images/gc.png","modified":0,"renderable":0},{"_id":"source/images/git.png","path":"images/git.png","modified":0,"renderable":0},{"_id":"source/images/java.jpg","path":"images/java.jpg","modified":0,"renderable":0},{"_id":"source/images/javafire.png","path":"images/javafire.png","modified":0,"renderable":0},{"_id":"source/images/javaperftop.png","path":"images/javaperftop.png","modified":0,"renderable":0},{"_id":"source/images/liuyanban.jpeg","path":"images/liuyanban.jpeg","modified":0,"renderable":0},{"_id":"source/images/load10.png","path":"images/load10.png","modified":0,"renderable":0},{"_id":"source/images/load30.png","path":"images/load30.png","modified":0,"renderable":0},{"_id":"source/images/load60.png","path":"images/load60.png","modified":0,"renderable":0},{"_id":"source/images/logo.jpeg","path":"images/logo.jpeg","modified":0,"renderable":0},{"_id":"source/images/music.jpeg","path":"images/music.jpeg","modified":0,"renderable":0},{"_id":"source/images/perftop.png","path":"images/perftop.png","modified":0,"renderable":0},{"_id":"source/images/server.jpg","path":"images/server.jpg","modified":0,"renderable":0},{"_id":"source/images/shouye.jpeg","path":"images/shouye.jpeg","modified":0,"renderable":0},{"_id":"source/images/stress-cpu.png","path":"images/stress-cpu.png","modified":0,"renderable":0},{"_id":"source/images/top-process.png","path":"images/top-process.png","modified":0,"renderable":0},{"_id":"source/images/top.png","path":"images/top.png","modified":0,"renderable":0},{"_id":"source/images/vmstat.png","path":"images/vmstat.png","modified":0,"renderable":0},{"_id":"source/images/io60c.png","path":"images/io60c.png","modified":0,"renderable":0},{"_id":"source/images/ioload60.png","path":"images/ioload60.png","modified":0,"renderable":0},{"_id":"source/images/ioload30.png","path":"images/ioload30.png","modified":0,"renderable":0},{"_id":"source/images/loadhigh.png","path":"images/loadhigh.png","modified":0,"renderable":0},{"_id":"source/images/psauxf.png","path":"images/psauxf.png","modified":0,"renderable":0},{"_id":"source/images/ioload10.png","path":"images/ioload10.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/images/dark.jpeg","hash":"dc6c5cd179fb4795afbcb6e0fbc278e561a2bef1","modified":1723965458968},{"_id":"source/liuyanban.jpeg","hash":"0f8795cf75733493ffa43a6b3cded703ce4a2d48","modified":1723964137897},{"_id":"source/_posts/线上问题排查方法汇总.md","hash":"c31fbf09f2070d8d5bb12cfdffff88478c8f7031","modified":1724058749361},{"_id":"source/about/index.md","hash":"186082b9ce497dc3939bf37fb433ec05ae4870f7","modified":1723905205345},{"_id":"source/_posts/JAVA问题定位.md","hash":"c6a5680ac7eb49c36aa4c0ef3d5ac567e31ce647","modified":1723907474404},{"_id":"source/images/git.png","hash":"468fcceae3d9260bd64fb531106d3cfd28d9d321","modified":1723963530079},{"_id":"source/images/liuyanban.jpeg","hash":"0f8795cf75733493ffa43a6b3cded703ce4a2d48","modified":1723964157109},{"_id":"source/images/logo.jpeg","hash":"1e0f89eb6c2df039baeb70230638cf584a1cb1d3","modified":1723968422143},{"_id":"source/images/load30.png","hash":"c689d35af16fe9f040e40598db2065b0cb0189e3","modified":1723803469458},{"_id":"source/images/load10.png","hash":"4076ee1111fa2062139614ef45057ba6886d74e4","modified":1723805518721},{"_id":"source/images/load60.png","hash":"73051eb2c54f2bbbf54c6907c0d766829da12109","modified":1723803502068},{"_id":"source/images/music.jpeg","hash":"d2f291d9993f84032375bdce650d2ad5abb954e7","modified":1723963918742},{"_id":"source/images/server.jpg","hash":"02e933b77901f8df62d9576c5a0a0211790f8167","modified":1723884776667},{"_id":"source/images/perftop.png","hash":"1489c907cc0278a6803c204792803bff98fd66ce","modified":1723783369753},{"_id":"source/images/stress-cpu.png","hash":"91839b4f8c115981fd31ce2dc7a957143e5d6f08","modified":1723722218268},{"_id":"source/images/top.png","hash":"a16eb91f4a11db4cefa61e4559588aac3626793b","modified":1723719871917},{"_id":"source/friends/index.md","hash":"93c6466b6dfb05b810f37f6370ea566b95223f19","modified":1723904822654},{"_id":"source/images/vmstat.png","hash":"c9cf2b97a3fee6dea79ac46252999b5bf28a7510","modified":1723541076248},{"_id":"source/comments/index.md","hash":"c3320621b69c638c5b75e48fbb244afc0d4bdd84","modified":1723964749280},{"_id":"source/images/gc.png","hash":"ba28184e39dac6e2f18da06e481337441226c8c6","modified":1723540745522},{"_id":"source/images/java.jpg","hash":"f8b81e75fd682ce8efdb21144be635ccd1ed0cdd","modified":1723884130363},{"_id":"source/images/javafire.png","hash":"118c0a92a404c68bb98c7da781617ac3632c2899","modified":1723798820453},{"_id":"source/images/top-process.png","hash":"582d184a7c7af782bd7040ead0d5d8c8abee4030","modified":1723721873257},{"_id":"source/images/javaperftop.png","hash":"cc8aed116972b9e62e9b6f961e17cd14dca24f5d","modified":1723788874806},{"_id":"themes/stellar/layout/_partial/widgets/search.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1723860608693},{"_id":"themes/stellar/source/css/_components/widgets/tree.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1723860608713},{"_id":"themes/stellar/.gitignore","hash":"cf4e2dcaa760ff6f7520fd032ce44574e2970e54","modified":1723860608683},{"_id":"themes/stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1723860608683},{"_id":"themes/stellar/.npmignore","hash":"9f66a3a5bea36f32c51cbfff88f1a45b74c80592","modified":1723860608683},{"_id":"themes/stellar/package.json","hash":"5ad06200f2df1c9430d6feb7ca666b99dd16a5d6","modified":1723860608696},{"_id":"themes/stellar/README.md","hash":"d474d9b14cafda27ab291336cbdb4ac91bfec756","modified":1723860608683},{"_id":"themes/stellar/giscus.json","hash":"af57a96a9dc188079bdcd0ad4273f1765778f5ea","modified":1723860608684},{"_id":"themes/stellar/npm-publish.sh","hash":"b137d2f0d48fccd065ba1750b886f33ad7a7236a","modified":1723860608696},{"_id":"themes/stellar/languages/zh-TW.yml","hash":"fa911ea00c326a1b261cc3e5f1770b27e0238ccf","modified":1723860608685},{"_id":"themes/stellar/languages/zh-CN.yml","hash":"faaf9f9e0728f4fff885f9591cd4daef0b195f25","modified":1723860608684},{"_id":"themes/stellar/_config.yml","hash":"ea66842bdc0b6391c0411638bac8654ccdff5313","modified":1723877609880},{"_id":"themes/stellar/layout/archive.ejs","hash":"af072e9b75e8d5371771237e71a1f1381078526a","modified":1723860608695},{"_id":"themes/stellar/languages/en.yml","hash":"5397b48828cceb50a071ee0f3b1432e304cad8ae","modified":1723860608684},{"_id":"themes/stellar/layout/404.ejs","hash":"d84f01256feb3c0bc0b280031fb78ae9f0d86f26","modified":1723860608685},{"_id":"themes/stellar/layout/index.ejs","hash":"ea5fa65b2049bc1c4c8c247972a79310468e3c68","modified":1723860608695},{"_id":"themes/stellar/layout/index_topic.ejs","hash":"6bffb1488ce9c2c4b04386cb7fe61792ae5491f2","modified":1723860608695},{"_id":"themes/stellar/layout/categories.ejs","hash":"eaf71831abd6780690f26fa1a7cf83bc6f08d7e9","modified":1723860608695},{"_id":"themes/stellar/layout/index_wiki.ejs","hash":"9e7dc6941c5205ed60fa7abfb1f36ae19e2f3834","modified":1723860608695},{"_id":"themes/stellar/layout/notebooks.ejs","hash":"7519887f825bc9ae1ca842e02bc5b2ad909e77a9","modified":1723860608696},{"_id":"themes/stellar/layout/notes.ejs","hash":"242f663e983fc496c51aab9531ccfe46b0d1b05e","modified":1723860608696},{"_id":"themes/stellar/layout/page.ejs","hash":"af600622274600941309fb7c06ebe860ceca24f2","modified":1723860608696},{"_id":"themes/stellar/layout/tags.ejs","hash":"4ff8ccff9a9c8d373df788fbc0bebdc87302056e","modified":1723860608696},{"_id":"themes/stellar/scripts/filters/index.js","hash":"5667f028990dd556133080090a5fcb00c64f05ac","modified":1723860608698},{"_id":"themes/stellar/scripts/events/index.js","hash":"01a8d06a48af2f20aacfac76962bde5edd83dd3f","modified":1723860608696},{"_id":"themes/stellar/layout/layout.ejs","hash":"1202be25819c066d85b2807a80a22e4020c0431e","modified":1723957201403},{"_id":"themes/stellar/.github/ISSUE_TEMPLATE/any-question.yaml","hash":"312caa37c7c3090b496167e6da5f82099ca4de4e","modified":1723860608682},{"_id":"themes/stellar/.github/ISSUE_TEMPLATE/article-share.md","hash":"f88a131062c94d8dadd0536e841966bf8547e1a7","modified":1723860608683},{"_id":"themes/stellar/scripts/helpers/category_color.js","hash":"20b19d6b6307cdeb0b0832bf4931366abe972490","modified":1723860608699},{"_id":"themes/stellar/scripts/helpers/icon.js","hash":"b7c84be7f08abc1725f351ed8718791a861466c3","modified":1723860608699},{"_id":"themes/stellar/scripts/helpers/parse_config.js","hash":"1251d82318972f22283dc7a089b77a3f0135b1b6","modified":1723860608699},{"_id":"themes/stellar/scripts/helpers/related_posts.js","hash":"6763a97fa25669fa1d1aa8e5291919deb5dc7f67","modified":1723860608699},{"_id":"themes/stellar/scripts/helpers/scrollreveal.js","hash":"57e3da4a3dd751b3ebd384a674e26f08f69da018","modified":1723860608699},{"_id":"themes/stellar/.github/workflows/label-commenter.yml","hash":"f89d116ba78e3fd4a0695c2ac4176e46e3c92028","modified":1723860608683},{"_id":"themes/stellar/.github/workflows/npm-publish.yml","hash":"9e95a1f04628056117df5ab8615acd36f3d63283","modified":1723860608683},{"_id":"themes/stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1723860608699},{"_id":"themes/stellar/scripts/helpers/utils.js","hash":"05c127baa250b192c9c673355bf90d7134e1ea11","modified":1723860608699},{"_id":"themes/stellar/_data/icons.yml","hash":"1ba122dcac1ed8fa1443b0baa0c9b9f1d007b7fe","modified":1723860608684},{"_id":"themes/stellar/scripts/generators/categories.js","hash":"936d4d406fd401359bab1e5f74c6e1e097e8f092","modified":1723860608698},{"_id":"themes/stellar/scripts/generators/notebooks.js","hash":"9ea0dc7408e11ae0e5abc89bd0c929d640a6e069","modified":1723860608698},{"_id":"themes/stellar/scripts/generators/tags.js","hash":"ed29755154d8e7a9346019ba4ac8782a8649b177","modified":1723860608699},{"_id":"themes/stellar/scripts/generators/search.js","hash":"404f28ea5d77cee462a551d8f74c9f7c41f73ba0","modified":1723860608698},{"_id":"themes/stellar/scripts/generators/topic.js","hash":"88c0f2990365fb0ce751682815e07f36cf333d3f","modified":1723860608699},{"_id":"themes/stellar/scripts/generators/author.js","hash":"0de0824fdbc4f67c84910267901095504b253751","modified":1723860608698},{"_id":"themes/stellar/.github/configs/label-commenter-config.yml","hash":"acae6f9e872bd6a462e711771aeedcb7cdca0a86","modified":1723860608683},{"_id":"themes/stellar/scripts/generators/wiki.js","hash":"61efe22787c3fea9d935df4b088a9dd2d1af0868","modified":1723860608699},{"_id":"themes/stellar/scripts/tags/inline-labels.js","hash":"a9cb7520af8a95f467c048128c036cbb3167fb8d","modified":1723860608700},{"_id":"themes/stellar/scripts/generators/404.js","hash":"66b53d2b35b18d5f3835b47467c23f31eb322553","modified":1723860608698},{"_id":"themes/stellar/scripts/tags/index.js","hash":"fca7eca8f4dde5876e7b4b9242b1b034ef540c5a","modified":1723860608700},{"_id":"themes/stellar/_data/widgets.yml","hash":"df27411efc301dc94caa756b9ddc8680a1427fe7","modified":1723970976531},{"_id":"themes/stellar/source/css/darkmode.css","hash":"acaad72e2c3eb183b54ae9ba23981141fc025140","modified":1723965100155},{"_id":"themes/stellar/source/js/darkmode.js","hash":"f475db6eb867d4790843eed74b75dd76d932f42a","modified":1723965057879},{"_id":"themes/stellar/source/css/_custom.styl","hash":"58e0e4d48aa890a48604873e76cb8a44a04b6d3d","modified":1723860608713},{"_id":"themes/stellar/source/css/main.styl","hash":"44b5008a50682b442f38f1cc2ffd117e4dfc9ec5","modified":1723860608715},{"_id":"themes/stellar/source/js/main.js","hash":"41ddd41a9f1896ad548a8eaa8610da2f823009ba","modified":1723860608715},{"_id":"themes/stellar/layout/_partial/head.ejs","hash":"3fac057477e1fbddbfba9189f598998a52d4fadb","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/menubtn.ejs","hash":"36775d16431301a6ac02858f32a8ee470ef8332f","modified":1723860608690},{"_id":"themes/stellar/layout/_plugins/copycode.ejs","hash":"7cedd8eced00f6813f7d772334ec92acbc8bd982","modified":1723860608694},{"_id":"themes/stellar/layout/_partial/scripts.ejs","hash":"25a6ec0b1fa8eda21f3d25539f59dc0d84491bec","modified":1723860608690},{"_id":"themes/stellar/layout/_plugins/heti.ejs","hash":"c3956c8fd5fabd4ec8cea05dc076bf7a03eb012a","modified":1723860608694},{"_id":"themes/stellar/layout/_plugins/index.ejs","hash":"29407e95f14d4d50c1f8a8b9a5af242927676432","modified":1723860608694},{"_id":"themes/stellar/layout/_plugins/mathjax.ejs","hash":"c1621e718747a6eb34734e7e4a8364f5a78dc714","modified":1723860608694},{"_id":"themes/stellar/layout/_plugins/lazyload.ejs","hash":"e2b07b0c97d531c82cc02a80610fe0c1a39bc837","modified":1723860608694},{"_id":"themes/stellar/layout/_plugins/preload.ejs","hash":"f25523da5633b249da8cebe7c866265bf7825697","modified":1723860608694},{"_id":"themes/stellar/scripts/events/lib/config.js","hash":"ab74c3df31ad21b842d859af40c1131dbd8fd2d7","modified":1723860608697},{"_id":"themes/stellar/scripts/events/lib/authors.js","hash":"eedefb5430fc4176bdc2814c8a88295f0e524d10","modified":1723860608697},{"_id":"themes/stellar/layout/_plugins/mermaid.ejs","hash":"8ef22ac075890554521f464f6b92dc1fb7538b37","modified":1723860608694},{"_id":"themes/stellar/scripts/events/lib/links.js","hash":"881cac75e4071d219a18156738e18eb397d83c00","modified":1723860608697},{"_id":"themes/stellar/layout/_plugins/fancybox.ejs","hash":"dcb638d9320eea6c9a6b7b0212e6167341bec05b","modified":1723860608694},{"_id":"themes/stellar/scripts/events/lib/merge_posts.js","hash":"4e45b8dc5317f7d66bc14879ae6b5f972123ce5d","modified":1723860608697},{"_id":"themes/stellar/scripts/events/lib/topic_tree.js","hash":"7f735f2573c87d202e2d4b845307d0725d619e8e","modified":1723860608697},{"_id":"themes/stellar/scripts/events/lib/utils.js","hash":"271ba6c8cc997e4f55b2e146a99bde8301818400","modified":1723860608697},{"_id":"themes/stellar/scripts/events/lib/notebooks.js","hash":"ad5eae17a77a92100c748fd668c73e1b09f7a21f","modified":1723860608697},{"_id":"themes/stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1723860608698},{"_id":"themes/stellar/scripts/events/lib/doc_tree.js","hash":"e217f244af98b1151e7f57e9e77812f3a1e2ad78","modified":1723860608697},{"_id":"themes/stellar/scripts/tags/lib/albums.js","hash":"9fd16a8ceffd1806c25582062af7a72eca0e5c56","modified":1723860608700},{"_id":"themes/stellar/scripts/tags/lib/audio.js","hash":"9b094b16dce131a5c09373661c88a1de9b5326f7","modified":1723860608700},{"_id":"themes/stellar/scripts/tags/lib/banner.js","hash":"1fceb77a37ecaddf38c03aa655eec878701427c0","modified":1723860608700},{"_id":"themes/stellar/scripts/tags/lib/about.js","hash":"c9778c35c1ccd9f2018174bafbd37b23dd52cf62","modified":1723860608700},{"_id":"themes/stellar/scripts/tags/lib/box.js","hash":"753ae16a343ae82628f2057bd9cf09ea376fdbb5","modified":1723860608700},{"_id":"themes/stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1723860608698},{"_id":"themes/stellar/scripts/tags/lib/checkbox.js","hash":"69caf7488b6c92cb2524df81ece6f33a46a89fe0","modified":1723860608700},{"_id":"themes/stellar/scripts/tags/lib/copy.js","hash":"d22a82b6fd9c96c7ac49677b427e6c629fa889d7","modified":1723860608701},{"_id":"themes/stellar/layout/_plugins/swiper.ejs","hash":"b80d6185c0263375df82498705a98ad32238b12f","modified":1723860608695},{"_id":"themes/stellar/scripts/tags/lib/button.js","hash":"e0890a759335b1c5ad09db084bcf62073b2557cb","modified":1723860608700},{"_id":"themes/stellar/layout/_plugins/scrollreveal.ejs","hash":"1f3b98068a4db7ec709b47e134520af16f59fa71","modified":1723860608694},{"_id":"themes/stellar/layout/_plugins/tianli_gpt.ejs","hash":"c63f65df336bd10b2c5f068830c3086f3f13f3a3","modified":1723860608695},{"_id":"themes/stellar/scripts/tags/lib/folding.js","hash":"b1efa6e86b1f8f25a58376349f21117902e5bb01","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/emoji.js","hash":"e10f68f69206fc6e9d0c478630be2b4514d328d7","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/folders.js","hash":"853a75c8b4f445f64a18420929c31865db30cd39","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/friends.js","hash":"da08a75ad3579464debe8da2dd57314bd641dbb2","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/gallery.js","hash":"56a9309b096cbe1876a1e8c2b7c3f692325135e1","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/grid.js","hash":"dad59b638c2fd30538e3a69bf0c8d76d34cf3ece","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/hashtag.js","hash":"f38ce98fff40ed35be9b1f1be3194bc4c5d44dc3","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/icon.js","hash":"273898ae29a07c1baccb432efa0d33ccfabe7db9","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/image.js","hash":"aa10441f0ec79b2f33829e5b1b8b4b4c21d865e9","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/ghcard.js","hash":"039ee39d8dba7c0aa0e267de38f9064b30855a55","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/frame.js","hash":"1251a8622260af8efc55c2f0aac8ee5cf79d9043","modified":1723860608701},{"_id":"themes/stellar/scripts/tags/lib/navbar.js","hash":"e78ca3469c44362c7d8c3ad8899f49a119b326ff","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/md.js","hash":"6ed5db6d055dbfe01ecaeddbd0ead13a20ba7e74","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/note.js","hash":"a70d1fcb440ad029ddddb72b053a59b1ed3bfef8","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/okr.js","hash":"8e7a7d912e4f5e1fe1feb6125e4762c378b11ba3","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/poetry.js","hash":"c36321caeec845ed131bdd0922bff25eb59f086a","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/quot.js","hash":"f15aa5c0fc87114a98e51baefb048b22302f7474","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/posters.js","hash":"713e1367f3a60e5903954a8fab15b0d9d9cfd89a","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/sites.js","hash":"298f42f3097a19e5d229099964e15dac7d46e1b0","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/tabs.js","hash":"1b3d7b6b962293b44430e7b40560b8d1fa5c618d","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/swiper.js","hash":"dc025c79b190d233383fec001ddbe478f2675cc8","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/video.js","hash":"181f1408fdfe355cafc5715618015ad10caca425","modified":1723860608704},{"_id":"themes/stellar/scripts/tags/lib/mark.js","hash":"cfd8198f349dba60fbdf53042b6ebd9a0ba521c7","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/timeline.js","hash":"f1defeed67e56c055f37ee7fab8a597a9d14f89e","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/link.js","hash":"8a1297c324749f98e24036d3aa91ad374ad1d930","modified":1723860608702},{"_id":"themes/stellar/scripts/tags/lib/toc.js","hash":"d7b51b66d7b83a77e501930e735092a9967d5d18","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/blockquote.styl","hash":"f107e6f399382a6663722bc2e823986c257da9a3","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/base.styl","hash":"2986c5771652c353a320f4404ceeb1c6b257a6ed","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/button.styl","hash":"9afb3e566294f95f404a608b666367081a691e6b","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/device.styl","hash":"fa135f5d93f8a333cc77f7dd4f6b8bf88e0f43bd","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/html.styl","hash":"e7f596ff7294517096f5cb27f5af53b1a797e047","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/blur.styl","hash":"43441caaee7b7ab011a26016362b023263cd64a8","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/cap.styl","hash":"c99286644d4a44dc76e1fe9a3af1815112f65acc","modified":1723860608704},{"_id":"themes/stellar/source/css/_common/input.styl","hash":"953fc87072cd760d92dfef55310addbb17bb2b51","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/layout.styl","hash":"c7d0d3c70087e14bd1f6d8d50d56762d8c5ad44d","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/highlight.styl","hash":"2e1191dbfa6e77a53ea9e95cecf66dc5b3d63b81","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/loading.styl","hash":"6962fd568ad9779146742b8b8928cec107972e8e","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/media.styl","hash":"fa7dbcaa31089fe547acb01a767af97fb019bba6","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/pre.styl","hash":"be7ecc0a1cdd2e6f1594c4cc238734b2dc3a2c4e","modified":1723860608705},{"_id":"themes/stellar/source/css/_common/title.styl","hash":"c9009b6c52a1ea4dfb6c2f56b1c3fc6de8a2c63a","modified":1723860608706},{"_id":"themes/stellar/source/css/_common/span.styl","hash":"86462ffaf1603b5d5ab6534c0f7fe0eb495aad2d","modified":1723860608706},{"_id":"themes/stellar/source/css/_common/svg.styl","hash":"aa2ae391db2ea028b9221740b24fca7f7e9ff16c","modified":1723860608706},{"_id":"themes/stellar/source/css/_common/toast.styl","hash":"f2930874174763da2338fa95087c345bf5c41800","modified":1723860608706},{"_id":"themes/stellar/source/css/_defines/const.styl","hash":"c62a434f1eef895d343cb8255a19c6f1a6c73195","modified":1723860608713},{"_id":"themes/stellar/source/css/_defines/func.styl","hash":"058d01ec243db6c123503274ca691586c9859d09","modified":1723860608713},{"_id":"themes/stellar/source/css/_plugins/aplayer.styl","hash":"00b6e9209638eef9f70e75a24a5a90b05f7b5347","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/copycode.styl","hash":"a9f27136143eb779d1aeb903e863c94a98b82aac","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/katex.styl","hash":"64a0208a475811c8a022536441188a161d9dd05d","modified":1723860608715},{"_id":"themes/stellar/source/css/_defines/theme.styl","hash":"467e23f3c13834ccfcc814c0efae3e13b9dfe8e0","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/mermaid.styl","hash":"b01f298bb006abfe00bf68566bcc53c3cad4a6e7","modified":1723860608715},{"_id":"themes/stellar/source/css/_plugins/lazyload.styl","hash":"6cd216067594d07c097a66e2403df36a1abbe6d6","modified":1723860608715},{"_id":"themes/stellar/source/css/_plugins/swiper.styl","hash":"46179e1e9ca273f4e095388d981acdc9fce5bdb8","modified":1723860608715},{"_id":"themes/stellar/source/css/_plugins/scrollreveal.styl","hash":"21b9125c1bae3e5348547e85500ceb992de21923","modified":1723860608715},{"_id":"themes/stellar/source/css/_plugins/index.styl","hash":"f96caf6f1d582973bc71199eee478cfc9fe88085","modified":1723860608714},{"_id":"themes/stellar/source/css/_components/index.styl","hash":"7a7ab293e065116646102546c6bab01166836059","modified":1723860608706},{"_id":"themes/stellar/source/css/_components/layout.styl","hash":"b7eb188db92bb9a32ae180969838f6eda2ec9640","modified":1723860608706},{"_id":"themes/stellar/source/css/_components/list.styl","hash":"326015062dd68c7ee8272416cf4f7732d20482cb","modified":1723860608706},{"_id":"themes/stellar/source/css/_components/main.styl","hash":"41040b445d23ff4e56656ce3ca4e0fd7fd67d67b","modified":1723860608706},{"_id":"themes/stellar/source/css/_components/md.styl","hash":"5cc0379fd0d4abf7a34944ccff1cf0b7dafdf091","modified":1723860608706},{"_id":"themes/stellar/source/js/search/algolia-search.js","hash":"2b4cc743d66fbdbe37f2311963d54d957637ca3e","modified":1723860608716},{"_id":"themes/stellar/source/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1723860608715},{"_id":"themes/stellar/source/js/services/fcircle.js","hash":"add550bfb204a2057661d4d6630d78ebf485754d","modified":1723860608716},{"_id":"themes/stellar/source/css/_plugins/tianli_gpt.styl","hash":"6cc2d27b8ec0296de09ce38d15abdd966702b79a","modified":1723860608715},{"_id":"themes/stellar/source/js/services/friends.js","hash":"581a2baa085df422b752cbec098ca56aac691790","modified":1723860608716},{"_id":"themes/stellar/source/css/_plugins/fancybox.styl","hash":"f4a709dcac4e21ca0fbeca552a8dde2ac2bf8d97","modified":1723860608714},{"_id":"themes/stellar/source/js/services/ghinfo.js","hash":"94b86ce42dd765e9a4c1befa72ee9648d7ec6f88","modified":1723860608716},{"_id":"themes/stellar/source/js/services/mdrender.js","hash":"947f476e6dd8ca6a75f87f6ac6f2fbb2b0861e82","modified":1723860608716},{"_id":"themes/stellar/source/js/search/local-search.js","hash":"cf710d711fcbc21122cdc01edd43d9b4087f1b9d","modified":1723860608716},{"_id":"themes/stellar/source/js/services/sites.js","hash":"5626b70d13360933c581983dcda422e4fccdc810","modified":1723860608717},{"_id":"themes/stellar/source/js/services/siteinfo.js","hash":"74da788f29862604cd53f6b82b036ff56c715d21","modified":1723860608716},{"_id":"themes/stellar/source/js/services/memos.js","hash":"2d430c7ae4d9f3a44653eda0214d18fb60bcfed1","modified":1723860608716},{"_id":"themes/stellar/source/js/services/weibo.js","hash":"437e631539f3a50cf8b46ff17008404609c1c481","modified":1723860608717},{"_id":"themes/stellar/layout/_partial/comments/layout.ejs","hash":"3dbdb141d295d25b4f67fd0e299c40baa38241a8","modified":1723860608686},{"_id":"themes/stellar/source/js/services/timeline.js","hash":"41cde82427726c3366b64b1f54f1aed9bc20fcf1","modified":1723860608717},{"_id":"themes/stellar/layout/_partial/comments/script.ejs","hash":"62be59ef634ceee342c81ecc4e23cb664cdbf620","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/cover/index.ejs","hash":"4b317700640749b1e04e6d51a542a2bcd28c8b72","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/cover/post_cover.ejs","hash":"59e6ae6726ded33e3d84208fd4a4872a6431fcc7","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/sidebar/index_rightbar.ejs","hash":"a16ecd6d9421c30ffe2ca1a44cc9597309b5b70c","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/sidebar/index_leftbar.ejs","hash":"3ce47de8a4e832454da10e271e4855b15cb3d9e7","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/cover/wiki_cover.ejs","hash":"8374cf58d5cc52799b8e1c8af95dd84c65372173","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/sidebar/search.ejs","hash":"770056e023a00b22d2853c4fa65bb48035ade3b2","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/sidebar/menu.ejs","hash":"59d579a0eaec7572485d8d4d22341de79a890d00","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/sidebar/logo.ejs","hash":"cd08385b0026953cd9adf5c22af528b9c3e924e7","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/widgets/author.ejs","hash":"4c7eab461e45a7a5863333e9904dadbed6c8ca0c","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/widgets/ghuser.ejs","hash":"5d8cf68b091f8bf4b88ac230495bc2dec561ad6a","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/linklist.ejs","hash":"813336cbbe4505e9be42d5682fd7b720dba25194","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/main/footer.ejs","hash":"52e2f251a775109a9d612028383e103ea1a47806","modified":1723972007277},{"_id":"themes/stellar/layout/_partial/widgets/ghrepo.ejs","hash":"e7d23ff8f8c96f77685e441c7f6040430d07a21a","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/widgets/ghissues.ejs","hash":"410f56e6da87e7a1476d033c6939a0241658a598","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/widgets/markdown.ejs","hash":"7ce0ce941c55e42c545c1fffa77a3db07e1989b1","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/recent.ejs","hash":"3962a8b6f3c1adc80ecc846e6ad0888722ec5464","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/main/footer.ejs.bak","hash":"52e2f251a775109a9d612028383e103ea1a47806","modified":1723971570597},{"_id":"themes/stellar/layout/_partial/widgets/tagcloud.ejs","hash":"d95c26f84c7d9061ba3ef6188d58fa14f1c63bf3","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/tagtree.ejs","hash":"9941285c0af5d5fbdf5e8e5b1c73f67304d9afed","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/related.ejs","hash":"ac6040f2067c799836d5dc4abacf0b879a156d88","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/toc.ejs","hash":"fd0be7f0f60cea0e0e637d122af47a601f56010c","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/tree.ejs","hash":"2a7d37a843e32d073be4637bc17980e368a16003","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/widgets/timeline.ejs","hash":"745b384871291e0cf2f6ceb4a0c12989b4e8cd62","modified":1723860608693},{"_id":"themes/stellar/layout/_partial/scripts/defines.ejs","hash":"93393f0fbd25f09363ada3adefd97ccb9ebd5893","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/scripts/sidebar.ejs","hash":"403b6986bfc54177a7ee3ddba9e0a55e7b79e3a1","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/scripts/theme.ejs","hash":"87022a734dc2f4be8549463111696bbbf6f950b1","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/scripts/tagtree.ejs","hash":"c16031694fee3e0c305139136126dee88e1e88cf","modified":1723860608691},{"_id":"themes/stellar/layout/_partial/scripts/services.ejs","hash":"ebe96e8b8edef9f48c80cff0e97b588dc8a1c859","modified":1723860608691},{"_id":"themes/stellar/scripts/tags/lib/read/paper.js","hash":"e87bbcf10f743e1fcfadc03cf6281aee87c255f5","modified":1723860608703},{"_id":"themes/stellar/scripts/tags/lib/read/reel.js","hash":"3a833a0c7d29f98972d6141103d62d5abfd913e4","modified":1723860608703},{"_id":"themes/stellar/layout/_partial/scripts/utils.ejs","hash":"a2a0d37c33b05c9020dbebe457e53283bff72a95","modified":1723860608691},{"_id":"themes/stellar/layout/_plugins/search/algolia_search.ejs","hash":"654fa8e2d695e5aa16988dfcd7dfab1b9b27d6f9","modified":1723860608695},{"_id":"themes/stellar/layout/_plugins/search/local_search.ejs","hash":"38a3641bb532583b699fda42175cb14242f07575","modified":1723860608695},{"_id":"themes/stellar/source/css/_plugins/comments/beaudar.styl","hash":"e9800f67a650f1c022aee494768e05da76e6a6b7","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/comments/artalk.styl","hash":"279d7185e0ea65a8f5e1f783eaa3f83bc7bf3555","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/comments/twikoo.styl","hash":"c30662f7635bbfd7b4ecde949fdec40aee4b6bce","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/comments/utterances.styl","hash":"be43f728d9515acaf050fbb3eed83cfefa2fe702","modified":1723860608714},{"_id":"themes/stellar/source/css/_plugins/comments/waline.styl","hash":"9efd82d46da9bb4adb09f7ad1eea31a599608163","modified":1723860608714},{"_id":"themes/stellar/source/css/_components/pages/archives.styl","hash":"a99f09f4cc948588d071f8cd95362f2d70ec4c40","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/pages/notebook.styl","hash":"2f9199575a7a58490d5faf023511781066370dae","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/article-footer.styl","hash":"762c38e63aebbd028b5aed264349fa1d2a14e8af","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/bread-nav.styl","hash":"daf58b32af0b5dfea6cbfa1c3cab695976e57164","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/article-banner.styl","hash":"325a1398d84e50cfae13b70f01aeaaf037ef54c1","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/footer.styl","hash":"363fd4daf060fbf7de56fe5df787bc325565791b","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/cover.styl","hash":"ef44c47d0a70feb84d69cf8bb2bc6977f61b94f2","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/partial/navbar.styl","hash":"282291ee0f876ea14cff671555ab9defe8fc2318","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/partial/related.styl","hash":"b413ab434cfb778384fbac64d43da41437435aa0","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/sidebar/footer.styl","hash":"ac3423d488259ea467e95325e12f57476a9bdc9c","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/sidebar/logo.styl","hash":"f81eb3d7a49c71f728d8bf42081bde30c6ff596e","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/partial/paginator.styl","hash":"d5a64f3820ffc0913086c9fa35b26391eb023e61","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/sidebar/menu.styl","hash":"57f772066edaa2cbe560622de28035780ad9000b","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/sidebar/nav-area.styl","hash":"5302a72d15f7c35b391da723e84592f1129fca57","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/sidebar/sidebar.styl","hash":"aaac0bc311badd146a11d3276ce89a4361c52ad4","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/sidebar/search.styl","hash":"ea880602a99ed8cb9b87f410e1f340b4d23d38e8","modified":1723860608708},{"_id":"themes/stellar/source/css/_components/pages/error.styl","hash":"91f9df285a87bc7b7e9da19d547ea4b1dc392828","modified":1723860608707},{"_id":"themes/stellar/source/css/_components/widgets/components.styl","hash":"34280561524a535342da3f246443b2a94fef074d","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/widgets/ghrepo.styl","hash":"73d5baa3dfcc9e73fc7470e1ebe244857ffd75c1","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/widgets/markdown.styl","hash":"f5a431cd88fca7f328634e13eff50a55b34b734b","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/widgets/list.styl","hash":"176281f5ccc64f87da4bbd4e34316e32017bc3b4","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/widgets/related.styl","hash":"8464b5adb8ffcd086d0e748849d907871d149223","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/widgets/ghuser.styl","hash":"16c62c701f9cf6a253c6390d43eaa01cfd7600b1","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/widgets/tagcloud.styl","hash":"c452b18f1242c634c0e124a46414cbc7c65da494","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/widgets/timeline.styl","hash":"ab1901de4acfe89b642cd721d7d08b1b0009661b","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/widgets/toc.styl","hash":"f290d98a4d721b523b0c972b7de61a86b05b1086","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/widgets/widgets.styl","hash":"7d383e58d54bf40806027fa22ab0ba70b5ab4fde","modified":1723860608713},{"_id":"themes/stellar/source/css/_components/tag-plugins/banner.styl","hash":"f49a123a61cb02c65eebb79adefae9a6f8b8e2fc","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/button.styl","hash":"19469c881d8798916ea45ec11ecd5348146e7927","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/about.styl","hash":"cdaf1ccd782db961cecda0802c94dabe27656731","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/checkbox.styl","hash":"1cd33e27fd539ed2a6cb41d4fc59294f1dd315b4","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/common.styl","hash":"a0a0e36d7672271147853bae34eb15b1ad2f0eef","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/copy.styl","hash":"2e00b4923bf8a4cf1b742d19cf26165cc65fcffe","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/emoji.styl","hash":"100d2e0c43496464dd97fa83fa3e603e68bf30e9","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/folders.styl","hash":"2eae18b521a613a19dd6399dcb5504f843dcbb88","modified":1723860608709},{"_id":"themes/stellar/source/css/_components/tag-plugins/folding.styl","hash":"84eb11a5a5808f3a4bd0985d97a7b108a36fd044","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/friends.styl","hash":"4d412ca8388ff65979b9a619a7ae2fe212a90bac","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/frame.styl","hash":"f8621b5a155ea78c5828e7ccbd1dfe6a72c9733c","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/gallery.styl","hash":"52be8d049ce7533084aa3a6f361b4f365086af02","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/icon.styl","hash":"ea5372d1042db221f6c3ce5a31e18153c5e00d39","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/image.styl","hash":"beb0eb953d11489d4eaf16282784625062c81d9f","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/hashtag.styl","hash":"0e2e74fcff5c30be9533e451a1c06ed1477dc9aa","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/inline-labels.styl","hash":"96aad4c7710ed7097842fab77473b66a298b6e3f","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/mark.styl","hash":"1227da0705c294abab7030439d1e505c6b304ccf","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/index.styl","hash":"d76245514a5a0aecb65120b7117cd125a70617fb","modified":1723860608710},{"_id":"themes/stellar/source/css/_components/tag-plugins/navbar.styl","hash":"c2c3da16355f2dfd316edd11d9f2f2c50bc5299c","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/okr.styl","hash":"0c2d281e90c8cb1a0de5ff516dca0e08ae7db141","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/note.styl","hash":"5e59f5ab728c2ad5b5e4e06b0dd694407bb14096","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/media.styl","hash":"61541156e59cd946b86626b4b2af0a2f24546f25","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/quot.styl","hash":"15c6726b2ea1d5ff7a12a310766145dffde4e778","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/link.styl","hash":"b91bb69a2f84567f87c2665c3dbaeb8831487185","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/override.styl","hash":"6a31ef8c4dc7caa655ed7d852100abb2711ab5ac","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/sites.styl","hash":"0b765b154695d544fa5dfab562e60a48c49f8547","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/tag-plugins/poetry.styl","hash":"6d15463121a741b69249318cadabf4bd06b4b3c6","modified":1723860608711},{"_id":"themes/stellar/source/css/_components/tag-plugins/tabs.styl","hash":"b9bb4cf9442c0d4c09951c2fb886dbf8d0fe8de0","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/tag-plugins/toc.styl","hash":"18577b1c775f14da4b70cf3a8db56aa229f733c8","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/tag-plugins/timeline.styl","hash":"a5ef35db9c54905770c0ab68471ec054b0a83d9e","modified":1723860608712},{"_id":"themes/stellar/layout/_partial/comments/artalk/layout.ejs","hash":"14b26d696ba6644ef9d5854e1b4a8fda028bddb9","modified":1723860608685},{"_id":"themes/stellar/layout/_partial/comments/artalk/script.ejs","hash":"beee3759c0501f1ed5266fc6725332b1e1d54dce","modified":1723860608685},{"_id":"themes/stellar/layout/_partial/comments/beaudar/script.ejs","hash":"69a2582d4e9e3203368196f4806adab2274e41fb","modified":1723860608685},{"_id":"themes/stellar/layout/_partial/comments/beaudar/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1723860608685},{"_id":"themes/stellar/layout/_partial/comments/giscus/layout.ejs","hash":"144e313ab45889c715ea1cfff3976b1f1322469e","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/comments/giscus/script.ejs","hash":"49fd68b7752d0ca06d80a52bf800cf03845909e0","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/comments/utterances/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/comments/twikoo/script.ejs","hash":"3c93fe825769cd70027281c28980021b3ff8c4b0","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/comments/utterances/script.ejs","hash":"0c54bbd610c1b31d7f45b9b4ded65690b673482c","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/comments/twikoo/layout.ejs","hash":"a3d429f4eafc582f739dd48865b39afd7c22ed56","modified":1723860608686},{"_id":"themes/stellar/layout/_partial/comments/waline/layout.ejs","hash":"2abe764ffeab5603645b0e5148a17e9373de5eb4","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/comments/waline/script.ejs","hash":"ef4b59476f4edf03cb25bdffe449b5da161d1d8e","modified":1723860608687},{"_id":"themes/stellar/layout/_partial/main/article/article_footer.ejs","hash":"e93326cdd00f97d363c4830a81d7adb4dcae507c","modified":1723860608688},{"_id":"themes/stellar/layout/_partial/main/article/read_next.ejs","hash":"30c9e20e6835fa92a528de61041742ff42cc2af0","modified":1723860608688},{"_id":"themes/stellar/layout/_partial/main/article/related_posts.ejs","hash":"ef485a4dc2db40bd68b35128f2140520db859b45","modified":1723860608688},{"_id":"themes/stellar/layout/_partial/main/navbar/article_banner.ejs","hash":"1651576216695b49980cf4531a0020ab82fb65c7","modified":1723860608688},{"_id":"themes/stellar/layout/_partial/main/navbar/ghinfo.ejs","hash":"f5177430efd994b7c2d9d3104a58b0f1f60f4a00","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/dateinfo.ejs","hash":"f0ce9221931e9113de3df27eac39313eb0df217b","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/nav_tabs_wiki.ejs","hash":"bb8644df466868a879fc97bc364f1aba6b1137cf","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/nav_tabs_blog.ejs","hash":"9a37405585fdabb01aca7b367ebb3ca4ed20d1ff","modified":1723860608689},{"_id":"themes/stellar/source/css/_components/tag-plugins/grid.styl","hash":"606311fa8326152f99fc721284a09e06490d0cca","modified":1723860608710},{"_id":"themes/stellar/layout/_partial/main/post_list/paginator.ejs","hash":"1a4b3bc64325ec7d5932ea78c36f2ec4978c09eb","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/main/post_list/post_card.ejs","hash":"dab8decf3ebf7a2d4d829a534af76e8500fbffbb","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/main/post_list/topic_card.ejs","hash":"9f100016e7cfa07c8728f9c3cf9543ed3ed43cfe","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"d2676c1817f09be21008fbf1c2a25e3c9dc1793f","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/widgets/components/edit.ejs","hash":"9d976ca956c73128f72f39ca7641ceb5240b15a1","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/widgets/components/linklist.ejs","hash":"91f3a83ff54284200951637c0cfcd3e4e613942e","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/main/notebook/note_card.ejs","hash":"f9b87418fbecf9e7e3a5d074ee9e9a26f5cc1788","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/widgets/components/link.ejs","hash":"eee3e54cca066643d973f7bc1e2af6230121e634","modified":1723860608692},{"_id":"themes/stellar/layout/_partial/main/notebook/notebook_card.ejs","hash":"999b9c8895d84db707b1654c42326dfbb5fbe0fa","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/main/notebook/paginator.ejs","hash":"3c2f797fd3cf7e6e8c1b1dac168db26e92430b60","modified":1723860608690},{"_id":"themes/stellar/layout/_partial/main/notebook/note_tags.ejs","hash":"6103372e1d17396550da909aed9de1f26e483962","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/blog.ejs","hash":"0e3ff0a54e75acf562fd06d3d2c3ea03e0df7e81","modified":1723860608688},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/note.ejs","hash":"815962a80cbcfe242339e1461707455a776b11dd","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/page.ejs","hash":"66fca0ad5ae3ceaa8fa1f698713c4882fc0341c3","modified":1723860608689},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/wiki.ejs","hash":"c878619b0e8835e9a53a3b460ab5c707e9a3fb61","modified":1723860608689},{"_id":"themes/stellar/source/css/_components/tag-plugins/read/reel.styl","hash":"2f129dd75e98406bbcc0b94d5bca448f6531aaf3","modified":1723860608712},{"_id":"themes/stellar/source/css/_components/tag-plugins/read/paper.styl","hash":"e35b61ab74124a019f8a4c06f8611ddd671df35c","modified":1723860608712},{"_id":"source/images/shouye.jpeg","hash":"d7476674b556372df7ddfb8ad6cb638797033dc9","modified":1723905077327},{"_id":"public/search.json","hash":"de5328cac5c8d63de468e5783859e0963d876ed9","modified":1724059656790},{"_id":"public/404.html","hash":"a806233ba88fcd87fec7ef2a2e881f91a5073c18","modified":1724059656790},{"_id":"public/about/index.html","hash":"da6fd80b119edb6297f83f1c8cf22b3268710768","modified":1724059656790},{"_id":"public/comments/index.html","hash":"d557c0215fa53b1aa17f2d48ba0b35c3e1310ef9","modified":1724059656790},{"_id":"public/friends/index.html","hash":"c2d0515774261df6b56365c7e595a41daeddb106","modified":1724059656790},{"_id":"public/2024/08/15/线上问题排查方法汇总/index.html","hash":"c39ba7d3330eb4778ab65f6a2ca9c27b04803305","modified":1724058980050},{"_id":"public/2024/07/30/JAVA问题定位/index.html","hash":"f288e8b3ecca349b56c9e7c299e62a0a441f58d5","modified":1723973123230},{"_id":"public/archives/index.html","hash":"ee96098829bc8a3caf49ac4533d1f959d7df3501","modified":1724059656790},{"_id":"public/archives/2024/index.html","hash":"c8ded70f3c00bce4df265c50ae5c4576edcb2155","modified":1724059656790},{"_id":"public/archives/2024/07/index.html","hash":"7bd2ed8920816c5b0a96a994f460a3a4dc5ba6a4","modified":1724059656790},{"_id":"public/archives/2024/08/index.html","hash":"f34a0bd83d1b2054a4fb7eeba9d662af5c703acb","modified":1724059656790},{"_id":"public/categories/问题排查/index.html","hash":"2162c1d8c5af879b6c0e319f32be8758d697da05","modified":1724059656790},{"_id":"public/index.html","hash":"762a68fee64051eee3e1e365b5d50b85eee861d1","modified":1724059656790},{"_id":"public/tags/JAVA/index.html","hash":"4954d34981613df3be368b593bff5cab9e0ddf7e","modified":1724059656790},{"_id":"public/tags/Linux/index.html","hash":"9ee2b14dcaedaced2a50ca15b23af0168aceff3b","modified":1724059656790},{"_id":"public/tags/Java/index.html","hash":"05693079bd6f89e32fce2b857ed0c7332f487fdc","modified":1724059656790},{"_id":"public/tags/Golang/index.html","hash":"286eeacec84805e8e3b9d0fe7157a7abfee65871","modified":1724059656790},{"_id":"public/tags/commands/index.html","hash":"c05d8ab97abb88f5c2b89bf388d8f64967fc02f3","modified":1724059656790},{"_id":"public/categories/index.html","hash":"142db39e42b8777e70e196e51eada881f428f62b","modified":1724059656790},{"_id":"public/notebooks/index.html","hash":"7a6349d4a9a86747443748dff6a9585cef0d2be3","modified":1723973123230},{"_id":"public/tags/index.html","hash":"9efc7a2e37f63950417786a2bd9b1f94a2d1c552","modified":1724059656790},{"_id":"public/liuyanban.jpeg","hash":"0f8795cf75733493ffa43a6b3cded703ce4a2d48","modified":1723973123230},{"_id":"public/images/liuyanban.jpeg","hash":"0f8795cf75733493ffa43a6b3cded703ce4a2d48","modified":1723973123230},{"_id":"public/images/load30.png","hash":"c689d35af16fe9f040e40598db2065b0cb0189e3","modified":1723973123230},{"_id":"public/images/logo.jpeg","hash":"1e0f89eb6c2df039baeb70230638cf584a1cb1d3","modified":1723973123230},{"_id":"public/images/load10.png","hash":"4076ee1111fa2062139614ef45057ba6886d74e4","modified":1723973123230},{"_id":"public/images/load60.png","hash":"73051eb2c54f2bbbf54c6907c0d766829da12109","modified":1723973123230},{"_id":"public/images/music.jpeg","hash":"d2f291d9993f84032375bdce650d2ad5abb954e7","modified":1723973123230},{"_id":"public/images/perftop.png","hash":"1489c907cc0278a6803c204792803bff98fd66ce","modified":1723973123230},{"_id":"public/images/server.jpg","hash":"02e933b77901f8df62d9576c5a0a0211790f8167","modified":1723973123230},{"_id":"public/images/dark.jpeg","hash":"dc6c5cd179fb4795afbcb6e0fbc278e561a2bef1","modified":1723973123230},{"_id":"public/images/stress-cpu.png","hash":"91839b4f8c115981fd31ce2dc7a957143e5d6f08","modified":1723973123230},{"_id":"public/images/top.png","hash":"a16eb91f4a11db4cefa61e4559588aac3626793b","modified":1723973123230},{"_id":"public/images/vmstat.png","hash":"c9cf2b97a3fee6dea79ac46252999b5bf28a7510","modified":1723973123230},{"_id":"public/images/git.png","hash":"468fcceae3d9260bd64fb531106d3cfd28d9d321","modified":1723973123230},{"_id":"public/images/gc.png","hash":"ba28184e39dac6e2f18da06e481337441226c8c6","modified":1723973123230},{"_id":"public/images/java.jpg","hash":"f8b81e75fd682ce8efdb21144be635ccd1ed0cdd","modified":1723973123230},{"_id":"public/images/javafire.png","hash":"118c0a92a404c68bb98c7da781617ac3632c2899","modified":1723973123230},{"_id":"public/images/top-process.png","hash":"582d184a7c7af782bd7040ead0d5d8c8abee4030","modified":1723973123230},{"_id":"public/css/darkmode.css","hash":"acaad72e2c3eb183b54ae9ba23981141fc025140","modified":1723973123230},{"_id":"public/js/darkmode.js","hash":"f475db6eb867d4790843eed74b75dd76d932f42a","modified":1723973123230},{"_id":"public/js/main.js","hash":"41ddd41a9f1896ad548a8eaa8610da2f823009ba","modified":1723973123230},{"_id":"public/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1723973123230},{"_id":"public/js/search/algolia-search.js","hash":"2b4cc743d66fbdbe37f2311963d54d957637ca3e","modified":1723973123230},{"_id":"public/js/search/local-search.js","hash":"cf710d711fcbc21122cdc01edd43d9b4087f1b9d","modified":1723973123230},{"_id":"public/js/services/fcircle.js","hash":"add550bfb204a2057661d4d6630d78ebf485754d","modified":1723973123230},{"_id":"public/js/services/friends.js","hash":"581a2baa085df422b752cbec098ca56aac691790","modified":1723973123230},{"_id":"public/js/services/ghinfo.js","hash":"94b86ce42dd765e9a4c1befa72ee9648d7ec6f88","modified":1723973123230},{"_id":"public/js/services/mdrender.js","hash":"947f476e6dd8ca6a75f87f6ac6f2fbb2b0861e82","modified":1723973123230},{"_id":"public/js/services/memos.js","hash":"2d430c7ae4d9f3a44653eda0214d18fb60bcfed1","modified":1723973123230},{"_id":"public/js/services/siteinfo.js","hash":"74da788f29862604cd53f6b82b036ff56c715d21","modified":1723973123230},{"_id":"public/js/services/sites.js","hash":"5626b70d13360933c581983dcda422e4fccdc810","modified":1723973123230},{"_id":"public/js/services/timeline.js","hash":"41cde82427726c3366b64b1f54f1aed9bc20fcf1","modified":1723973123230},{"_id":"public/js/services/weibo.js","hash":"437e631539f3a50cf8b46ff17008404609c1c481","modified":1723973123230},{"_id":"public/css/main.css","hash":"13281d2f679605225bb52299b7b412b1a9ed1d7f","modified":1723973123230},{"_id":"public/images/javaperftop.png","hash":"cc8aed116972b9e62e9b6f961e17cd14dca24f5d","modified":1723973123230},{"_id":"public/images/shouye.jpeg","hash":"d7476674b556372df7ddfb8ad6cb638797033dc9","modified":1723973123230},{"_id":"source/images/io60c.png","hash":"6630c2853124fe1c89e30e8e96397124ab8ef1b9","modified":1724053201299},{"_id":"source/_posts/image.png","hash":"2d94494a628427c738e8a09484740c8b4fce1bbb","modified":1724056788333},{"_id":"source/images/ioload30.png","hash":"9bc8e346914d1e23f889dd2583e4359859aa63d9","modified":1724055156306},{"_id":"source/images/ioload60.png","hash":"a1377e41182d0d8cbcad6083a24416a17ea23978","modified":1724055228042},{"_id":"source/images/ioload10.png","hash":"d6e08bea439fcc0040db5a70a9614c943b9f892b","modified":1724055199926},{"_id":"source/images/psauxf.png","hash":"2d94494a628427c738e8a09484740c8b4fce1bbb","modified":1724056792844},{"_id":"source/images/loadhigh.png","hash":"b1331cf964a90c34de2517eef57a04da739ead6d","modified":1724058952995},{"_id":"public/images/io60c.png","hash":"6630c2853124fe1c89e30e8e96397124ab8ef1b9","modified":1724058980050},{"_id":"public/images/ioload30.png","hash":"9bc8e346914d1e23f889dd2583e4359859aa63d9","modified":1724058980050},{"_id":"public/images/ioload60.png","hash":"a1377e41182d0d8cbcad6083a24416a17ea23978","modified":1724058980050},{"_id":"public/images/psauxf.png","hash":"2d94494a628427c738e8a09484740c8b4fce1bbb","modified":1724058980050},{"_id":"public/images/ioload10.png","hash":"d6e08bea439fcc0040db5a70a9614c943b9f892b","modified":1724058980050},{"_id":"public/images/loadhigh.png","hash":"b1331cf964a90c34de2517eef57a04da739ead6d","modified":1724058980050},{"_id":"public/undefined/线上问题排查方法汇总/index.html","hash":"61ef1431cb18dc83f6a8f5e7acff1561e4650744","modified":1724059627866},{"_id":"public/undefined/JAVA问题定位/index.html","hash":"9066779d21e224f65a78717013393b6ccf689c91","modified":1724059627866},{"_id":"public/p/线上问题排查方法汇总/index.html","hash":"33bae7b647fd2219f454284f018973f765b00943","modified":1724059656790},{"_id":"public/p/JAVA问题定位/index.html","hash":"bb32788ce6be1f7244c9a1f43a5cb7cb99cec8cb","modified":1724059656790}],"Category":[{"name":"问题排查","_id":"clzzd33n20004x4ic8hf5bwi8"}],"Data":[],"Page":[{"title":"个人介绍","date":"2024-08-16T04:00:00.000Z","banner":"/images/shouye.jpeg","_content":"\n## 简介\n- **职业**:     运维开发工程师\n- **出生时间**:  98年\n- **性别**:     男\n- **联系方式**:  446302864@qq.com/baixiaozhou96@gmail.com\n\n## 工作履历\n- 2020.7-2023.6  杭州齐治科技 软件开发工程师\n- 2023.7-2024.1  腾讯云 ES SRE\n- 2024.3-        金山云 SRE\n\n\n## 个人项目\n- [SysStress](https://github.com/baixiaozhou/SysStress) 自己写的一个性能压测工具，还在不断完善中\n","source":"about/index.md","raw":"---\ntitle: 个人介绍\ndate: 2024-08-16 12:00:00\nbanner: /images/shouye.jpeg\n---\n\n## 简介\n- **职业**:     运维开发工程师\n- **出生时间**:  98年\n- **性别**:     男\n- **联系方式**:  446302864@qq.com/baixiaozhou96@gmail.com\n\n## 工作履历\n- 2020.7-2023.6  杭州齐治科技 软件开发工程师\n- 2023.7-2024.1  腾讯云 ES SRE\n- 2024.3-        金山云 SRE\n\n\n## 个人项目\n- [SysStress](https://github.com/baixiaozhou/SysStress) 自己写的一个性能压测工具，还在不断完善中\n","updated":"2024-08-17T14:33:25.345Z","path":"about/index.html","comments":1,"layout":"page","_id":"clzzd33my0000x4icg0w6fwgv","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><strong>职业</strong>:     运维开发工程师</li>\n<li><strong>出生时间</strong>:  98年</li>\n<li><strong>性别</strong>:     男</li>\n<li><strong>联系方式</strong>:  <a href=\"mailto:&#x34;&#x34;&#x36;&#x33;&#48;&#50;&#x38;&#54;&#x34;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;\">&#x34;&#x34;&#x36;&#x33;&#48;&#50;&#x38;&#54;&#x34;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a>&#x2F;<a href=\"mailto:&#98;&#97;&#105;&#120;&#105;&#x61;&#111;&#122;&#104;&#111;&#117;&#57;&#x36;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">&#98;&#97;&#105;&#120;&#105;&#x61;&#111;&#122;&#104;&#111;&#117;&#57;&#x36;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n<h2 id=\"工作履历\"><a href=\"#工作履历\" class=\"headerlink\" title=\"工作履历\"></a>工作履历</h2><ul>\n<li>2020.7-2023.6  杭州齐治科技 软件开发工程师</li>\n<li>2023.7-2024.1  腾讯云 ES SRE</li>\n<li>2024.3-        金山云 SRE</li>\n</ul>\n<h2 id=\"个人项目\"><a href=\"#个人项目\" class=\"headerlink\" title=\"个人项目\"></a>个人项目</h2><ul>\n<li><a href=\"https://github.com/baixiaozhou/SysStress\">SysStress</a> 自己写的一个性能压测工具，还在不断完善中</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><strong>职业</strong>:     运维开发工程师</li>\n<li><strong>出生时间</strong>:  98年</li>\n<li><strong>性别</strong>:     男</li>\n<li><strong>联系方式</strong>:  <a href=\"mailto:&#x34;&#x34;&#x36;&#x33;&#48;&#50;&#x38;&#54;&#x34;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;\">&#x34;&#x34;&#x36;&#x33;&#48;&#50;&#x38;&#54;&#x34;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a>&#x2F;<a href=\"mailto:&#98;&#97;&#105;&#120;&#105;&#x61;&#111;&#122;&#104;&#111;&#117;&#57;&#x36;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">&#98;&#97;&#105;&#120;&#105;&#x61;&#111;&#122;&#104;&#111;&#117;&#57;&#x36;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n<h2 id=\"工作履历\"><a href=\"#工作履历\" class=\"headerlink\" title=\"工作履历\"></a>工作履历</h2><ul>\n<li>2020.7-2023.6  杭州齐治科技 软件开发工程师</li>\n<li>2023.7-2024.1  腾讯云 ES SRE</li>\n<li>2024.3-        金山云 SRE</li>\n</ul>\n<h2 id=\"个人项目\"><a href=\"#个人项目\" class=\"headerlink\" title=\"个人项目\"></a>个人项目</h2><ul>\n<li><a href=\"https://github.com/baixiaozhou/SysStress\">SysStress</a> 自己写的一个性能压测工具，还在不断完善中</li>\n</ul>\n"},{"date":"2024-08-18T07:00:00.000Z","_content":"\n{% quot 留言板%}\n\n欢迎大家在这里进行留言，进行问题探讨\n","source":"comments/index.md","raw":"---\ndate: 2024-08-18 15:00:00\n---\n\n{% quot 留言板%}\n\n欢迎大家在这里进行留言，进行问题探讨\n","updated":"2024-08-18T07:05:49.280Z","path":"comments/index.html","title":"","comments":1,"layout":"page","_id":"clzzd33n10002x4ice0pw74nv","content":"<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">留言板</span><span class=\"empty\"></span></p></div>\n\n<p>欢迎大家在这里进行留言，进行问题探讨</p>\n","excerpt":"","more":"<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">留言板</span><span class=\"empty\"></span></p></div>\n\n<p>欢迎大家在这里进行留言，进行问题探讨</p>\n"},{"title":"个人介绍","date":"2024-08-16T04:00:00.000Z","banner":"../images/persion.png","_content":"\n# Test\n","source":"friends/index.md","raw":"---\ntitle: 个人介绍\ndate: 2024-08-16 12:00:00\nbanner: ../images/persion.png\n---\n\n# Test\n","updated":"2024-08-17T14:27:02.654Z","path":"friends/index.html","comments":1,"layout":"page","_id":"clzzd33n20006x4icham51i0p","content":"<h1 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h1>","excerpt":"","more":"<h1 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h1>"}],"Post":[{"title":"JAVA问题定位","author":"baixiaozhou","description":"java常见问题和排查的基本方法和工具介绍","date":"2024-07-30T07:32:13.000Z","cover":"/images/java.jpg","banner":"/images/java.jpg","_content":"\n<!-- more -->\n\n\n# 一、JAVA 相关命令\n\n## 1.jps\njps - Lists the instrumented Java Virtual Machines (JVMs) on the target system. This command is experimental and unsupported.\n\n相关参数\n```\nOPTIONS\n       The jps command supports a number of options that modify the output of the command. These options are subject to change or removal in the future.\n       -q\n              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.\n       -m\n              Displays the arguments passed to the main method. The output may be null for embedded JVMs.\n       -l\n              Displays the full package name for the application's main class or the full path name to the application's JAR file.\n       -v\n              Displays the arguments passed to the JVM.\n       -V\n              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.\n       -Joption\n              Passes option to the JVM, where option is one of the options described on the reference page for the Java application launcher. For example, -J-Xms48m sets the\n              startup memory to 48 MB. See java(1).\n```\n\n## 2.jinfo\njinfo（Java Virtual Machine Configuration Information）是JDK提供的一个可以实时查看Java虚拟机各种配置参数和系统属性的命令行工具。使用jps命令的-v参数可以查看Java虚拟机启动时显式指定的配置参数，如果想查看没有显式指定的配置参数就可以使用jinfo命令进行查看。另外，jinfo命令还可以查询Java虚拟机进程的System.getProperties()的内容。\n\n以tomcat进程为例\n```\nAttaching to process ID 2045, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.242-b08\nJava System Properties:\n\njava.vendor = Huawei Technologies Co., Ltd\nsun.java.launcher = SUN_STANDARD\ncatalina.base = /usr/share/tomcat\nsun.management.compiler = HotSpot 64-Bit Tiered Compilers\nsun.nio.ch.bugLevel = \ncatalina.useNaming = true\njnidispatch.path = /var/cache/tomcat/temp/jna--903012287/jna4240128671455089550.tmp\nos.name = Linux\nsun.boot.class.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/classes\njava.vm.specification.vendor = Oracle Corporation\njava.runtime.version = 1.8.0_242-b08\njna.loaded = true\nuser.name = xxx\ntomcat.util.scan.StandardJarScanFilter.jarsToScan = taglibs-standard-impl*.jar\nshared.loader = \ntomcat.util.buf.StringCache.byte.enabled = true\nuser.language = en\njava.naming.factory.initial = org.apache.naming.java.javaURLContextFactory\nsun.boot.library.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64\njava.version = 1.8.0_242\njava.util.logging.manager = org.apache.juli.ClassLoaderLogManager\nuser.timezone = Asia/Shanghai\nsun.arch.data.model = 64\njava.util.concurrent.ForkJoinPool.common.threadFactory = org.apache.catalina.startup.SafeForkJoinWorkerThreadFactory\njava.endorsed.dirs = \nsun.cpu.isalist = \nsun.jnu.encoding = UTF-8\nfile.encoding.pkg = sun.io\npackage.access = sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.\nfile.separator = /\njava.specification.name = Java Platform API Specification\njava.class.version = 52.0\nuser.country = US\njava.home = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre\njava.vm.info = mixed mode\nos.version = 4.19.90-24.4.v2101.ky10.x86_64\nsun.font.fontmanager = sun.awt.X11FontManager\npath.separator = :\njava.vm.version = 25.242-b08\njboss.i18n.generate-proxies = true\njava.awt.printerjob = sun.print.PSPrinterJob\nsun.io.unicode.encoding = UnicodeLittle\nawt.toolkit = sun.awt.X11.XToolkit\npackage.definition = sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.\njava.naming.factory.url.pkgs = org.apache.naming\nmail.mime.splitlongparameters = false\njava.security.egd = file:/dev/./urandom\nuser.home = /home/shterm\njava.specification.vendor = Oracle Corporation\ntomcat.util.scan.StandardJarScanFilter.jarsToSkip = activ*.jar,amqp-client.jar,annotations-api.jar,ant-junit*.jar,ant-launcher.jar,ant.jar,antlr.jar,aopalliance.jar,asm-*.jar,aspectj*.jar,bcp*.jar,bootstrap.jar,catalina-ant.jar,catalina-ha.jar,catalina-jmx-remote.jar,catalina-storeconfig.jar,catalina-tribes.jar,catalina-ws.jar,catalina.jar,cglib-*.jar,classmate.jar,cobertura-*.jar,commons-*.jar,compress-lzf.jar,curator-*.jar,db2-jdbc.jar,dom4j-*.jar,easymock-*.jar,ecj-*.jar,el-api.jar,elasticsearch.jar,geronimo-spec-jaxrpc*.jar,groovy-all.jar,guava.jar,h2*.jar,hamcrest-*.jar,hibernate*.jar,hppc.jar,http*.jar,icu4j-*.jar,itext*.jar,jackson-*.jar,jandex.jar,jasper-el.jar,jasper.jar,jasperreports*.jar,jaspic-api.jar,javamail.jar,javassist.jar,jaxb-*.jar,jaxen*.jar,jboss*.jar,jc*.jar,jdom-*.jar,jedis.jar,jetty-*.jar,jfreechart.jar,jgit.jar,jline.jar,jmx-tools.jar,jmx.jar,jna.jar,joda-time.jar,jr-*.jar,jsch.jar,json*.jar,jsoup.jar,jsp-api.jar,jsr166e.jar,jstl.jar,jta*.jar,junit-*.jar,junit.jar,liquibase-*.jar,log4j*.jar,lucene*.jar,mail*.jar,mariadb-jdbc.jar,mssql-jdbc.jar,mybatis.jar,netty.jar,nmap4j.jar,objenesis*.jar,olap4j.jar,opc*.jar,oracle-jdbc.jar,oraclepki.jar,oro-*.jar,poi*.jar,postgresql-jdbc.jar,quartz.jar,servlet-api-*.jar,servlet-api.jar,slf4j*.jar,snakeyaml.jar,snmp4j.jar,spring*.jar,sshd-core.jar,taglibs-standard-spec-*.jar,tagsoup-*.jar,t-digest.jar,tomcat-api.jar,tomcat-coyote.jar,tomcat-dbcp.jar,tomcat-i18n-*.jar,tomcat-jdbc.jar,tomcat-jni.jar,tomcat-juli-adapters.jar,tomcat-juli.jar,tomcat-util-scan.jar,tomcat-util.jar,tomcat-websocket.jar,tools.jar,validation-api.jar,velocypack.jar,websocket-api.jar,wl*.jar,wsdl4j*.jar,xercesImpl.jar,xml-apis.jar,xmlbeans.jar,xmlParserAPIs-*.jar,xmlParserAPIs.jar,xom-*.jar,xz.jar,zip4j.jar,zookeeper.jar\njava.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\njava.vendor.url = http://jdk.rnd.huawei.com/\njava.vm.vendor = Huawei Technologies Co., Ltd\ncommon.loader = \"${catalina.base}/lib\",\"${catalina.base}/lib/*.jar\",\"${catalina.home}/lib\",\"${catalina.home}/lib/*.jar\"\njava.runtime.name = OpenJDK Runtime Environment\nsun.java.command = org.apache.catalina.startup.Bootstrap start\njava.class.path = /usr/share/tomcat/bin/bootstrap.jar:/usr/share/tomcat/bin/tomcat-juli.jar:/usr/lib/java/commons-daemon.jar\njava.vm.specification.name = Java Virtual Machine Specification\njava.vm.specification.version = 1.8\ncatalina.home = /usr/share/tomcat\nsun.cpu.endian = little\nsun.os.patch.level = unknown\njava.awt.headless = true\njava.io.tmpdir = /var/cache/tomcat/temp\njava.vendor.url.bug = http://jdk.rnd.huawei.com/\nserver.loader = \njava.rmi.server.hostname = 127.0.0.1\njna.platform.library.path = /usr/lib64:/lib64:/usr/lib:/lib:/usr/lib64/tracker-miners-2.0:/usr/lib64/tracker-2.0:/usr/lib64/dyninst:/usr/libexec/sudo:/usr/lib64/sssd:/usr/pgsql-9.6/lib:/usr/lib64/perl5/CORE:/usr/lib64/opencryptoki:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64/jli:/usr/lib64/bind9-export\nos.arch = amd64\njava.awt.graphicsenv = sun.awt.X11GraphicsEnvironment\njava.ext.dirs = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/ext:/usr/java/packages/lib/ext\nuser.dir = /usr/share/tomcat\nline.separator = \n\njava.vm.name = OpenJDK 64-Bit Server VM\nlog4j.configurationFile = /etc/tomcat/log4j2.xml\nfile.encoding = UTF-8\ncom.sun.jndi.ldap.object.disableEndpointIdentification = \njava.specification.version = 1.8\n\nVM Flags:\nNon-default VM flags: -XX:CICompilerCount=4 -XX:GCLogFileSize=20971520 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=243269632 -XX:MaxHeapSize=1610612736 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=80740352 -XX:NumberOfGCLogFiles=15 -XX:OldSize=162529280 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRotation -XX:+UseParallelGC \nCommand line:  -Xmx1536m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/tomcat -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=20m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/var/log/tomcat/tomcat-gc-%t.log -Dcom.sun.jndi.ldap.object.disableEndpointIdentification -Dcatalina.base=/usr/share/tomcat -Dcatalina.home=/usr/share/tomcat -Djava.endorsed.dirs= -Djava.io.tmpdir=/var/cache/tomcat/temp -Dlog4j.configurationFile=/etc/tomcat/log4j2.xml -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n```\n\n## 3.jstat\n命令参数说明：\n- generalOptions：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：\n- -help：显示帮助信息。\n- -options：显示outputOptions参数的列表。\n- outputOptions：输出选项，指定显示某一种Java虚拟机信息。\n- -t：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。\n- -h n：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。\n- vmid：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。\n- interval：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每隔这段时间显示一次统计信息。\n- count：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。\n输出选项\n如果不指定通用选项（generalOptions），则可以指定输出选项（outputOptions）。输出选项决定jstat命令显示的内容和格式，具体如下：\n- -class：显示类加载、卸载数量、总空间和装载耗时的统计信息。\n- -compiler：显示即时编译的方法、耗时等信息。\n- -gc：显示堆各个区域内存使用和垃圾回收的统计信息。\n- -gccapacity：显示堆各个区域的容量及其对应的空间的统计信息。\n- -gcutil：显示有关垃圾收集统计信息的摘要。\n- -gccause：显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因。\n- -gcnew：显示新生代的垃圾回收统计信息。\n- -gcnewcapacity：显示新生代的大小及其对应的空间的统计信息。\n- -gcold: 显示老年代和元空间的垃圾回收统计信息。\n- -gcoldcapacity：显示老年代的大小统计信息。\n- -gcmetacapacity：显示元空间的大小的统计信息。\n- -printcompilation：显示即时编译方法的统计信息。\n\n# 二、线程堆栈\n## 1.输出\nJava虚拟机提供了线程转储(Thread dump)的后门，通过这个后门，可以将线程堆栈打印出来。这个后门就是通过向Java进程发送一个QUIT信号，Java虚拟机收到该信号之后，将系统当前的JAVA线程调用堆栈打印出来。\n\n打印方法：\n- jstack -l pid > xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式\n- kill -3\n***同时请确保Java命令行中没有DISABLE_JAVADUMP运行选项***\n## 2.线程分析\n通过输出堆栈进行分析 `jstack -l $(jps | grep xxx | awk '{print $1}')` > /tmp/xxx.jstack\n```Lua\n\"SYS_STATUS_CHECKER\" #14 daemon prio=5 os_prio=0 tid=0x00007f5e047bf000 nid=0xe15 waiting on condition [0x00007f5dd43d1000]\n    java.lang.Thread.State: TIMED_WAITING (sleeping)\n        at java.lang.Thread.sleep(Native Method)\nru        at com.xxx.xxx.SystemStatusChecker.run(SystemStatusChecker.java:xx)\n        at java.lang.Thread.run(Thread.java:748)        \n    Locked ownable synchronizers:\n        - None\n                \n\"RMI Reaper\" #39 prio=5 os_prio=0 tid=0x00007f5e04e4c800 nid=0xf0b in Object.wait() [0x00007f5dae2c4000]\n    java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)\n        - locked <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)\n        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:351)\n        at java.lang.Thread.run(Thread.java:748)\n    Locked ownable synchronizers:\n        - None\n        \n\"main\" #1 prio=5 os_prio=0 tid=0x00007f5e0400a000 nid=0xdcb runnable [0x00007f5e0b393000]\n    java.lang.Thread.State: RUNNABLE\n        at java.net.PlainSocketImpl.socketAccept(Native Method)\n        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:545)\n        at java.net.ServerSocket.accept(ServerSocket.java:513)\n        at com.xxx.common.xxx.await(CommonMain.java:244)\n        at com.xxx.common.xxx.startup(CommonMain.java:207)\n        at com.xxx.common.xxx.main(CommonMain.java:147)\n    Locked ownable synchronizers:\n        - None\n```\n在RMI线程中可以看到 \" - locked <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\" 表示该线程已经使用了ID为\"0x00000000c0c88d2\"的锁，锁的ID由系统自动产生\n```\n\"main\"  prio=5     os_prio=0          tid=0x00007f5e0400a000 nid=0xdcb      runnable [0x00007f5e0b393000]\n|       |          |                  |                      |              |         |\n线程名称 线程优先级   操作系统级别的优先级   线程id                 对应的本地线程ID  状态      线程占用内存地址\n```\n\n其中\"线程对应的本地线程id号\"所指的\"本地线程\"是指该Java线程所对应的虚拟机中的本地线程。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是 依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。\n\nJava代码 中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix/Linux下，我们可以通 如下方式把Java虚拟机的本地线程打印出来：\n- 使用ps -ef | grep java 获得Java进程ID。\n- 使用pstack <java pid>获得Java虚拟机的本地线程的堆栈\n其中本地线程各项含义如下：\n```\nThread 56 (Thread 0x7f5e0b394700 (LWP 3531))\n|                 |                 |\n|                 |                 +----本地线程id(另一种表示,LWP-light weight process)\n|                 +-------------------本地线程id\n+------------------------------线程名称\n```\n而通过jstack输出的main本地线程ID为0xdcb，其10进制正好为3531。\n\n\"runnable\"表示当前线程处于运行状态。这个runnable状态是从虚拟机的角度来看的, 表示这个线程正在运行\n<p><strong>⚠️ NOTE:</strong> 但是处于Runnable状态的线程不一定真的消耗CPU. 处于Runnable的线程只能说明该线程没有阻塞在java的wait或者sleep方法上，同时也没等待在锁上面。但是如果该线程调用了本地方法，而本地方法处于等待状态，这个时候虚拟机是不知道本地代码中发生 了什么（但操作系统是知道的，pstack就是操作提供的一个命令，它知道当前线程正在执行的本地代码上下文），此时尽管当前线程实际上也是阻塞的状态，但实际上显示出来的还是runnable状态， 这种情况下是不消耗CPU的</p>\n\n```\n1. 处于waittig和blocked状态的线程都不会消耗CPU \n2. 线程频繁地挂起和唤醒需要消耗CPU, 而且代价颇大\n```\n- TIMED_WAITING(on object monitor) 表示当前线程被挂起一段时间,说明该线程正在 执行obj.wait(int time)方法.\n- TIMED_WAITING(sleeping) 表示当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法. \n- TIMED_WAITING(parking) 当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法.\n- WAINTING(on object monitor) 当前线程被挂起，即正在执行obj.wait()方法(无参数的wait()方法).\n```\n处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.\n• 如果是纯Java运算代码，则消耗CPU.\n• 如果是网络IO,很少消耗CPU.\n• 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)， 如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消 耗CPU。\n```\n# 三、相关的排查方法\n## 1.CPU\n生产环境中往往会出现CPU飙高的情况，对于JAVA应用而言，此类问题相对较好确定问题方向。\n### 1.1 使用jstack确定CPU占用高的线程\\\n通过`top`指令，可以看到进程占用的一些基础资源信息，然后“P”键可以按照CPU使用率进行排序，“M”键可以按照内存占用情况进行排序\n\n找到CPU占用高的进程pid，然后将jstack信息定向到一个文件中去，通过`top -Hp pid`查看具体的情况。\n\n通过 `printf '%x\\n' pid`将pid转换为16进制，然后在jstack文件中根据对应的数字进行查找，然后针对性的进行分析\n### 1.2 频繁GC\n有时候我们可以先确定下gc是不是太频繁，使用`jstat -gc pid 1000`命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，`S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU`分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。`YGC/YGT、FGC/FGCT、GCT`则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。\n![alt text](../images/gc.png)\n### 1.3 频繁上下文切换\n针对频繁上下文问题，我们可以使用vmstat命令来进行查看\n![alt text](../images/vmstat.png)\ncs(context switch)一列则代表了上下文切换的次数。\n\n如果我们希望对特定的pid进行监控那么可以使用 `pidstat -w pid`命令，cswch和nvcswch表示自愿及非自愿切换。\n\n## 2.内存\n对于JAVA应用，涉及到的内存问题主要包括OOM、GC问题和堆外内存。\n### 2.1 OOM\nJVM中的内存不足，OOM大致可以分为以下几种情况\n- `Exception in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread` 这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改`/etc/security/limits.confnofile`和`nproc`来增大os对线程的限制\n- `Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space ` 这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。\n- `Caused by: java.lang.OutOfMemoryError: Meta space` 这个意思是元数据区的内存占用已经达到`XX:MaxMetaspaceSize`设置的最大值，排查思路和上面的一致，参数方面可以通过`XX:MaxPermSize`来进行调整\n- `Exception in thread \"main\" java.lang.StackOverflowError` 表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。\n### 2.2 GC问题\ngc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常等。\n\n线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的`unable to create new native thread`。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过`pstreee -p pid |wc -l`\n### 2.3 堆外内存\nJVM 的堆外内存主要包括：\n- JVM 自身运行占用的空间；\n- 线程栈分配占用的系统内存；\n- DirectByteBuffer 占用的内存；\n- JNI 里分配的内存；\n- Java 8 开始的元数据空间；\n- NIO 缓存\n- Unsafe 调用分配的内存；\n- codecache\n\n冰山对象：冰山对象是指在 JVM 堆里占用的内存很小，但其实引用了一块很大的本地内存。DirectByteBuffer 和 线程都属于这类对象。\n#### 2.3.1NMT分析堆外内存\nNMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。\n\nNMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。\n\n#### 2.3.2 开启 NMT\n启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。\n启动命令： `-XX:NativeMemoryTracking=[off | summary | detail]`。\n- off：NMT 默认是关闭的；\n- summary：只收集子系统的内存使用的总计数据；\n- detail：收集每个调用点的内存使用数据。\n\n#### 2.3.3 jcmd 访问 NMT 数据\n命令：\n`jcmd <pid> VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]`\n\n","source":"_posts/JAVA问题定位.md","raw":"---\ntitle: JAVA问题定位\nauthor: baixiaozhou\ncategories:\n  - 问题排查\ntags:\n  - JAVA\n  - Linux\ndescription: java常见问题和排查的基本方法和工具介绍\ndate: 2024-07-30 15:32:13\ncover: /images/java.jpg\nbanner: /images/java.jpg\n---\n\n<!-- more -->\n\n\n# 一、JAVA 相关命令\n\n## 1.jps\njps - Lists the instrumented Java Virtual Machines (JVMs) on the target system. This command is experimental and unsupported.\n\n相关参数\n```\nOPTIONS\n       The jps command supports a number of options that modify the output of the command. These options are subject to change or removal in the future.\n       -q\n              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.\n       -m\n              Displays the arguments passed to the main method. The output may be null for embedded JVMs.\n       -l\n              Displays the full package name for the application's main class or the full path name to the application's JAR file.\n       -v\n              Displays the arguments passed to the JVM.\n       -V\n              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.\n       -Joption\n              Passes option to the JVM, where option is one of the options described on the reference page for the Java application launcher. For example, -J-Xms48m sets the\n              startup memory to 48 MB. See java(1).\n```\n\n## 2.jinfo\njinfo（Java Virtual Machine Configuration Information）是JDK提供的一个可以实时查看Java虚拟机各种配置参数和系统属性的命令行工具。使用jps命令的-v参数可以查看Java虚拟机启动时显式指定的配置参数，如果想查看没有显式指定的配置参数就可以使用jinfo命令进行查看。另外，jinfo命令还可以查询Java虚拟机进程的System.getProperties()的内容。\n\n以tomcat进程为例\n```\nAttaching to process ID 2045, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.242-b08\nJava System Properties:\n\njava.vendor = Huawei Technologies Co., Ltd\nsun.java.launcher = SUN_STANDARD\ncatalina.base = /usr/share/tomcat\nsun.management.compiler = HotSpot 64-Bit Tiered Compilers\nsun.nio.ch.bugLevel = \ncatalina.useNaming = true\njnidispatch.path = /var/cache/tomcat/temp/jna--903012287/jna4240128671455089550.tmp\nos.name = Linux\nsun.boot.class.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/classes\njava.vm.specification.vendor = Oracle Corporation\njava.runtime.version = 1.8.0_242-b08\njna.loaded = true\nuser.name = xxx\ntomcat.util.scan.StandardJarScanFilter.jarsToScan = taglibs-standard-impl*.jar\nshared.loader = \ntomcat.util.buf.StringCache.byte.enabled = true\nuser.language = en\njava.naming.factory.initial = org.apache.naming.java.javaURLContextFactory\nsun.boot.library.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64\njava.version = 1.8.0_242\njava.util.logging.manager = org.apache.juli.ClassLoaderLogManager\nuser.timezone = Asia/Shanghai\nsun.arch.data.model = 64\njava.util.concurrent.ForkJoinPool.common.threadFactory = org.apache.catalina.startup.SafeForkJoinWorkerThreadFactory\njava.endorsed.dirs = \nsun.cpu.isalist = \nsun.jnu.encoding = UTF-8\nfile.encoding.pkg = sun.io\npackage.access = sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.\nfile.separator = /\njava.specification.name = Java Platform API Specification\njava.class.version = 52.0\nuser.country = US\njava.home = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre\njava.vm.info = mixed mode\nos.version = 4.19.90-24.4.v2101.ky10.x86_64\nsun.font.fontmanager = sun.awt.X11FontManager\npath.separator = :\njava.vm.version = 25.242-b08\njboss.i18n.generate-proxies = true\njava.awt.printerjob = sun.print.PSPrinterJob\nsun.io.unicode.encoding = UnicodeLittle\nawt.toolkit = sun.awt.X11.XToolkit\npackage.definition = sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.\njava.naming.factory.url.pkgs = org.apache.naming\nmail.mime.splitlongparameters = false\njava.security.egd = file:/dev/./urandom\nuser.home = /home/shterm\njava.specification.vendor = Oracle Corporation\ntomcat.util.scan.StandardJarScanFilter.jarsToSkip = activ*.jar,amqp-client.jar,annotations-api.jar,ant-junit*.jar,ant-launcher.jar,ant.jar,antlr.jar,aopalliance.jar,asm-*.jar,aspectj*.jar,bcp*.jar,bootstrap.jar,catalina-ant.jar,catalina-ha.jar,catalina-jmx-remote.jar,catalina-storeconfig.jar,catalina-tribes.jar,catalina-ws.jar,catalina.jar,cglib-*.jar,classmate.jar,cobertura-*.jar,commons-*.jar,compress-lzf.jar,curator-*.jar,db2-jdbc.jar,dom4j-*.jar,easymock-*.jar,ecj-*.jar,el-api.jar,elasticsearch.jar,geronimo-spec-jaxrpc*.jar,groovy-all.jar,guava.jar,h2*.jar,hamcrest-*.jar,hibernate*.jar,hppc.jar,http*.jar,icu4j-*.jar,itext*.jar,jackson-*.jar,jandex.jar,jasper-el.jar,jasper.jar,jasperreports*.jar,jaspic-api.jar,javamail.jar,javassist.jar,jaxb-*.jar,jaxen*.jar,jboss*.jar,jc*.jar,jdom-*.jar,jedis.jar,jetty-*.jar,jfreechart.jar,jgit.jar,jline.jar,jmx-tools.jar,jmx.jar,jna.jar,joda-time.jar,jr-*.jar,jsch.jar,json*.jar,jsoup.jar,jsp-api.jar,jsr166e.jar,jstl.jar,jta*.jar,junit-*.jar,junit.jar,liquibase-*.jar,log4j*.jar,lucene*.jar,mail*.jar,mariadb-jdbc.jar,mssql-jdbc.jar,mybatis.jar,netty.jar,nmap4j.jar,objenesis*.jar,olap4j.jar,opc*.jar,oracle-jdbc.jar,oraclepki.jar,oro-*.jar,poi*.jar,postgresql-jdbc.jar,quartz.jar,servlet-api-*.jar,servlet-api.jar,slf4j*.jar,snakeyaml.jar,snmp4j.jar,spring*.jar,sshd-core.jar,taglibs-standard-spec-*.jar,tagsoup-*.jar,t-digest.jar,tomcat-api.jar,tomcat-coyote.jar,tomcat-dbcp.jar,tomcat-i18n-*.jar,tomcat-jdbc.jar,tomcat-jni.jar,tomcat-juli-adapters.jar,tomcat-juli.jar,tomcat-util-scan.jar,tomcat-util.jar,tomcat-websocket.jar,tools.jar,validation-api.jar,velocypack.jar,websocket-api.jar,wl*.jar,wsdl4j*.jar,xercesImpl.jar,xml-apis.jar,xmlbeans.jar,xmlParserAPIs-*.jar,xmlParserAPIs.jar,xom-*.jar,xz.jar,zip4j.jar,zookeeper.jar\njava.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\njava.vendor.url = http://jdk.rnd.huawei.com/\njava.vm.vendor = Huawei Technologies Co., Ltd\ncommon.loader = \"${catalina.base}/lib\",\"${catalina.base}/lib/*.jar\",\"${catalina.home}/lib\",\"${catalina.home}/lib/*.jar\"\njava.runtime.name = OpenJDK Runtime Environment\nsun.java.command = org.apache.catalina.startup.Bootstrap start\njava.class.path = /usr/share/tomcat/bin/bootstrap.jar:/usr/share/tomcat/bin/tomcat-juli.jar:/usr/lib/java/commons-daemon.jar\njava.vm.specification.name = Java Virtual Machine Specification\njava.vm.specification.version = 1.8\ncatalina.home = /usr/share/tomcat\nsun.cpu.endian = little\nsun.os.patch.level = unknown\njava.awt.headless = true\njava.io.tmpdir = /var/cache/tomcat/temp\njava.vendor.url.bug = http://jdk.rnd.huawei.com/\nserver.loader = \njava.rmi.server.hostname = 127.0.0.1\njna.platform.library.path = /usr/lib64:/lib64:/usr/lib:/lib:/usr/lib64/tracker-miners-2.0:/usr/lib64/tracker-2.0:/usr/lib64/dyninst:/usr/libexec/sudo:/usr/lib64/sssd:/usr/pgsql-9.6/lib:/usr/lib64/perl5/CORE:/usr/lib64/opencryptoki:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64/jli:/usr/lib64/bind9-export\nos.arch = amd64\njava.awt.graphicsenv = sun.awt.X11GraphicsEnvironment\njava.ext.dirs = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/ext:/usr/java/packages/lib/ext\nuser.dir = /usr/share/tomcat\nline.separator = \n\njava.vm.name = OpenJDK 64-Bit Server VM\nlog4j.configurationFile = /etc/tomcat/log4j2.xml\nfile.encoding = UTF-8\ncom.sun.jndi.ldap.object.disableEndpointIdentification = \njava.specification.version = 1.8\n\nVM Flags:\nNon-default VM flags: -XX:CICompilerCount=4 -XX:GCLogFileSize=20971520 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=243269632 -XX:MaxHeapSize=1610612736 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=80740352 -XX:NumberOfGCLogFiles=15 -XX:OldSize=162529280 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRotation -XX:+UseParallelGC \nCommand line:  -Xmx1536m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/tomcat -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=20m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/var/log/tomcat/tomcat-gc-%t.log -Dcom.sun.jndi.ldap.object.disableEndpointIdentification -Dcatalina.base=/usr/share/tomcat -Dcatalina.home=/usr/share/tomcat -Djava.endorsed.dirs= -Djava.io.tmpdir=/var/cache/tomcat/temp -Dlog4j.configurationFile=/etc/tomcat/log4j2.xml -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n```\n\n## 3.jstat\n命令参数说明：\n- generalOptions：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：\n- -help：显示帮助信息。\n- -options：显示outputOptions参数的列表。\n- outputOptions：输出选项，指定显示某一种Java虚拟机信息。\n- -t：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。\n- -h n：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。\n- vmid：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。\n- interval：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每隔这段时间显示一次统计信息。\n- count：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。\n输出选项\n如果不指定通用选项（generalOptions），则可以指定输出选项（outputOptions）。输出选项决定jstat命令显示的内容和格式，具体如下：\n- -class：显示类加载、卸载数量、总空间和装载耗时的统计信息。\n- -compiler：显示即时编译的方法、耗时等信息。\n- -gc：显示堆各个区域内存使用和垃圾回收的统计信息。\n- -gccapacity：显示堆各个区域的容量及其对应的空间的统计信息。\n- -gcutil：显示有关垃圾收集统计信息的摘要。\n- -gccause：显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因。\n- -gcnew：显示新生代的垃圾回收统计信息。\n- -gcnewcapacity：显示新生代的大小及其对应的空间的统计信息。\n- -gcold: 显示老年代和元空间的垃圾回收统计信息。\n- -gcoldcapacity：显示老年代的大小统计信息。\n- -gcmetacapacity：显示元空间的大小的统计信息。\n- -printcompilation：显示即时编译方法的统计信息。\n\n# 二、线程堆栈\n## 1.输出\nJava虚拟机提供了线程转储(Thread dump)的后门，通过这个后门，可以将线程堆栈打印出来。这个后门就是通过向Java进程发送一个QUIT信号，Java虚拟机收到该信号之后，将系统当前的JAVA线程调用堆栈打印出来。\n\n打印方法：\n- jstack -l pid > xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式\n- kill -3\n***同时请确保Java命令行中没有DISABLE_JAVADUMP运行选项***\n## 2.线程分析\n通过输出堆栈进行分析 `jstack -l $(jps | grep xxx | awk '{print $1}')` > /tmp/xxx.jstack\n```Lua\n\"SYS_STATUS_CHECKER\" #14 daemon prio=5 os_prio=0 tid=0x00007f5e047bf000 nid=0xe15 waiting on condition [0x00007f5dd43d1000]\n    java.lang.Thread.State: TIMED_WAITING (sleeping)\n        at java.lang.Thread.sleep(Native Method)\nru        at com.xxx.xxx.SystemStatusChecker.run(SystemStatusChecker.java:xx)\n        at java.lang.Thread.run(Thread.java:748)        \n    Locked ownable synchronizers:\n        - None\n                \n\"RMI Reaper\" #39 prio=5 os_prio=0 tid=0x00007f5e04e4c800 nid=0xf0b in Object.wait() [0x00007f5dae2c4000]\n    java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)\n        - locked <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)\n        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:351)\n        at java.lang.Thread.run(Thread.java:748)\n    Locked ownable synchronizers:\n        - None\n        \n\"main\" #1 prio=5 os_prio=0 tid=0x00007f5e0400a000 nid=0xdcb runnable [0x00007f5e0b393000]\n    java.lang.Thread.State: RUNNABLE\n        at java.net.PlainSocketImpl.socketAccept(Native Method)\n        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:545)\n        at java.net.ServerSocket.accept(ServerSocket.java:513)\n        at com.xxx.common.xxx.await(CommonMain.java:244)\n        at com.xxx.common.xxx.startup(CommonMain.java:207)\n        at com.xxx.common.xxx.main(CommonMain.java:147)\n    Locked ownable synchronizers:\n        - None\n```\n在RMI线程中可以看到 \" - locked <0x00000000c0c88d20> (a java.lang.ref.ReferenceQueue$Lock)\" 表示该线程已经使用了ID为\"0x00000000c0c88d2\"的锁，锁的ID由系统自动产生\n```\n\"main\"  prio=5     os_prio=0          tid=0x00007f5e0400a000 nid=0xdcb      runnable [0x00007f5e0b393000]\n|       |          |                  |                      |              |         |\n线程名称 线程优先级   操作系统级别的优先级   线程id                 对应的本地线程ID  状态      线程占用内存地址\n```\n\n其中\"线程对应的本地线程id号\"所指的\"本地线程\"是指该Java线程所对应的虚拟机中的本地线程。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是 依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。\n\nJava代码 中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix/Linux下，我们可以通 如下方式把Java虚拟机的本地线程打印出来：\n- 使用ps -ef | grep java 获得Java进程ID。\n- 使用pstack <java pid>获得Java虚拟机的本地线程的堆栈\n其中本地线程各项含义如下：\n```\nThread 56 (Thread 0x7f5e0b394700 (LWP 3531))\n|                 |                 |\n|                 |                 +----本地线程id(另一种表示,LWP-light weight process)\n|                 +-------------------本地线程id\n+------------------------------线程名称\n```\n而通过jstack输出的main本地线程ID为0xdcb，其10进制正好为3531。\n\n\"runnable\"表示当前线程处于运行状态。这个runnable状态是从虚拟机的角度来看的, 表示这个线程正在运行\n<p><strong>⚠️ NOTE:</strong> 但是处于Runnable状态的线程不一定真的消耗CPU. 处于Runnable的线程只能说明该线程没有阻塞在java的wait或者sleep方法上，同时也没等待在锁上面。但是如果该线程调用了本地方法，而本地方法处于等待状态，这个时候虚拟机是不知道本地代码中发生 了什么（但操作系统是知道的，pstack就是操作提供的一个命令，它知道当前线程正在执行的本地代码上下文），此时尽管当前线程实际上也是阻塞的状态，但实际上显示出来的还是runnable状态， 这种情况下是不消耗CPU的</p>\n\n```\n1. 处于waittig和blocked状态的线程都不会消耗CPU \n2. 线程频繁地挂起和唤醒需要消耗CPU, 而且代价颇大\n```\n- TIMED_WAITING(on object monitor) 表示当前线程被挂起一段时间,说明该线程正在 执行obj.wait(int time)方法.\n- TIMED_WAITING(sleeping) 表示当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法. \n- TIMED_WAITING(parking) 当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法.\n- WAINTING(on object monitor) 当前线程被挂起，即正在执行obj.wait()方法(无参数的wait()方法).\n```\n处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.\n• 如果是纯Java运算代码，则消耗CPU.\n• 如果是网络IO,很少消耗CPU.\n• 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)， 如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消 耗CPU。\n```\n# 三、相关的排查方法\n## 1.CPU\n生产环境中往往会出现CPU飙高的情况，对于JAVA应用而言，此类问题相对较好确定问题方向。\n### 1.1 使用jstack确定CPU占用高的线程\\\n通过`top`指令，可以看到进程占用的一些基础资源信息，然后“P”键可以按照CPU使用率进行排序，“M”键可以按照内存占用情况进行排序\n\n找到CPU占用高的进程pid，然后将jstack信息定向到一个文件中去，通过`top -Hp pid`查看具体的情况。\n\n通过 `printf '%x\\n' pid`将pid转换为16进制，然后在jstack文件中根据对应的数字进行查找，然后针对性的进行分析\n### 1.2 频繁GC\n有时候我们可以先确定下gc是不是太频繁，使用`jstat -gc pid 1000`命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，`S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU`分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。`YGC/YGT、FGC/FGCT、GCT`则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。\n![alt text](../images/gc.png)\n### 1.3 频繁上下文切换\n针对频繁上下文问题，我们可以使用vmstat命令来进行查看\n![alt text](../images/vmstat.png)\ncs(context switch)一列则代表了上下文切换的次数。\n\n如果我们希望对特定的pid进行监控那么可以使用 `pidstat -w pid`命令，cswch和nvcswch表示自愿及非自愿切换。\n\n## 2.内存\n对于JAVA应用，涉及到的内存问题主要包括OOM、GC问题和堆外内存。\n### 2.1 OOM\nJVM中的内存不足，OOM大致可以分为以下几种情况\n- `Exception in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread` 这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改`/etc/security/limits.confnofile`和`nproc`来增大os对线程的限制\n- `Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space ` 这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。\n- `Caused by: java.lang.OutOfMemoryError: Meta space` 这个意思是元数据区的内存占用已经达到`XX:MaxMetaspaceSize`设置的最大值，排查思路和上面的一致，参数方面可以通过`XX:MaxPermSize`来进行调整\n- `Exception in thread \"main\" java.lang.StackOverflowError` 表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。\n### 2.2 GC问题\ngc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常等。\n\n线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的`unable to create new native thread`。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过`pstreee -p pid |wc -l`\n### 2.3 堆外内存\nJVM 的堆外内存主要包括：\n- JVM 自身运行占用的空间；\n- 线程栈分配占用的系统内存；\n- DirectByteBuffer 占用的内存；\n- JNI 里分配的内存；\n- Java 8 开始的元数据空间；\n- NIO 缓存\n- Unsafe 调用分配的内存；\n- codecache\n\n冰山对象：冰山对象是指在 JVM 堆里占用的内存很小，但其实引用了一块很大的本地内存。DirectByteBuffer 和 线程都属于这类对象。\n#### 2.3.1NMT分析堆外内存\nNMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。\n\nNMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。\n\n#### 2.3.2 开启 NMT\n启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。\n启动命令： `-XX:NativeMemoryTracking=[off | summary | detail]`。\n- off：NMT 默认是关闭的；\n- summary：只收集子系统的内存使用的总计数据；\n- detail：收集每个调用点的内存使用数据。\n\n#### 2.3.3 jcmd 访问 NMT 数据\n命令：\n`jcmd <pid> VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]`\n\n","slug":"JAVA问题定位","published":1,"updated":"2024-08-17T15:11:14.404Z","comments":1,"layout":"post","photos":[],"_id":"clzzd33n00001x4ic3em03qw9","content":"<span id=\"more\"></span>\n\n\n<h1 id=\"一、JAVA-相关命令\"><a href=\"#一、JAVA-相关命令\" class=\"headerlink\" title=\"一、JAVA 相关命令\"></a>一、JAVA 相关命令</h1><h2 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1.jps\"></a>1.jps</h2><p>jps - Lists the instrumented Java Virtual Machines (JVMs) on the target system. This command is experimental and unsupported.</p>\n<p>相关参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS</span><br><span class=\"line\">       The jps command supports a number of options that modify the output of the command. These options are subject to change or removal in the future.</span><br><span class=\"line\">       -q</span><br><span class=\"line\">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class=\"line\">       -m</span><br><span class=\"line\">              Displays the arguments passed to the main method. The output may be null for embedded JVMs.</span><br><span class=\"line\">       -l</span><br><span class=\"line\">              Displays the full package name for the application&#x27;s main class or the full path name to the application&#x27;s JAR file.</span><br><span class=\"line\">       -v</span><br><span class=\"line\">              Displays the arguments passed to the JVM.</span><br><span class=\"line\">       -V</span><br><span class=\"line\">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class=\"line\">       -Joption</span><br><span class=\"line\">              Passes option to the JVM, where option is one of the options described on the reference page for the Java application launcher. For example, -J-Xms48m sets the</span><br><span class=\"line\">              startup memory to 48 MB. See java(1).</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-jinfo\"><a href=\"#2-jinfo\" class=\"headerlink\" title=\"2.jinfo\"></a>2.jinfo</h2><p>jinfo（Java Virtual Machine Configuration Information）是JDK提供的一个可以实时查看Java虚拟机各种配置参数和系统属性的命令行工具。使用jps命令的-v参数可以查看Java虚拟机启动时显式指定的配置参数，如果想查看没有显式指定的配置参数就可以使用jinfo命令进行查看。另外，jinfo命令还可以查询Java虚拟机进程的System.getProperties()的内容。</p>\n<p>以tomcat进程为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Attaching to process ID 2045, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.242-b08</span><br><span class=\"line\">Java System Properties:</span><br><span class=\"line\"></span><br><span class=\"line\">java.vendor = Huawei Technologies Co., Ltd</span><br><span class=\"line\">sun.java.launcher = SUN_STANDARD</span><br><span class=\"line\">catalina.base = /usr/share/tomcat</span><br><span class=\"line\">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class=\"line\">sun.nio.ch.bugLevel = </span><br><span class=\"line\">catalina.useNaming = true</span><br><span class=\"line\">jnidispatch.path = /var/cache/tomcat/temp/jna--903012287/jna4240128671455089550.tmp</span><br><span class=\"line\">os.name = Linux</span><br><span class=\"line\">sun.boot.class.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/classes</span><br><span class=\"line\">java.vm.specification.vendor = Oracle Corporation</span><br><span class=\"line\">java.runtime.version = 1.8.0_242-b08</span><br><span class=\"line\">jna.loaded = true</span><br><span class=\"line\">user.name = xxx</span><br><span class=\"line\">tomcat.util.scan.StandardJarScanFilter.jarsToScan = taglibs-standard-impl*.jar</span><br><span class=\"line\">shared.loader = </span><br><span class=\"line\">tomcat.util.buf.StringCache.byte.enabled = true</span><br><span class=\"line\">user.language = en</span><br><span class=\"line\">java.naming.factory.initial = org.apache.naming.java.javaURLContextFactory</span><br><span class=\"line\">sun.boot.library.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64</span><br><span class=\"line\">java.version = 1.8.0_242</span><br><span class=\"line\">java.util.logging.manager = org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">user.timezone = Asia/Shanghai</span><br><span class=\"line\">sun.arch.data.model = 64</span><br><span class=\"line\">java.util.concurrent.ForkJoinPool.common.threadFactory = org.apache.catalina.startup.SafeForkJoinWorkerThreadFactory</span><br><span class=\"line\">java.endorsed.dirs = </span><br><span class=\"line\">sun.cpu.isalist = </span><br><span class=\"line\">sun.jnu.encoding = UTF-8</span><br><span class=\"line\">file.encoding.pkg = sun.io</span><br><span class=\"line\">package.access = sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.</span><br><span class=\"line\">file.separator = /</span><br><span class=\"line\">java.specification.name = Java Platform API Specification</span><br><span class=\"line\">java.class.version = 52.0</span><br><span class=\"line\">user.country = US</span><br><span class=\"line\">java.home = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre</span><br><span class=\"line\">java.vm.info = mixed mode</span><br><span class=\"line\">os.version = 4.19.90-24.4.v2101.ky10.x86_64</span><br><span class=\"line\">sun.font.fontmanager = sun.awt.X11FontManager</span><br><span class=\"line\">path.separator = :</span><br><span class=\"line\">java.vm.version = 25.242-b08</span><br><span class=\"line\">jboss.i18n.generate-proxies = true</span><br><span class=\"line\">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class=\"line\">sun.io.unicode.encoding = UnicodeLittle</span><br><span class=\"line\">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class=\"line\">package.definition = sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.</span><br><span class=\"line\">java.naming.factory.url.pkgs = org.apache.naming</span><br><span class=\"line\">mail.mime.splitlongparameters = false</span><br><span class=\"line\">java.security.egd = file:/dev/./urandom</span><br><span class=\"line\">user.home = /home/shterm</span><br><span class=\"line\">java.specification.vendor = Oracle Corporation</span><br><span class=\"line\">tomcat.util.scan.StandardJarScanFilter.jarsToSkip = activ*.jar,amqp-client.jar,annotations-api.jar,ant-junit*.jar,ant-launcher.jar,ant.jar,antlr.jar,aopalliance.jar,asm-*.jar,aspectj*.jar,bcp*.jar,bootstrap.jar,catalina-ant.jar,catalina-ha.jar,catalina-jmx-remote.jar,catalina-storeconfig.jar,catalina-tribes.jar,catalina-ws.jar,catalina.jar,cglib-*.jar,classmate.jar,cobertura-*.jar,commons-*.jar,compress-lzf.jar,curator-*.jar,db2-jdbc.jar,dom4j-*.jar,easymock-*.jar,ecj-*.jar,el-api.jar,elasticsearch.jar,geronimo-spec-jaxrpc*.jar,groovy-all.jar,guava.jar,h2*.jar,hamcrest-*.jar,hibernate*.jar,hppc.jar,http*.jar,icu4j-*.jar,itext*.jar,jackson-*.jar,jandex.jar,jasper-el.jar,jasper.jar,jasperreports*.jar,jaspic-api.jar,javamail.jar,javassist.jar,jaxb-*.jar,jaxen*.jar,jboss*.jar,jc*.jar,jdom-*.jar,jedis.jar,jetty-*.jar,jfreechart.jar,jgit.jar,jline.jar,jmx-tools.jar,jmx.jar,jna.jar,joda-time.jar,jr-*.jar,jsch.jar,json*.jar,jsoup.jar,jsp-api.jar,jsr166e.jar,jstl.jar,jta*.jar,junit-*.jar,junit.jar,liquibase-*.jar,log4j*.jar,lucene*.jar,mail*.jar,mariadb-jdbc.jar,mssql-jdbc.jar,mybatis.jar,netty.jar,nmap4j.jar,objenesis*.jar,olap4j.jar,opc*.jar,oracle-jdbc.jar,oraclepki.jar,oro-*.jar,poi*.jar,postgresql-jdbc.jar,quartz.jar,servlet-api-*.jar,servlet-api.jar,slf4j*.jar,snakeyaml.jar,snmp4j.jar,spring*.jar,sshd-core.jar,taglibs-standard-spec-*.jar,tagsoup-*.jar,t-digest.jar,tomcat-api.jar,tomcat-coyote.jar,tomcat-dbcp.jar,tomcat-i18n-*.jar,tomcat-jdbc.jar,tomcat-jni.jar,tomcat-juli-adapters.jar,tomcat-juli.jar,tomcat-util-scan.jar,tomcat-util.jar,tomcat-websocket.jar,tools.jar,validation-api.jar,velocypack.jar,websocket-api.jar,wl*.jar,wsdl4j*.jar,xercesImpl.jar,xml-apis.jar,xmlbeans.jar,xmlParserAPIs-*.jar,xmlParserAPIs.jar,xom-*.jar,xz.jar,zip4j.jar,zookeeper.jar</span><br><span class=\"line\">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class=\"line\">java.vendor.url = http://jdk.rnd.huawei.com/</span><br><span class=\"line\">java.vm.vendor = Huawei Technologies Co., Ltd</span><br><span class=\"line\">common.loader = &quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span><br><span class=\"line\">java.runtime.name = OpenJDK Runtime Environment</span><br><span class=\"line\">sun.java.command = org.apache.catalina.startup.Bootstrap start</span><br><span class=\"line\">java.class.path = /usr/share/tomcat/bin/bootstrap.jar:/usr/share/tomcat/bin/tomcat-juli.jar:/usr/lib/java/commons-daemon.jar</span><br><span class=\"line\">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class=\"line\">java.vm.specification.version = 1.8</span><br><span class=\"line\">catalina.home = /usr/share/tomcat</span><br><span class=\"line\">sun.cpu.endian = little</span><br><span class=\"line\">sun.os.patch.level = unknown</span><br><span class=\"line\">java.awt.headless = true</span><br><span class=\"line\">java.io.tmpdir = /var/cache/tomcat/temp</span><br><span class=\"line\">java.vendor.url.bug = http://jdk.rnd.huawei.com/</span><br><span class=\"line\">server.loader = </span><br><span class=\"line\">java.rmi.server.hostname = 127.0.0.1</span><br><span class=\"line\">jna.platform.library.path = /usr/lib64:/lib64:/usr/lib:/lib:/usr/lib64/tracker-miners-2.0:/usr/lib64/tracker-2.0:/usr/lib64/dyninst:/usr/libexec/sudo:/usr/lib64/sssd:/usr/pgsql-9.6/lib:/usr/lib64/perl5/CORE:/usr/lib64/opencryptoki:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64/jli:/usr/lib64/bind9-export</span><br><span class=\"line\">os.arch = amd64</span><br><span class=\"line\">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class=\"line\">java.ext.dirs = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class=\"line\">user.dir = /usr/share/tomcat</span><br><span class=\"line\">line.separator = </span><br><span class=\"line\"></span><br><span class=\"line\">java.vm.name = OpenJDK 64-Bit Server VM</span><br><span class=\"line\">log4j.configurationFile = /etc/tomcat/log4j2.xml</span><br><span class=\"line\">file.encoding = UTF-8</span><br><span class=\"line\">com.sun.jndi.ldap.object.disableEndpointIdentification = </span><br><span class=\"line\">java.specification.version = 1.8</span><br><span class=\"line\"></span><br><span class=\"line\">VM Flags:</span><br><span class=\"line\">Non-default VM flags: -XX:CICompilerCount=4 -XX:GCLogFileSize=20971520 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=243269632 -XX:MaxHeapSize=1610612736 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=80740352 -XX:NumberOfGCLogFiles=15 -XX:OldSize=162529280 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRotation -XX:+UseParallelGC </span><br><span class=\"line\">Command line:  -Xmx1536m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/tomcat -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=20m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/var/log/tomcat/tomcat-gc-%t.log -Dcom.sun.jndi.ldap.object.disableEndpointIdentification -Dcatalina.base=/usr/share/tomcat -Dcatalina.home=/usr/share/tomcat -Djava.endorsed.dirs= -Djava.io.tmpdir=/var/cache/tomcat/temp -Dlog4j.configurationFile=/etc/tomcat/log4j2.xml -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-jstat\"><a href=\"#3-jstat\" class=\"headerlink\" title=\"3.jstat\"></a>3.jstat</h2><p>命令参数说明：</p>\n<ul>\n<li>generalOptions：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：</li>\n<li>-help：显示帮助信息。</li>\n<li>-options：显示outputOptions参数的列表。</li>\n<li>outputOptions：输出选项，指定显示某一种Java虚拟机信息。</li>\n<li>-t：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。</li>\n<li>-h n：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。</li>\n<li>vmid：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。</li>\n<li>interval：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每隔这段时间显示一次统计信息。</li>\n<li>count：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。<br>输出选项<br>如果不指定通用选项（generalOptions），则可以指定输出选项（outputOptions）。输出选项决定jstat命令显示的内容和格式，具体如下：</li>\n<li>-class：显示类加载、卸载数量、总空间和装载耗时的统计信息。</li>\n<li>-compiler：显示即时编译的方法、耗时等信息。</li>\n<li>-gc：显示堆各个区域内存使用和垃圾回收的统计信息。</li>\n<li>-gccapacity：显示堆各个区域的容量及其对应的空间的统计信息。</li>\n<li>-gcutil：显示有关垃圾收集统计信息的摘要。</li>\n<li>-gccause：显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因。</li>\n<li>-gcnew：显示新生代的垃圾回收统计信息。</li>\n<li>-gcnewcapacity：显示新生代的大小及其对应的空间的统计信息。</li>\n<li>-gcold: 显示老年代和元空间的垃圾回收统计信息。</li>\n<li>-gcoldcapacity：显示老年代的大小统计信息。</li>\n<li>-gcmetacapacity：显示元空间的大小的统计信息。</li>\n<li>-printcompilation：显示即时编译方法的统计信息。</li>\n</ul>\n<h1 id=\"二、线程堆栈\"><a href=\"#二、线程堆栈\" class=\"headerlink\" title=\"二、线程堆栈\"></a>二、线程堆栈</h1><h2 id=\"1-输出\"><a href=\"#1-输出\" class=\"headerlink\" title=\"1.输出\"></a>1.输出</h2><p>Java虚拟机提供了线程转储(Thread dump)的后门，通过这个后门，可以将线程堆栈打印出来。这个后门就是通过向Java进程发送一个QUIT信号，Java虚拟机收到该信号之后，将系统当前的JAVA线程调用堆栈打印出来。</p>\n<p>打印方法：</p>\n<ul>\n<li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li>\n<li>kill -3<br><em><strong>同时请确保Java命令行中没有DISABLE_JAVADUMP运行选项</strong></em></li>\n</ul>\n<h2 id=\"2-线程分析\"><a href=\"#2-线程分析\" class=\"headerlink\" title=\"2.线程分析\"></a>2.线程分析</h2><p>通过输出堆栈进行分析 <code>jstack -l $(jps | grep xxx | awk &#39;&#123;print $1&#125;&#39;)</code> &gt; &#x2F;tmp&#x2F;xxx.jstack</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;SYS_STATUS_CHECKER&quot;</span> #<span class=\"number\">14</span> daemon prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e047bf000</span> nid=<span class=\"number\">0xe15</span> waiting on condition [<span class=\"number\">0x00007f5dd43d1000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">ru        at com.xxx.xxx.SystemStatusChecker.run(SystemStatusChecker.java:xx)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)        </span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"string\">&quot;RMI Reaper&quot;</span> #<span class=\"number\">39</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e04e4c800</span> nid=<span class=\"number\">0xf0b</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f5dae2c4000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">144</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">165</span>)</span><br><span class=\"line\">        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:<span class=\"number\">351</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"string\">&quot;main&quot;</span> #<span class=\"number\">1</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e0400a000</span> nid=<span class=\"number\">0xdcb</span> runnable [<span class=\"number\">0x00007f5e0b393000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class=\"number\">409</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class=\"number\">545</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.accept(ServerSocket.java:<span class=\"number\">513</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.await(CommonMain.java:<span class=\"number\">244</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.startup(CommonMain.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.main(CommonMain.java:<span class=\"number\">147</span>)</span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br></pre></td></tr></table></figure>\n<p>在RMI线程中可以看到 “ - locked &lt;0x00000000c0c88d20&gt; (a java.lang.ref.ReferenceQueue$Lock)” 表示该线程已经使用了ID为”0x00000000c0c88d2”的锁，锁的ID由系统自动产生</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot;  prio=5     os_prio=0          tid=0x00007f5e0400a000 nid=0xdcb      runnable [0x00007f5e0b393000]</span><br><span class=\"line\">|       |          |                  |                      |              |         |</span><br><span class=\"line\">线程名称 线程优先级   操作系统级别的优先级   线程id                 对应的本地线程ID  状态      线程占用内存地址</span><br></pre></td></tr></table></figure>\n\n<p>其中”线程对应的本地线程id号”所指的”本地线程”是指该Java线程所对应的虚拟机中的本地线程。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是 依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。</p>\n<p>Java代码 中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix&#x2F;Linux下，我们可以通 如下方式把Java虚拟机的本地线程打印出来：</p>\n<ul>\n<li>使用ps -ef | grep java 获得Java进程ID。</li>\n<li>使用pstack <java pid>获得Java虚拟机的本地线程的堆栈<br>其中本地线程各项含义如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 56 (Thread 0x7f5e0b394700 (LWP 3531))</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|                 |                 +----本地线程id(另一种表示,LWP-light weight process)</span><br><span class=\"line\">|                 +-------------------本地线程id</span><br><span class=\"line\">+------------------------------线程名称</span><br></pre></td></tr></table></figure>\n而通过jstack输出的main本地线程ID为0xdcb，其10进制正好为3531。</li>\n</ul>\n<p>“runnable”表示当前线程处于运行状态。这个runnable状态是从虚拟机的角度来看的, 表示这个线程正在运行</p>\n<p><strong>⚠️ NOTE:</strong> 但是处于Runnable状态的线程不一定真的消耗CPU. 处于Runnable的线程只能说明该线程没有阻塞在java的wait或者sleep方法上，同时也没等待在锁上面。但是如果该线程调用了本地方法，而本地方法处于等待状态，这个时候虚拟机是不知道本地代码中发生 了什么（但操作系统是知道的，pstack就是操作提供的一个命令，它知道当前线程正在执行的本地代码上下文），此时尽管当前线程实际上也是阻塞的状态，但实际上显示出来的还是runnable状态， 这种情况下是不消耗CPU的</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 处于waittig和blocked状态的线程都不会消耗CPU </span><br><span class=\"line\">2. 线程频繁地挂起和唤醒需要消耗CPU, 而且代价颇大</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TIMED_WAITING(on object monitor) 表示当前线程被挂起一段时间,说明该线程正在 执行obj.wait(int time)方法.</li>\n<li>TIMED_WAITING(sleeping) 表示当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法. </li>\n<li>TIMED_WAITING(parking) 当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法.</li>\n<li>WAINTING(on object monitor) 当前线程被挂起，即正在执行obj.wait()方法(无参数的wait()方法).<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.</span><br><span class=\"line\">• 如果是纯Java运算代码，则消耗CPU.</span><br><span class=\"line\">• 如果是网络IO,很少消耗CPU.</span><br><span class=\"line\">• 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)， 如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消 耗CPU。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、相关的排查方法\"><a href=\"#三、相关的排查方法\" class=\"headerlink\" title=\"三、相关的排查方法\"></a>三、相关的排查方法</h1><h2 id=\"1-CPU\"><a href=\"#1-CPU\" class=\"headerlink\" title=\"1.CPU\"></a>1.CPU</h2><p>生产环境中往往会出现CPU飙高的情况，对于JAVA应用而言，此类问题相对较好确定问题方向。</p>\n<h3 id=\"1-1-使用jstack确定CPU占用高的线程\"><a href=\"#1-1-使用jstack确定CPU占用高的线程\" class=\"headerlink\" title=\"1.1 使用jstack确定CPU占用高的线程\\\"></a>1.1 使用jstack确定CPU占用高的线程\\</h3><p>通过<code>top</code>指令，可以看到进程占用的一些基础资源信息，然后“P”键可以按照CPU使用率进行排序，“M”键可以按照内存占用情况进行排序</p>\n<p>找到CPU占用高的进程pid，然后将jstack信息定向到一个文件中去，通过<code>top -Hp pid</code>查看具体的情况。</p>\n<p>通过 <code>printf &#39;%x\\n&#39; pid</code>将pid转换为16进制，然后在jstack文件中根据对应的数字进行查找，然后针对性的进行分析</p>\n<h3 id=\"1-2-频繁GC\"><a href=\"#1-2-频繁GC\" class=\"headerlink\" title=\"1.2 频繁GC\"></a>1.2 频繁GC</h3><p>有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，<code>S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU</code>分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。<code>YGC/YGT、FGC/FGCT、GCT</code>则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。<br><img src=\"/../images/gc.png\" alt=\"alt text\"></p>\n<h3 id=\"1-3-频繁上下文切换\"><a href=\"#1-3-频繁上下文切换\" class=\"headerlink\" title=\"1.3 频繁上下文切换\"></a>1.3 频繁上下文切换</h3><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看<br><img src=\"/../images/vmstat.png\" alt=\"alt text\"><br>cs(context switch)一列则代表了上下文切换的次数。</p>\n<p>如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。</p>\n<h2 id=\"2-内存\"><a href=\"#2-内存\" class=\"headerlink\" title=\"2.内存\"></a>2.内存</h2><p>对于JAVA应用，涉及到的内存问题主要包括OOM、GC问题和堆外内存。</p>\n<h3 id=\"2-1-OOM\"><a href=\"#2-1-OOM\" class=\"headerlink\" title=\"2.1 OOM\"></a>2.1 OOM</h3><p>JVM中的内存不足，OOM大致可以分为以下几种情况</p>\n<ul>\n<li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</code> 这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.confnofile</code>和<code>nproc</code>来增大os对线程的限制</li>\n<li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space </code> 这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</li>\n<li><code>Caused by: java.lang.OutOfMemoryError: Meta space</code> 这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整</li>\n<li><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code> 表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。</li>\n</ul>\n<h3 id=\"2-2-GC问题\"><a href=\"#2-2-GC问题\" class=\"headerlink\" title=\"2.2 GC问题\"></a>2.2 GC问题</h3><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常等。</p>\n<p>线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code></p>\n<h3 id=\"2-3-堆外内存\"><a href=\"#2-3-堆外内存\" class=\"headerlink\" title=\"2.3 堆外内存\"></a>2.3 堆外内存</h3><p>JVM 的堆外内存主要包括：</p>\n<ul>\n<li>JVM 自身运行占用的空间；</li>\n<li>线程栈分配占用的系统内存；</li>\n<li>DirectByteBuffer 占用的内存；</li>\n<li>JNI 里分配的内存；</li>\n<li>Java 8 开始的元数据空间；</li>\n<li>NIO 缓存</li>\n<li>Unsafe 调用分配的内存；</li>\n<li>codecache</li>\n</ul>\n<p>冰山对象：冰山对象是指在 JVM 堆里占用的内存很小，但其实引用了一块很大的本地内存。DirectByteBuffer 和 线程都属于这类对象。</p>\n<h4 id=\"2-3-1NMT分析堆外内存\"><a href=\"#2-3-1NMT分析堆外内存\" class=\"headerlink\" title=\"2.3.1NMT分析堆外内存\"></a>2.3.1NMT分析堆外内存</h4><p>NMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。</p>\n<p>NMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。</p>\n<h4 id=\"2-3-2-开启-NMT\"><a href=\"#2-3-2-开启-NMT\" class=\"headerlink\" title=\"2.3.2 开启 NMT\"></a>2.3.2 开启 NMT</h4><p>启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。<br>启动命令： <code>-XX:NativeMemoryTracking=[off | summary | detail]</code>。</p>\n<ul>\n<li>off：NMT 默认是关闭的；</li>\n<li>summary：只收集子系统的内存使用的总计数据；</li>\n<li>detail：收集每个调用点的内存使用数据。</li>\n</ul>\n<h4 id=\"2-3-3-jcmd-访问-NMT-数据\"><a href=\"#2-3-3-jcmd-访问-NMT-数据\" class=\"headerlink\" title=\"2.3.3 jcmd 访问 NMT 数据\"></a>2.3.3 jcmd 访问 NMT 数据</h4><p>命令：<br><code>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</code></p>\n","excerpt":"","more":"<h1 id=\"一、JAVA-相关命令\"><a href=\"#一、JAVA-相关命令\" class=\"headerlink\" title=\"一、JAVA 相关命令\"></a>一、JAVA 相关命令</h1><h2 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1.jps\"></a>1.jps</h2><p>jps - Lists the instrumented Java Virtual Machines (JVMs) on the target system. This command is experimental and unsupported.</p>\n<p>相关参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS</span><br><span class=\"line\">       The jps command supports a number of options that modify the output of the command. These options are subject to change or removal in the future.</span><br><span class=\"line\">       -q</span><br><span class=\"line\">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class=\"line\">       -m</span><br><span class=\"line\">              Displays the arguments passed to the main method. The output may be null for embedded JVMs.</span><br><span class=\"line\">       -l</span><br><span class=\"line\">              Displays the full package name for the application&#x27;s main class or the full path name to the application&#x27;s JAR file.</span><br><span class=\"line\">       -v</span><br><span class=\"line\">              Displays the arguments passed to the JVM.</span><br><span class=\"line\">       -V</span><br><span class=\"line\">              Suppresses the output of the class name, JAR file name, and arguments passed to the main method, producing only a list of local JVM identifiers.</span><br><span class=\"line\">       -Joption</span><br><span class=\"line\">              Passes option to the JVM, where option is one of the options described on the reference page for the Java application launcher. For example, -J-Xms48m sets the</span><br><span class=\"line\">              startup memory to 48 MB. See java(1).</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-jinfo\"><a href=\"#2-jinfo\" class=\"headerlink\" title=\"2.jinfo\"></a>2.jinfo</h2><p>jinfo（Java Virtual Machine Configuration Information）是JDK提供的一个可以实时查看Java虚拟机各种配置参数和系统属性的命令行工具。使用jps命令的-v参数可以查看Java虚拟机启动时显式指定的配置参数，如果想查看没有显式指定的配置参数就可以使用jinfo命令进行查看。另外，jinfo命令还可以查询Java虚拟机进程的System.getProperties()的内容。</p>\n<p>以tomcat进程为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Attaching to process ID 2045, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.242-b08</span><br><span class=\"line\">Java System Properties:</span><br><span class=\"line\"></span><br><span class=\"line\">java.vendor = Huawei Technologies Co., Ltd</span><br><span class=\"line\">sun.java.launcher = SUN_STANDARD</span><br><span class=\"line\">catalina.base = /usr/share/tomcat</span><br><span class=\"line\">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class=\"line\">sun.nio.ch.bugLevel = </span><br><span class=\"line\">catalina.useNaming = true</span><br><span class=\"line\">jnidispatch.path = /var/cache/tomcat/temp/jna--903012287/jna4240128671455089550.tmp</span><br><span class=\"line\">os.name = Linux</span><br><span class=\"line\">sun.boot.class.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/classes</span><br><span class=\"line\">java.vm.specification.vendor = Oracle Corporation</span><br><span class=\"line\">java.runtime.version = 1.8.0_242-b08</span><br><span class=\"line\">jna.loaded = true</span><br><span class=\"line\">user.name = xxx</span><br><span class=\"line\">tomcat.util.scan.StandardJarScanFilter.jarsToScan = taglibs-standard-impl*.jar</span><br><span class=\"line\">shared.loader = </span><br><span class=\"line\">tomcat.util.buf.StringCache.byte.enabled = true</span><br><span class=\"line\">user.language = en</span><br><span class=\"line\">java.naming.factory.initial = org.apache.naming.java.javaURLContextFactory</span><br><span class=\"line\">sun.boot.library.path = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64</span><br><span class=\"line\">java.version = 1.8.0_242</span><br><span class=\"line\">java.util.logging.manager = org.apache.juli.ClassLoaderLogManager</span><br><span class=\"line\">user.timezone = Asia/Shanghai</span><br><span class=\"line\">sun.arch.data.model = 64</span><br><span class=\"line\">java.util.concurrent.ForkJoinPool.common.threadFactory = org.apache.catalina.startup.SafeForkJoinWorkerThreadFactory</span><br><span class=\"line\">java.endorsed.dirs = </span><br><span class=\"line\">sun.cpu.isalist = </span><br><span class=\"line\">sun.jnu.encoding = UTF-8</span><br><span class=\"line\">file.encoding.pkg = sun.io</span><br><span class=\"line\">package.access = sun.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.tomcat.</span><br><span class=\"line\">file.separator = /</span><br><span class=\"line\">java.specification.name = Java Platform API Specification</span><br><span class=\"line\">java.class.version = 52.0</span><br><span class=\"line\">user.country = US</span><br><span class=\"line\">java.home = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre</span><br><span class=\"line\">java.vm.info = mixed mode</span><br><span class=\"line\">os.version = 4.19.90-24.4.v2101.ky10.x86_64</span><br><span class=\"line\">sun.font.fontmanager = sun.awt.X11FontManager</span><br><span class=\"line\">path.separator = :</span><br><span class=\"line\">java.vm.version = 25.242-b08</span><br><span class=\"line\">jboss.i18n.generate-proxies = true</span><br><span class=\"line\">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class=\"line\">sun.io.unicode.encoding = UnicodeLittle</span><br><span class=\"line\">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class=\"line\">package.definition = sun.,java.,org.apache.catalina.,org.apache.coyote.,org.apache.jasper.,org.apache.naming.,org.apache.tomcat.</span><br><span class=\"line\">java.naming.factory.url.pkgs = org.apache.naming</span><br><span class=\"line\">mail.mime.splitlongparameters = false</span><br><span class=\"line\">java.security.egd = file:/dev/./urandom</span><br><span class=\"line\">user.home = /home/shterm</span><br><span class=\"line\">java.specification.vendor = Oracle Corporation</span><br><span class=\"line\">tomcat.util.scan.StandardJarScanFilter.jarsToSkip = activ*.jar,amqp-client.jar,annotations-api.jar,ant-junit*.jar,ant-launcher.jar,ant.jar,antlr.jar,aopalliance.jar,asm-*.jar,aspectj*.jar,bcp*.jar,bootstrap.jar,catalina-ant.jar,catalina-ha.jar,catalina-jmx-remote.jar,catalina-storeconfig.jar,catalina-tribes.jar,catalina-ws.jar,catalina.jar,cglib-*.jar,classmate.jar,cobertura-*.jar,commons-*.jar,compress-lzf.jar,curator-*.jar,db2-jdbc.jar,dom4j-*.jar,easymock-*.jar,ecj-*.jar,el-api.jar,elasticsearch.jar,geronimo-spec-jaxrpc*.jar,groovy-all.jar,guava.jar,h2*.jar,hamcrest-*.jar,hibernate*.jar,hppc.jar,http*.jar,icu4j-*.jar,itext*.jar,jackson-*.jar,jandex.jar,jasper-el.jar,jasper.jar,jasperreports*.jar,jaspic-api.jar,javamail.jar,javassist.jar,jaxb-*.jar,jaxen*.jar,jboss*.jar,jc*.jar,jdom-*.jar,jedis.jar,jetty-*.jar,jfreechart.jar,jgit.jar,jline.jar,jmx-tools.jar,jmx.jar,jna.jar,joda-time.jar,jr-*.jar,jsch.jar,json*.jar,jsoup.jar,jsp-api.jar,jsr166e.jar,jstl.jar,jta*.jar,junit-*.jar,junit.jar,liquibase-*.jar,log4j*.jar,lucene*.jar,mail*.jar,mariadb-jdbc.jar,mssql-jdbc.jar,mybatis.jar,netty.jar,nmap4j.jar,objenesis*.jar,olap4j.jar,opc*.jar,oracle-jdbc.jar,oraclepki.jar,oro-*.jar,poi*.jar,postgresql-jdbc.jar,quartz.jar,servlet-api-*.jar,servlet-api.jar,slf4j*.jar,snakeyaml.jar,snmp4j.jar,spring*.jar,sshd-core.jar,taglibs-standard-spec-*.jar,tagsoup-*.jar,t-digest.jar,tomcat-api.jar,tomcat-coyote.jar,tomcat-dbcp.jar,tomcat-i18n-*.jar,tomcat-jdbc.jar,tomcat-jni.jar,tomcat-juli-adapters.jar,tomcat-juli.jar,tomcat-util-scan.jar,tomcat-util.jar,tomcat-websocket.jar,tools.jar,validation-api.jar,velocypack.jar,websocket-api.jar,wl*.jar,wsdl4j*.jar,xercesImpl.jar,xml-apis.jar,xmlbeans.jar,xmlParserAPIs-*.jar,xmlParserAPIs.jar,xom-*.jar,xz.jar,zip4j.jar,zookeeper.jar</span><br><span class=\"line\">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class=\"line\">java.vendor.url = http://jdk.rnd.huawei.com/</span><br><span class=\"line\">java.vm.vendor = Huawei Technologies Co., Ltd</span><br><span class=\"line\">common.loader = &quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span><br><span class=\"line\">java.runtime.name = OpenJDK Runtime Environment</span><br><span class=\"line\">sun.java.command = org.apache.catalina.startup.Bootstrap start</span><br><span class=\"line\">java.class.path = /usr/share/tomcat/bin/bootstrap.jar:/usr/share/tomcat/bin/tomcat-juli.jar:/usr/lib/java/commons-daemon.jar</span><br><span class=\"line\">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class=\"line\">java.vm.specification.version = 1.8</span><br><span class=\"line\">catalina.home = /usr/share/tomcat</span><br><span class=\"line\">sun.cpu.endian = little</span><br><span class=\"line\">sun.os.patch.level = unknown</span><br><span class=\"line\">java.awt.headless = true</span><br><span class=\"line\">java.io.tmpdir = /var/cache/tomcat/temp</span><br><span class=\"line\">java.vendor.url.bug = http://jdk.rnd.huawei.com/</span><br><span class=\"line\">server.loader = </span><br><span class=\"line\">java.rmi.server.hostname = 127.0.0.1</span><br><span class=\"line\">jna.platform.library.path = /usr/lib64:/lib64:/usr/lib:/lib:/usr/lib64/tracker-miners-2.0:/usr/lib64/tracker-2.0:/usr/lib64/dyninst:/usr/libexec/sudo:/usr/lib64/sssd:/usr/pgsql-9.6/lib:/usr/lib64/perl5/CORE:/usr/lib64/opencryptoki:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/amd64/jli:/usr/lib64/bind9-export</span><br><span class=\"line\">os.arch = amd64</span><br><span class=\"line\">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class=\"line\">java.ext.dirs = /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class=\"line\">user.dir = /usr/share/tomcat</span><br><span class=\"line\">line.separator = </span><br><span class=\"line\"></span><br><span class=\"line\">java.vm.name = OpenJDK 64-Bit Server VM</span><br><span class=\"line\">log4j.configurationFile = /etc/tomcat/log4j2.xml</span><br><span class=\"line\">file.encoding = UTF-8</span><br><span class=\"line\">com.sun.jndi.ldap.object.disableEndpointIdentification = </span><br><span class=\"line\">java.specification.version = 1.8</span><br><span class=\"line\"></span><br><span class=\"line\">VM Flags:</span><br><span class=\"line\">Non-default VM flags: -XX:CICompilerCount=4 -XX:GCLogFileSize=20971520 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=null -XX:InitialHeapSize=243269632 -XX:MaxHeapSize=1610612736 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=80740352 -XX:NumberOfGCLogFiles=15 -XX:OldSize=162529280 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseGCLogFileRotation -XX:+UseParallelGC </span><br><span class=\"line\">Command line:  -Xmx1536m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/tomcat -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=15 -XX:GCLogFileSize=20m -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:/var/log/tomcat/tomcat-gc-%t.log -Dcom.sun.jndi.ldap.object.disableEndpointIdentification -Dcatalina.base=/usr/share/tomcat -Dcatalina.home=/usr/share/tomcat -Djava.endorsed.dirs= -Djava.io.tmpdir=/var/cache/tomcat/temp -Dlog4j.configurationFile=/etc/tomcat/log4j2.xml -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-jstat\"><a href=\"#3-jstat\" class=\"headerlink\" title=\"3.jstat\"></a>3.jstat</h2><p>命令参数说明：</p>\n<ul>\n<li>generalOptions：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：</li>\n<li>-help：显示帮助信息。</li>\n<li>-options：显示outputOptions参数的列表。</li>\n<li>outputOptions：输出选项，指定显示某一种Java虚拟机信息。</li>\n<li>-t：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。</li>\n<li>-h n：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。</li>\n<li>vmid：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。</li>\n<li>interval：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每隔这段时间显示一次统计信息。</li>\n<li>count：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。<br>输出选项<br>如果不指定通用选项（generalOptions），则可以指定输出选项（outputOptions）。输出选项决定jstat命令显示的内容和格式，具体如下：</li>\n<li>-class：显示类加载、卸载数量、总空间和装载耗时的统计信息。</li>\n<li>-compiler：显示即时编译的方法、耗时等信息。</li>\n<li>-gc：显示堆各个区域内存使用和垃圾回收的统计信息。</li>\n<li>-gccapacity：显示堆各个区域的容量及其对应的空间的统计信息。</li>\n<li>-gcutil：显示有关垃圾收集统计信息的摘要。</li>\n<li>-gccause：显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因。</li>\n<li>-gcnew：显示新生代的垃圾回收统计信息。</li>\n<li>-gcnewcapacity：显示新生代的大小及其对应的空间的统计信息。</li>\n<li>-gcold: 显示老年代和元空间的垃圾回收统计信息。</li>\n<li>-gcoldcapacity：显示老年代的大小统计信息。</li>\n<li>-gcmetacapacity：显示元空间的大小的统计信息。</li>\n<li>-printcompilation：显示即时编译方法的统计信息。</li>\n</ul>\n<h1 id=\"二、线程堆栈\"><a href=\"#二、线程堆栈\" class=\"headerlink\" title=\"二、线程堆栈\"></a>二、线程堆栈</h1><h2 id=\"1-输出\"><a href=\"#1-输出\" class=\"headerlink\" title=\"1.输出\"></a>1.输出</h2><p>Java虚拟机提供了线程转储(Thread dump)的后门，通过这个后门，可以将线程堆栈打印出来。这个后门就是通过向Java进程发送一个QUIT信号，Java虚拟机收到该信号之后，将系统当前的JAVA线程调用堆栈打印出来。</p>\n<p>打印方法：</p>\n<ul>\n<li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li>\n<li>kill -3<br><em><strong>同时请确保Java命令行中没有DISABLE_JAVADUMP运行选项</strong></em></li>\n</ul>\n<h2 id=\"2-线程分析\"><a href=\"#2-线程分析\" class=\"headerlink\" title=\"2.线程分析\"></a>2.线程分析</h2><p>通过输出堆栈进行分析 <code>jstack -l $(jps | grep xxx | awk &#39;&#123;print $1&#125;&#39;)</code> &gt; &#x2F;tmp&#x2F;xxx.jstack</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;SYS_STATUS_CHECKER&quot;</span> #<span class=\"number\">14</span> daemon prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e047bf000</span> nid=<span class=\"number\">0xe15</span> waiting on condition [<span class=\"number\">0x00007f5dd43d1000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">ru        at com.xxx.xxx.SystemStatusChecker.run(SystemStatusChecker.java:xx)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)        </span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"string\">&quot;RMI Reaper&quot;</span> #<span class=\"number\">39</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e04e4c800</span> nid=<span class=\"number\">0xf0b</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f5dae2c4000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)</span><br><span class=\"line\">        - waiting on &lt;<span class=\"number\">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">144</span>)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000c0c88d20</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">165</span>)</span><br><span class=\"line\">        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:<span class=\"number\">351</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"string\">&quot;main&quot;</span> #<span class=\"number\">1</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f5e0400a000</span> nid=<span class=\"number\">0xdcb</span> runnable [<span class=\"number\">0x00007f5e0b393000</span>]</span><br><span class=\"line\">    java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">        at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class=\"line\">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class=\"number\">409</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class=\"number\">545</span>)</span><br><span class=\"line\">        at java.net.ServerSocket.accept(ServerSocket.java:<span class=\"number\">513</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.await(CommonMain.java:<span class=\"number\">244</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.startup(CommonMain.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">        at com.xxx.common.xxx.main(CommonMain.java:<span class=\"number\">147</span>)</span><br><span class=\"line\">    Locked ownable synchronizers:</span><br><span class=\"line\">        - None</span><br></pre></td></tr></table></figure>\n<p>在RMI线程中可以看到 “ - locked &lt;0x00000000c0c88d20&gt; (a java.lang.ref.ReferenceQueue$Lock)” 表示该线程已经使用了ID为”0x00000000c0c88d2”的锁，锁的ID由系统自动产生</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot;  prio=5     os_prio=0          tid=0x00007f5e0400a000 nid=0xdcb      runnable [0x00007f5e0b393000]</span><br><span class=\"line\">|       |          |                  |                      |              |         |</span><br><span class=\"line\">线程名称 线程优先级   操作系统级别的优先级   线程id                 对应的本地线程ID  状态      线程占用内存地址</span><br></pre></td></tr></table></figure>\n\n<p>其中”线程对应的本地线程id号”所指的”本地线程”是指该Java线程所对应的虚拟机中的本地线程。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是 依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。</p>\n<p>Java代码 中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix&#x2F;Linux下，我们可以通 如下方式把Java虚拟机的本地线程打印出来：</p>\n<ul>\n<li>使用ps -ef | grep java 获得Java进程ID。</li>\n<li>使用pstack <java pid>获得Java虚拟机的本地线程的堆栈<br>其中本地线程各项含义如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread 56 (Thread 0x7f5e0b394700 (LWP 3531))</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|                 |                 +----本地线程id(另一种表示,LWP-light weight process)</span><br><span class=\"line\">|                 +-------------------本地线程id</span><br><span class=\"line\">+------------------------------线程名称</span><br></pre></td></tr></table></figure>\n而通过jstack输出的main本地线程ID为0xdcb，其10进制正好为3531。</li>\n</ul>\n<p>“runnable”表示当前线程处于运行状态。这个runnable状态是从虚拟机的角度来看的, 表示这个线程正在运行</p>\n<p><strong>⚠️ NOTE:</strong> 但是处于Runnable状态的线程不一定真的消耗CPU. 处于Runnable的线程只能说明该线程没有阻塞在java的wait或者sleep方法上，同时也没等待在锁上面。但是如果该线程调用了本地方法，而本地方法处于等待状态，这个时候虚拟机是不知道本地代码中发生 了什么（但操作系统是知道的，pstack就是操作提供的一个命令，它知道当前线程正在执行的本地代码上下文），此时尽管当前线程实际上也是阻塞的状态，但实际上显示出来的还是runnable状态， 这种情况下是不消耗CPU的</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 处于waittig和blocked状态的线程都不会消耗CPU </span><br><span class=\"line\">2. 线程频繁地挂起和唤醒需要消耗CPU, 而且代价颇大</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TIMED_WAITING(on object monitor) 表示当前线程被挂起一段时间,说明该线程正在 执行obj.wait(int time)方法.</li>\n<li>TIMED_WAITING(sleeping) 表示当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法. </li>\n<li>TIMED_WAITING(parking) 当前线程被挂起一段时间,即正在执行Thread.sleep(int time)方法.</li>\n<li>WAINTING(on object monitor) 当前线程被挂起，即正在执行obj.wait()方法(无参数的wait()方法).<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.</span><br><span class=\"line\">• 如果是纯Java运算代码，则消耗CPU.</span><br><span class=\"line\">• 如果是网络IO,很少消耗CPU.</span><br><span class=\"line\">• 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)， 如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消 耗CPU。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"三、相关的排查方法\"><a href=\"#三、相关的排查方法\" class=\"headerlink\" title=\"三、相关的排查方法\"></a>三、相关的排查方法</h1><h2 id=\"1-CPU\"><a href=\"#1-CPU\" class=\"headerlink\" title=\"1.CPU\"></a>1.CPU</h2><p>生产环境中往往会出现CPU飙高的情况，对于JAVA应用而言，此类问题相对较好确定问题方向。</p>\n<h3 id=\"1-1-使用jstack确定CPU占用高的线程\"><a href=\"#1-1-使用jstack确定CPU占用高的线程\" class=\"headerlink\" title=\"1.1 使用jstack确定CPU占用高的线程\\\"></a>1.1 使用jstack确定CPU占用高的线程\\</h3><p>通过<code>top</code>指令，可以看到进程占用的一些基础资源信息，然后“P”键可以按照CPU使用率进行排序，“M”键可以按照内存占用情况进行排序</p>\n<p>找到CPU占用高的进程pid，然后将jstack信息定向到一个文件中去，通过<code>top -Hp pid</code>查看具体的情况。</p>\n<p>通过 <code>printf &#39;%x\\n&#39; pid</code>将pid转换为16进制，然后在jstack文件中根据对应的数字进行查找，然后针对性的进行分析</p>\n<h3 id=\"1-2-频繁GC\"><a href=\"#1-2-频繁GC\" class=\"headerlink\" title=\"1.2 频繁GC\"></a>1.2 频繁GC</h3><p>有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，<code>S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU</code>分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。<code>YGC/YGT、FGC/FGCT、GCT</code>则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。<br><img src=\"/../images/gc.png\" alt=\"alt text\"></p>\n<h3 id=\"1-3-频繁上下文切换\"><a href=\"#1-3-频繁上下文切换\" class=\"headerlink\" title=\"1.3 频繁上下文切换\"></a>1.3 频繁上下文切换</h3><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看<br><img src=\"/../images/vmstat.png\" alt=\"alt text\"><br>cs(context switch)一列则代表了上下文切换的次数。</p>\n<p>如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。</p>\n<h2 id=\"2-内存\"><a href=\"#2-内存\" class=\"headerlink\" title=\"2.内存\"></a>2.内存</h2><p>对于JAVA应用，涉及到的内存问题主要包括OOM、GC问题和堆外内存。</p>\n<h3 id=\"2-1-OOM\"><a href=\"#2-1-OOM\" class=\"headerlink\" title=\"2.1 OOM\"></a>2.1 OOM</h3><p>JVM中的内存不足，OOM大致可以分为以下几种情况</p>\n<ul>\n<li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</code> 这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.confnofile</code>和<code>nproc</code>来增大os对线程的限制</li>\n<li><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space </code> 这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</li>\n<li><code>Caused by: java.lang.OutOfMemoryError: Meta space</code> 这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整</li>\n<li><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code> 表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。</li>\n</ul>\n<h3 id=\"2-2-GC问题\"><a href=\"#2-2-GC问题\" class=\"headerlink\" title=\"2.2 GC问题\"></a>2.2 GC问题</h3><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常等。</p>\n<p>线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code></p>\n<h3 id=\"2-3-堆外内存\"><a href=\"#2-3-堆外内存\" class=\"headerlink\" title=\"2.3 堆外内存\"></a>2.3 堆外内存</h3><p>JVM 的堆外内存主要包括：</p>\n<ul>\n<li>JVM 自身运行占用的空间；</li>\n<li>线程栈分配占用的系统内存；</li>\n<li>DirectByteBuffer 占用的内存；</li>\n<li>JNI 里分配的内存；</li>\n<li>Java 8 开始的元数据空间；</li>\n<li>NIO 缓存</li>\n<li>Unsafe 调用分配的内存；</li>\n<li>codecache</li>\n</ul>\n<p>冰山对象：冰山对象是指在 JVM 堆里占用的内存很小，但其实引用了一块很大的本地内存。DirectByteBuffer 和 线程都属于这类对象。</p>\n<h4 id=\"2-3-1NMT分析堆外内存\"><a href=\"#2-3-1NMT分析堆外内存\" class=\"headerlink\" title=\"2.3.1NMT分析堆外内存\"></a>2.3.1NMT分析堆外内存</h4><p>NMT（Native Memory Tracking）是 HotSpot JVM 引入的跟踪 JVM 内部使用的本地内存的一个特性，可以通过 jcmd 工具访问 NMT 数据。NMT 目前不支持跟踪第三方本地代码的内存分配和 JDK 类库。</p>\n<p>NMT 不跟踪非 JVM 代码的内存分配，本地代码里的内存泄露需要使用操作系统支持的工具来定位。</p>\n<h4 id=\"2-3-2-开启-NMT\"><a href=\"#2-3-2-开启-NMT\" class=\"headerlink\" title=\"2.3.2 开启 NMT\"></a>2.3.2 开启 NMT</h4><p>启用 NMT 会带来 5-10% 的性能损失。NMT 的内存使用率情况需要添加两个机器字 word 到 malloc 内存的 malloc 头里。NMT 内存使用率也被 NMT 跟踪。<br>启动命令： <code>-XX:NativeMemoryTracking=[off | summary | detail]</code>。</p>\n<ul>\n<li>off：NMT 默认是关闭的；</li>\n<li>summary：只收集子系统的内存使用的总计数据；</li>\n<li>detail：收集每个调用点的内存使用数据。</li>\n</ul>\n<h4 id=\"2-3-3-jcmd-访问-NMT-数据\"><a href=\"#2-3-3-jcmd-访问-NMT-数据\" class=\"headerlink\" title=\"2.3.3 jcmd 访问 NMT 数据\"></a>2.3.3 jcmd 访问 NMT 数据</h4><p>命令：<br><code>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</code></p>"},{"title":"线上故障排查方法和工具介绍","author":"baixiaozhou","description":"线上故障问题的排查方法和工具介绍，包括 CPU、内存、负载、磁盘、IO、网络等","date":"2024-08-15T03:12:21.000Z","references":["[Examining Load Average](https://www.linuxjournal.com/article/9001)","[What-is-CPU-Load-Average](https://community.tenable.com/s/article/What-is-CPU-Load-Average)"],"cover":"/images/server.jpg","banner":"/images/server.jpg","_content":"\n<!-- more -->\n\n- [写在前面](#写在前面)\n- [CPU使用率飙升](#cpu使用率飙升)\n  - [如何让CPU使用率飙升](#如何让cpu使用率飙升)\n  - [如何判断和发现CPU使用率飙升](#如何判断和发现cpu使用率飙升)\n  - [如何确定CPU飙升的根源](#如何确定cpu飙升的根源)\n    - [perf命令](#perf命令)\n    - [jstack](#jstack)\n    - [火焰图](#火焰图)\n- [负载飙升](#负载飙升)\n  - [负载的定义以及如何查看负载](#负载的定义以及如何查看负载)\n  - [如何让系统负载飙高](#如何让系统负载飙高)\n    - [纯计算任务对负载的影响](#纯计算任务对负载的影响)\n    - [磁盘 IO 对负载的影响](#磁盘-io-对负载的影响)\n    - [通过网络 IO 模拟 D 状态进程观察负载影响](#通过网络-io-模拟-d-状态进程观察负载影响)\n  - [负载飙升如何排查](#负载飙升如何排查)\n\n\n## 写在前面\n\n在很多文章中，每当提到去解决线上问题的时候，大部分的处理方式就是登录环境，哐哐各种敲命令。操作本身没什么问题，但是对于很多人而言，我觉得这种做法其实是本末倒置的，过于在乎去快速抓住重点问题，而忽略了从全局去看问题。那么如果最开始不去操作各种命令，那应该干什么呢？\n\n***看监控！！！！***\n\n首先不要觉得这个是废话，对于很多场景来说，业务规模是不断变化的，有的时候并发超过了极限的性能，那么这种情况下都没有必要去后台进行各种查询。举个简单的例子，假如说某套业务系统，本身只能支持 500 并发，现在实际上的量到了 2000，导致线上各种内存、CPU、负载的告警，这种情况下还有必要去后台敲`top`、`free`吗？答案当然是否定的，这种情况下，就需要考虑对业务系统进行快速的扩容等。\n\n看监控的意义在于尽可能的找到更多的性能瓶颈或者异常的点，从全局出发，对系统当前存在的问题和异常点有全面的了解。\n\n监控系统多种多样，从较早的 zabbix 到现在比较流行的prometheus+grafana（举两个常用的例子），对于系统业务都有比较完善的监控，可以帮助我们更加具体的了解到系统运行全貌。如果你对这些都不喜欢，那么你自己写一个监控系统也没什么问题。\n\n当我们看完监控之后（假设你真的看了），接下来进入实际操作环节，我会从这些指标的详细含义出发，然后尽可能地将各种处理方式分享给大家。\n\n## CPU使用率飙升\n\n### 如何让CPU使用率飙升\n\n这个问题其实很简单，只要有计算任务一直存在，让 CPU 一直处于繁忙之中，那么 CPU 必然飙升。我们可以通过一系列的工具去模拟这个情况。\n\n[github SysStress](https://github.com/baixiaozhou/SysStress) 这是我自己用 golang 写的压测工具(还在开发中，可以点个 star 让我更有动力😂)\n\n使用方法:\n```\n./sysstress cpu --cpu-number 10 --duration 10m\n```\n这个就是模拟占用 10 核心的 CPU 并持续 10min，当然大家也可以用其他的压测工具，比如`stress-ng`\n\n### 如何判断和发现CPU使用率飙升\n\n首先我们先看一下，跟 CPU 使用率相关的有哪些指标。我们通过 `top` 命令就可以看到具体的信息\n\n{% image /images/top.png top fancybox:true %}\n<!-- ![top](../images/top.png) -->\n这些输出中有一行是 `%Cpu(s)`, 这行展示了 CPU 的整体使用情况，是一个百分比的形式，我们详细阐述下这几个字段的含义\n```\nus, user    : time running un-niced user processes   未降低优先级的用户进程所占用的时间\nsy, system  : time running kernel processes          内核进程所占用的时间\nni, nice    : time running niced user processes      降低优先级的用户进程所占用的时间\nid, idle    : time spent in the kernel idle handler  空闲的时间\nwa, IO-wait : time waiting for I/O completion        等待 I/O 操作完成所花费的时间\nhi : time spent servicing hardware interrupts        处理硬件中断所花费的时间\nsi : time spent servicing software interrupts        处理软件中断所花费的时间\nst : time stolen from this vm by the hypervisor      被虚拟机管理程序从此虚拟机中窃取的时间\n```\n在这些指标中，一般关注的比较多的就是 us、sy、id、wa（其他几个指标很高的情况我个人目前基本上没有遇到过）\n\n上述指标反映了系统整体的 CPU 情况。而程序在操作系统中实际上是以一个个的进程存在的，那我们如何确定到占用 CPU 高的进程呢？让我们的目光从 top 的头部信息往下移动，下面就展示了详细的进程信息\n{% image /images/top-process.png top-process fancybox:true %}\n<!-- ![top-process](../images/top-process.png) -->\n\n这些程序默认是按照 CPU 的使用率从高到底进行排序的，当然你也可以通过在`top`的时候输入`P`进行排序，这样我们就可以看到系统中消耗 CPU 资源的详细进程信息\n\n上面是我通过 `./sysstress cpu --cpu-number 10 --duration 10m` 压测程序跑出来的，可以看到这里的 sysstress 程序占用了 1002 的 %CPU，也就是说基本上是 10 个核心，那我们跑一个更高的，将`--cpu-number`加到 60 看看发生了什么\n<!-- ![stress-cpu](../images/stress-cpu.png) -->\n{% image /images/stress-cpu.png stress-cpu fancybox:true %}\n\n我们可以看到这次%CPU打到了 6000，那很多人就好奇我日常的程序跑到多高算高呢？\n\n这里我们需要明确一点，现在的服务器绝大部分都是多核心 CPU（1C2G这种自己用来玩的忽略），CPU 的核心数决定了我们程序在同一时间能够执行多少个线程，也就是说，这个高不高是相对于机器配置而言的。如果你的机器只有 16C，那么单个进程占用的 %CPU 到 1000，那么其实已经算是比较高了。如果是 256C 的CPU（土豪级配置），那么单个进程占用的 %CPU 到 6000，对于系统的稳定性影响就没有那么大了。\n\n上述我们说的情况是进程占用 CPU 对整个系统的影响，那么进程占用的 CPU 对系统的影响不大就代表这个程序一定没有问题吗？答案显然是未必的。\n\n我们还是要回归到业务本身，如果进程的 CPU 占用在业务变动不大的情况下，发生了异常波动，或者正常情况下业务不会消耗这么高的 CPU，那么我们就需要继续排查了。\n\n### 如何确定CPU飙升的根源\n这个问题的 核心是 CPU 上在运行什么东西。 多核心CPU 下，每个核心都可以执行不同的程序，我们如何确定一个进程中那些方法在消耗 CPU 呢？从而引申下面详细的问题:\n 1. 程序的调用栈是什么样的？\n 2. 调用栈信息中哪些是需要关注的，那些是可以忽略的？\n 3. 热点函数是什么？\n\n老话说得好，\"工欲善其事，必先利其器\", 我们需要这些东西，就必须了解到什么样的工具可以拿到上面我提到的一些信息。接下来我将通过常用的后端语言：`golang` 和 `java` 为例构造一些高 CPU 的程序来进行展示。\n\n#### perf命令\n**perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。**\n\n安装:\n```\nyum install perf   #Centos\n```\n安装完成后，我们可以首先看下 `perf`的用法，这里不展开具体用法，只列出我平常使用的几个命令:\n```\ntop        System profiling tool.               #对系统性能进行实时分析。\nrecord     Run a command and record its profile into perf.data     #收集采样信息\nreport     Read perf.data (created by perf record) and display the profile  #分析采样信息，和record配合使用\n```\nrecord 和 report 的使用更多在于 dump 当前环境的信息用于后续分析，如果在自己环境上测试，可以用 top 进行一些简单的实时分析（类似于 top 命令）。\n\n还是用之前的压测工具，我们模拟一个 10 核心的 10min 的压测场景\n```\nnohup ./sysstress cpu --cpu-number 10 --duration 10m > /dev/null 2>&1 &\n```\n执行这个语句，让压测程序在后台执行，然后我们通过`perf top`查看具体的情况（可以通过-p 指定 pid）\n\n{% image /images/perftop.png perf top, fancybox:true %}\n<!-- ![perf top](../images/perftop.png) -->\n\n从截图的信息中我们可以看到占用资源最多的一些方法，包括 sysstress 进程的各种方法(从图片中基本上就可以确定高消耗的方法在哪里)以及底层的 `__vdso_clock_gettime`, 那再结合压测工具的代码分析下:\n\n``` golang\nfunc burnCpu(wg *sync.WaitGroup, start time.Time, durSec int64) {\n\tdefer wg.Done()\n\tfor {\n\t\t_ = 1 * 1\n\t\tnow := time.Now()\n\t\tif now.Sub(start) > time.Duration(durSec)*time.Second {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n这是方法的核心，其实就是做无意义的计算，外加时间的判断，超过 duration 就结束。这样和上面的 perf top 信息就能对应起来。\n\n然后我们用 java 写一个同样的程序，再看看 `perf top`的情况:\n{% image /images/javaperftop.png perf top, fancybox:true %}\n<!-- ![perf top](../images/javaperftop.png) -->\n从这一大段显示来看，是不是看的一脸懵逼，很难发现到底是什么程序在占用CPU 资源。大家可以看一下源程序:\n``` java\nimport java.time.LocalDateTime;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n = 10;\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        Math.sin(Math.random());\n                        LocalDateTime currentTime = LocalDateTime.now();\n                    }\n                }\n            }).start();\n        }\n    }\n}\n```\n这里的程序也是非常简单，启动 10 个线程，做一个无意义的数学运算，然后获取当前时间。从这段代码中是不是很难和上面`perf top`的显示关联起来？ 原因也非常简单， 像Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。那我们好能通过 perf 去看到 java 相关的堆栈吗？答案是可以的。\n\n可以借助 [perf-map-agent](https://github.com/jvm-profiling-tools/perf-map-agent) 这样的开源工具，去生成和`perf` 工具一起使用的方法映射，但是需要做额外的一些配置。这里的方法大家可以自己探究，为什么不详细的讲这个呢，原因也简单，排查问题的工具多种多样，没必要在一棵树上吊死。\n\n#### jstack\n\n既然 perf top 去查看 JAVA 的调用栈不太方便，我们就直接上 java 提供的 jstack 工具去分析。\n- jstack -l pid > xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式\n- kill -3， jstack 用不了的情况下可以使用 kill -3 pid 的形式，堆栈会输出在系统日志中。\n\n具体的操作步骤:\n1. `top -Hp $pid` 找到占用 CPU 的具体线程\n2. `jstack -l $pid > /tmp/$pid.jstack` 或者 `kill -3 $pid`将 java 进程的堆栈情况输出的日志中，然后根据 `top -Hp` 看到的线程信息在输出的堆栈日志中进行查找（`top -Hp` 输出的是 10 进制的 id，`jstack` 输出的是 16 进制的，在查找时注意进制转换）\n\n我们看下上面 java 程序的堆栈的信息:\n``` Lua\n2024-08-16 15:15:40\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):\n\n\"Attach Listener\" #35 daemon prio=9 os_prio=0 tid=0x00007f52b4001000 nid=0x71f4 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"DestroyJavaVM\" #34 prio=5 os_prio=0 tid=0x00007f53e0009800 nid=0x1693 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Thread-1\" #25 prio=5 os_prio=0 tid=0x00007f53e015a800 nid=0x16d9 runnable [0x00007f52f64e3000]\n   java.lang.Thread.State: RUNNABLE\n\tat sun.misc.Unsafe.getObjectVolatile(Native Method)\n\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:755)\n\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:938)\n\tat java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:267)\n\tat java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)\n\tat java.time.ZoneRegion.ofId(ZoneRegion.java:120)\n\tat java.time.ZoneId.of(ZoneId.java:411)\n\tat java.time.ZoneId.of(ZoneId.java:359)\n\tat java.time.ZoneId.of(ZoneId.java:315)\n\tat java.util.TimeZone.toZoneId(TimeZone.java:556)\n\tat java.time.ZoneId.systemDefault(ZoneId.java:274)\n\tat java.time.Clock.systemDefaultZone(Clock.java:178)\n\tat java.time.LocalDateTime.now(LocalDateTime.java:180)\n\tat Main$1.run(Main.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Thread-0\" #24 prio=5 os_prio=0 tid=0x00007f53e0159000 nid=0x16d8 runnable [0x00007f52f65e4000]\n   java.lang.Thread.State: RUNNABLE\n\tat sun.misc.Unsafe.getObjectVolatile(Native Method)\n\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:755)\n\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:938)\n\tat java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:267)\n\tat java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)\n\tat java.time.ZoneRegion.ofId(ZoneRegion.java:120)\n\tat java.time.ZoneId.of(ZoneId.java:411)\n\tat java.time.ZoneId.of(ZoneId.java:359)\n\tat java.time.ZoneId.of(ZoneId.java:315)\n\tat java.util.TimeZone.toZoneId(TimeZone.java:556)\n\tat java.time.ZoneId.systemDefault(ZoneId.java:274)\n\tat java.time.Clock.systemDefaultZone(Clock.java:178)\n\tat java.time.LocalDateTime.now(LocalDateTime.java:180)\n\tat Main$1.run(Main.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n\n   Locked ownable synchronizers:\n\t- None\n --- 10 个 thread\n\n\"Service Thread\" #23 daemon prio=9 os_prio=0 tid=0x00007f53e0143800 nid=0x16d6 runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"C2 CompilerThread1\" #6 daemon prio=9 os_prio=0 tid=0x00007f53e010e000 nid=0x16c5 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n --- 一大堆 C2 CompilerThread\n\n\"C2 CompilerThread0\" #5 daemon prio=9 os_prio=0 tid=0x00007f53e010b000 nid=0x16c4 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Signal Dispatcher\" #4 daemon prio=9 os_prio=0 tid=0x00007f53e0109800 nid=0x16c3 runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Finalizer\" #3 daemon prio=8 os_prio=0 tid=0x00007f53e00d8800 nid=0x16c2 in Object.wait() [0x00007f52f7bfa000]\n   java.lang.Thread.State: WAITING (on object monitor)\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x000000008021a5e8> (a java.lang.ref.ReferenceQueue$Lock)\n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)\n\t- locked <0x000000008021a5e8> (a java.lang.ref.ReferenceQueue$Lock)\n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)\n\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Reference Handler\" #2 daemon prio=10 os_prio=0 tid=0x00007f53e00d3800 nid=0x16c1 in Object.wait() [0x00007f52f7cfb000]\n   java.lang.Thread.State: WAITING (on object monitor)\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x0000000080218d38> (a java.lang.ref.Reference$Lock)\n\tat java.lang.Object.wait(Object.java:502)\n\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n\t- locked <0x0000000080218d38> (a java.lang.ref.Reference$Lock)\n\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"VM Thread\" os_prio=0 tid=0x00007f53e00ca000 nid=0x16c0 runnable\n\n\"GC task thread#0 (ParallelGC)\" os_prio=0 tid=0x00007f53e001f000 nid=0x1694 runnable\n\n--- 一大堆 GC task thread\n\n\"VM Periodic Task Thread\" os_prio=0 tid=0x00007f53e0146000 nid=0x16d7 waiting on condition\n\nJNI global references: 202\n```\n我们通过 top -Hp 的信息就可以快速定位到 Thread-[0-9] 这几个线程，而每个线程的调用栈都是 `java.time.LocalDateTime.now`, 也说明了这个方法在不停消耗 CPU。（但是 jstack 只能捕获短时间或者瞬时的堆栈信息，没法处理长时间的，所以我们在获取时可以多打印几次或者使用其他方法）\n\n至于 jstack 的详细用法，请参考我的另一篇博客：[java问题定位](https://baixiaozhou.github.io/2024/08/13/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/)\n\n除此之外，还有非常多的分析工具，pstack\\gstack\\strace\\gdb等等，大家可以自行探索使用\n\n#### 火焰图\n\n上面我们介绍了很多操作的命令和方法，那么有没有一种比较直观的方式能够直接看到各种方法执行的耗时比重等情况呢？火焰图就是为了解决这种情况而生的。\n\n火焰图的分类有很多，常用的包括:\n1. CPU 火焰图 (CPU Flame Graph)\n\t-\t描述：展示 CPU 在不同方法上的消耗情况，显示每个方法调用所占用的 CPU 时间。\n\t-\t用途：用于分析 CPU 性能瓶颈，识别哪些方法消耗了最多的 CPU 资源。\n\t-\t应用：Java、C++ 等多种编程语言的性能分析。\n2. 内存火焰图 (Memory Flame Graph)\n\t- 描述：展示内存分配情况，显示每个方法调用分配的内存量。\n    - 用途：用于检测内存泄漏、过度内存分配问题，帮助优化内存使用。\n\t- 应用：常用于分析内存密集型应用，如 Java 应用的堆内存分析。\n3. I/O 火焰图 (I/O Flame Graph)\n\t-\t描述：展示 I/O 操作的耗时情况，显示不同方法的 I/O 操作占用的时间。\n\t-\t用途：用于分析应用程序的 I/O 性能，识别慢速或频繁的 I/O 操作。\n\t-\t应用：数据库查询、文件系统操作、网络通信等场景的性能调优。\n\n我们这里通过 [async-profiler](https://github.com/async-profiler/async-profiler) 对文章上面的java压测程序进行抓取(这个工具只能抓 java 的)\n\n```\ntar -xzf async-profiler-3.0-linux-x64.tar.gz\ncd async-profiler-3.0-linux-x64/bin\n./asprof -d 60 pid -f /tmp/javastress.html\n```\n我们用浏览器打开生成的 html 文件，可以看到如下的火焰图信息（可以在网页进行点击，查看更细节的方法）\n{% image /images/javafire.png java 程序的火焰图, fancybox:true %}\n<!-- ![java 程序的火焰图](../images/javafire.png) -->\n\n这样看起来就比 jstack这些信息更加直观一点。\n\n## 负载飙升\n\n### 负载的定义以及如何查看负载\n\n我们先看下系统负载的官方描述:\n```\nSystem load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in arunnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access,eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs ina  system,  so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.\n```\n\n系统负载平均值表示处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。处于不可中断状态的进程正在等待某些 I/O 访问，例如等待磁盘。这里的核心概念就是 loadavg 这个数值体现了某些特定状态进程的数量。\n\n那引申出两个问题:\n1. 进程的状态有哪些？ 如何在 Linux 上查看进程状态\n2. 可运行和不可中断状态的进程具体含义是什么\n\n查看的方式，我们可以通过 ps 命令进行查看，比如通过`ps -auxf`, 我么可以看到有一列为 `STAT`,这列就代表该进程的状态:\n\n{% image /images/psauxf.png 进程状态 fancybox:true %}\n\n进程的状态和具体含义:\n- D    uninterruptible sleep (usually IO)\n- R    running or runnable (on run queue)\n- S    interruptible sleep (waiting for an event to complete)\n- T    stopped by job control signal\n- t    stopped by debugger during the tracing\n- W    paging (not valid since the 2.6.xx kernel)\n- X    dead (should never be seen) \n- Z    defunct (\"zombie\") process, terminated but not reaped by its parent\n\n这里我们看到处于不可中断的状态的进程和正在运行的进程分别为 `D` 和 `R`,换个说法，也就是说造成负载升高的原因也就是这两个状态的进程引起的。\n\n（插个题外话，按照官方的说法，X 状态的进程应该是不应该被看到的， 但是之前在腾讯云做ES的时候，偶然间碰到了一次，当时还截了个图用做留念😂，但是没有捕获到具体的信息）\n\n负载的指标可以通过 `top` 以及 `uptime` 指令获取\n```\n23:35:00 up 1 day, 46 min,  1 user,  load average: 49.16, 18.35, 7.87\n```\n这里展示了 loadavg 的三个数值: 分别代表的含义是 1min、5min、15min 的系统平均负载\n\n那我们如何判断系统的负载是高是低呢？\n\n这里一般有个经验值，我们一般和 CPU 和核心数进行对比，一般负载在 CPU 核心的 70% 左右以及以下，对系统一般没什么影响，超过 70%，系统可能收到影响。但是这里还需要注意的一点就是，负载的比例在 70% 以下时不一定代表系统就没问题，举个简单的例子，如果一个系统上基本上没有业务在运行，那么负载基本上就在零点几左右，那么这种情况下，负载有升高不一定是合理的（后面举一个简单的例子）\n\n### 如何让系统负载飙高\n\n#### 纯计算任务对负载的影响\n\n既然说正在运行的进程会引起负载的变化，那么跑一些程序，让程序不停运行，那么自然而然就能构造出持续运行的进程了。\n我这里找了三台机器(64C)，用我的压测工具先跑一些纯 CPU 的运算，然后观察下效果：\n\n测试分为三组，测试前关闭不必要的服务和进程:\n1. 10 并发 30min\n   -  `nohup ./sysstress cpu --cpu-number 10 --duration 30m > /dev/null 2>&1`\n2. 30 并发 30min\n   - `nohup ./sysstress cpu --cpu-number 30 --duration 30m > /dev/null 2>&1`\n3. 60 并发 30min\n   - `nohup ./sysstress cpu --cpu-number 60 --duration 30m > /dev/null 2>&1`\n\n效果如下:\n{% image /images/load10.png 10并发负载, fancybox:true %}\n{% image /images/load30.png 30并发负载, fancybox:true %}\n{% image /images/load60.png 60并发负载, fancybox:true %}\n<!-- ![10并发负载](../images/load10.png)\n![30并发负载](../images/load30.png)\n![60并发负载](../images/load60.png) -->\n\n从上述测试过程中，我们可以发现，在纯运算这种场景下，并发的量基本上和负载是对应的。也就是说随着 CPU的使用量 上涨，负载也会不断变高。\n\n#### 磁盘 IO 对负载的影响\n\n在刚才的例子中，我们看到了纯运算对负载的影响（R 进程的代表），然后在关于 D 进程的说明中，我们可以看到有一个比较明显的说明 `(usually IO)` ,即通常是 IO 引起的，那么接下来我们通过磁盘 IO 来测试一下\n\n测试分为三组，测试前关闭不必要的服务和进程:\n1. 10 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 10 -d 15m > /dev/null 2>&1 &`\n2. 30 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 30 -d 15m > /dev/null 2>&1 &`\n3. 60 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 60 -d 15m > /dev/null 2>&1 &`\n\n效果如下:\n\n{% image /images/ioload10.png 10并发负载 fancybox:true %}\n{% image /images/ioload30.png 30并发负载 fancybox:true %}\n{% image /images/ioload60.png 60并发负载 fancybox:true %}\n\n我们也顺便看一下，60 并发下 CPU 的情况:\n\n{% image /images/io60c.png 60并发系统整体情况 fancybox:true %}\n\n这里我们可以观察到，系统的 CPU 基本上已经跑满了。us 和 sy 都占的比较多，但是这种读取非常有可能走到缓存中，我们想测绕过缓存，可以通过 DIRECT 的方式。\n\n但是上面的例子其实也证明了一件事，IO 的操作也是会导致负载产生飙升。\n\n那么问题来了，磁盘IO 和 CPU 操作都会导致系统负载飙升，那么负载飙升一定会是这两个原因吗？答案也是未必的，因为上述我们曾经提到过 D 状态的进程，到目前为止我们好像还没介绍过，那么我们来继续模拟，既然 D 状态的进程是 IO 操作引起的，普通的磁盘读写 IO 很难模拟，那我们就换个 IO 场景继续模拟 -- 网络 IO。\n\n#### 通过网络 IO 模拟 D 状态进程观察负载影响\n\n这里直接上一个模拟方法:\n- A 机器开启 NFS Server\n- B 机器作为客户端进行挂载\n- 断开网络\n- 疯狂 df -h\n\n详细的操作步骤:\n```\n# 安装 Centos\nsudo yum install nfs-utils\n\n# 服务端配置\nsudo mkdir -p /mnt/nfs_share\nsudo chown nobody:nogroup /mnt/nfs_share\nsudo chmod 755 /mnt/nfs_share\n## 打开 /etc/exports 配置，添加一行来定义共享目录及其权限。例如，将 /mnt/nfs_share 共享给网络 192.168.1.0/24，并提供读写权限：\n/mnt/nfs_share 192.168.1.0/24(rw,sync,no_subtree_check)\n\n## 启动 NFS\nsudo exportfs -a\nsudo systemctl restart nfs-kernel-server\nsudo systemctl enable nfs-kernel-server\n\n# 客户端配置\nsudo mkdir -p /mnt/nfs_client\nsudo mount -t nfs 192.168.1.100(server ip):/mnt/nfs_share /mnt/nfs_client\n## 验证\ndf -h /mnt/nfs_client\n\n# 断网模拟(客户端)\niptables -I INPUT -s serverip -j DROP\n\n# 持续(疯狂)执行：\ndu -sh /mnt/nfs_client\n```\n因为网络已经断掉，所以`du -sh /mnt/nfs_client`,而且这个程序没有自动退出或者报错，这样就导致程序无法顺利执行下去，继而阻塞住就变成了 D 状态的进程。\n\n基于这种模拟方法大家可以自行测试下，笔者之前做过一个场景，将一个两核心的 CPU负载干到了 200 多，但是因为**这种情况下更多是阻塞在网络中，所以此时的负载虽高，并不一定影响系统运行**。\n\n当然这只是其中一个例子，笔者曾经也因为见过 ping 操作阻塞导致的负载飙升，所以这种场景是多种多样的😂，大家有更多的例子也可以在下方留言，共同学习进步。\n\n\n### 负载飙升如何排查\n基于上面的例子和场景模拟，我们其实应该已经有一套基本的排查方法了，下面这张图是我个人的一些总结(图还会不断完善)\n\n{% image /images/loadhigh.png  负载高排查导图 fancybox:true %}\n","source":"_posts/线上问题排查方法汇总.md","raw":"---\ntitle: 线上故障排查方法和工具介绍\nauthor: baixiaozhou\ncategories:\n  - 问题排查\ntags:\n  - Linux\n  - Java\n  - Golang\n  - commands\ndescription: 线上故障问题的排查方法和工具介绍，包括 CPU、内存、负载、磁盘、IO、网络等\ndate: 2024-08-15 11:12:21\nreferences:\n  - '[Examining Load Average](https://www.linuxjournal.com/article/9001)'\n  - '[What-is-CPU-Load-Average](https://community.tenable.com/s/article/What-is-CPU-Load-Average)'\ncover: /images/server.jpg\nbanner: /images/server.jpg\n---\n\n<!-- more -->\n\n- [写在前面](#写在前面)\n- [CPU使用率飙升](#cpu使用率飙升)\n  - [如何让CPU使用率飙升](#如何让cpu使用率飙升)\n  - [如何判断和发现CPU使用率飙升](#如何判断和发现cpu使用率飙升)\n  - [如何确定CPU飙升的根源](#如何确定cpu飙升的根源)\n    - [perf命令](#perf命令)\n    - [jstack](#jstack)\n    - [火焰图](#火焰图)\n- [负载飙升](#负载飙升)\n  - [负载的定义以及如何查看负载](#负载的定义以及如何查看负载)\n  - [如何让系统负载飙高](#如何让系统负载飙高)\n    - [纯计算任务对负载的影响](#纯计算任务对负载的影响)\n    - [磁盘 IO 对负载的影响](#磁盘-io-对负载的影响)\n    - [通过网络 IO 模拟 D 状态进程观察负载影响](#通过网络-io-模拟-d-状态进程观察负载影响)\n  - [负载飙升如何排查](#负载飙升如何排查)\n\n\n## 写在前面\n\n在很多文章中，每当提到去解决线上问题的时候，大部分的处理方式就是登录环境，哐哐各种敲命令。操作本身没什么问题，但是对于很多人而言，我觉得这种做法其实是本末倒置的，过于在乎去快速抓住重点问题，而忽略了从全局去看问题。那么如果最开始不去操作各种命令，那应该干什么呢？\n\n***看监控！！！！***\n\n首先不要觉得这个是废话，对于很多场景来说，业务规模是不断变化的，有的时候并发超过了极限的性能，那么这种情况下都没有必要去后台进行各种查询。举个简单的例子，假如说某套业务系统，本身只能支持 500 并发，现在实际上的量到了 2000，导致线上各种内存、CPU、负载的告警，这种情况下还有必要去后台敲`top`、`free`吗？答案当然是否定的，这种情况下，就需要考虑对业务系统进行快速的扩容等。\n\n看监控的意义在于尽可能的找到更多的性能瓶颈或者异常的点，从全局出发，对系统当前存在的问题和异常点有全面的了解。\n\n监控系统多种多样，从较早的 zabbix 到现在比较流行的prometheus+grafana（举两个常用的例子），对于系统业务都有比较完善的监控，可以帮助我们更加具体的了解到系统运行全貌。如果你对这些都不喜欢，那么你自己写一个监控系统也没什么问题。\n\n当我们看完监控之后（假设你真的看了），接下来进入实际操作环节，我会从这些指标的详细含义出发，然后尽可能地将各种处理方式分享给大家。\n\n## CPU使用率飙升\n\n### 如何让CPU使用率飙升\n\n这个问题其实很简单，只要有计算任务一直存在，让 CPU 一直处于繁忙之中，那么 CPU 必然飙升。我们可以通过一系列的工具去模拟这个情况。\n\n[github SysStress](https://github.com/baixiaozhou/SysStress) 这是我自己用 golang 写的压测工具(还在开发中，可以点个 star 让我更有动力😂)\n\n使用方法:\n```\n./sysstress cpu --cpu-number 10 --duration 10m\n```\n这个就是模拟占用 10 核心的 CPU 并持续 10min，当然大家也可以用其他的压测工具，比如`stress-ng`\n\n### 如何判断和发现CPU使用率飙升\n\n首先我们先看一下，跟 CPU 使用率相关的有哪些指标。我们通过 `top` 命令就可以看到具体的信息\n\n{% image /images/top.png top fancybox:true %}\n<!-- ![top](../images/top.png) -->\n这些输出中有一行是 `%Cpu(s)`, 这行展示了 CPU 的整体使用情况，是一个百分比的形式，我们详细阐述下这几个字段的含义\n```\nus, user    : time running un-niced user processes   未降低优先级的用户进程所占用的时间\nsy, system  : time running kernel processes          内核进程所占用的时间\nni, nice    : time running niced user processes      降低优先级的用户进程所占用的时间\nid, idle    : time spent in the kernel idle handler  空闲的时间\nwa, IO-wait : time waiting for I/O completion        等待 I/O 操作完成所花费的时间\nhi : time spent servicing hardware interrupts        处理硬件中断所花费的时间\nsi : time spent servicing software interrupts        处理软件中断所花费的时间\nst : time stolen from this vm by the hypervisor      被虚拟机管理程序从此虚拟机中窃取的时间\n```\n在这些指标中，一般关注的比较多的就是 us、sy、id、wa（其他几个指标很高的情况我个人目前基本上没有遇到过）\n\n上述指标反映了系统整体的 CPU 情况。而程序在操作系统中实际上是以一个个的进程存在的，那我们如何确定到占用 CPU 高的进程呢？让我们的目光从 top 的头部信息往下移动，下面就展示了详细的进程信息\n{% image /images/top-process.png top-process fancybox:true %}\n<!-- ![top-process](../images/top-process.png) -->\n\n这些程序默认是按照 CPU 的使用率从高到底进行排序的，当然你也可以通过在`top`的时候输入`P`进行排序，这样我们就可以看到系统中消耗 CPU 资源的详细进程信息\n\n上面是我通过 `./sysstress cpu --cpu-number 10 --duration 10m` 压测程序跑出来的，可以看到这里的 sysstress 程序占用了 1002 的 %CPU，也就是说基本上是 10 个核心，那我们跑一个更高的，将`--cpu-number`加到 60 看看发生了什么\n<!-- ![stress-cpu](../images/stress-cpu.png) -->\n{% image /images/stress-cpu.png stress-cpu fancybox:true %}\n\n我们可以看到这次%CPU打到了 6000，那很多人就好奇我日常的程序跑到多高算高呢？\n\n这里我们需要明确一点，现在的服务器绝大部分都是多核心 CPU（1C2G这种自己用来玩的忽略），CPU 的核心数决定了我们程序在同一时间能够执行多少个线程，也就是说，这个高不高是相对于机器配置而言的。如果你的机器只有 16C，那么单个进程占用的 %CPU 到 1000，那么其实已经算是比较高了。如果是 256C 的CPU（土豪级配置），那么单个进程占用的 %CPU 到 6000，对于系统的稳定性影响就没有那么大了。\n\n上述我们说的情况是进程占用 CPU 对整个系统的影响，那么进程占用的 CPU 对系统的影响不大就代表这个程序一定没有问题吗？答案显然是未必的。\n\n我们还是要回归到业务本身，如果进程的 CPU 占用在业务变动不大的情况下，发生了异常波动，或者正常情况下业务不会消耗这么高的 CPU，那么我们就需要继续排查了。\n\n### 如何确定CPU飙升的根源\n这个问题的 核心是 CPU 上在运行什么东西。 多核心CPU 下，每个核心都可以执行不同的程序，我们如何确定一个进程中那些方法在消耗 CPU 呢？从而引申下面详细的问题:\n 1. 程序的调用栈是什么样的？\n 2. 调用栈信息中哪些是需要关注的，那些是可以忽略的？\n 3. 热点函数是什么？\n\n老话说得好，\"工欲善其事，必先利其器\", 我们需要这些东西，就必须了解到什么样的工具可以拿到上面我提到的一些信息。接下来我将通过常用的后端语言：`golang` 和 `java` 为例构造一些高 CPU 的程序来进行展示。\n\n#### perf命令\n**perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。**\n\n安装:\n```\nyum install perf   #Centos\n```\n安装完成后，我们可以首先看下 `perf`的用法，这里不展开具体用法，只列出我平常使用的几个命令:\n```\ntop        System profiling tool.               #对系统性能进行实时分析。\nrecord     Run a command and record its profile into perf.data     #收集采样信息\nreport     Read perf.data (created by perf record) and display the profile  #分析采样信息，和record配合使用\n```\nrecord 和 report 的使用更多在于 dump 当前环境的信息用于后续分析，如果在自己环境上测试，可以用 top 进行一些简单的实时分析（类似于 top 命令）。\n\n还是用之前的压测工具，我们模拟一个 10 核心的 10min 的压测场景\n```\nnohup ./sysstress cpu --cpu-number 10 --duration 10m > /dev/null 2>&1 &\n```\n执行这个语句，让压测程序在后台执行，然后我们通过`perf top`查看具体的情况（可以通过-p 指定 pid）\n\n{% image /images/perftop.png perf top, fancybox:true %}\n<!-- ![perf top](../images/perftop.png) -->\n\n从截图的信息中我们可以看到占用资源最多的一些方法，包括 sysstress 进程的各种方法(从图片中基本上就可以确定高消耗的方法在哪里)以及底层的 `__vdso_clock_gettime`, 那再结合压测工具的代码分析下:\n\n``` golang\nfunc burnCpu(wg *sync.WaitGroup, start time.Time, durSec int64) {\n\tdefer wg.Done()\n\tfor {\n\t\t_ = 1 * 1\n\t\tnow := time.Now()\n\t\tif now.Sub(start) > time.Duration(durSec)*time.Second {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n这是方法的核心，其实就是做无意义的计算，外加时间的判断，超过 duration 就结束。这样和上面的 perf top 信息就能对应起来。\n\n然后我们用 java 写一个同样的程序，再看看 `perf top`的情况:\n{% image /images/javaperftop.png perf top, fancybox:true %}\n<!-- ![perf top](../images/javaperftop.png) -->\n从这一大段显示来看，是不是看的一脸懵逼，很难发现到底是什么程序在占用CPU 资源。大家可以看一下源程序:\n``` java\nimport java.time.LocalDateTime;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n = 10;\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                public void run() {\n                    while (true) {\n                        Math.sin(Math.random());\n                        LocalDateTime currentTime = LocalDateTime.now();\n                    }\n                }\n            }).start();\n        }\n    }\n}\n```\n这里的程序也是非常简单，启动 10 个线程，做一个无意义的数学运算，然后获取当前时间。从这段代码中是不是很难和上面`perf top`的显示关联起来？ 原因也非常简单， 像Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。那我们好能通过 perf 去看到 java 相关的堆栈吗？答案是可以的。\n\n可以借助 [perf-map-agent](https://github.com/jvm-profiling-tools/perf-map-agent) 这样的开源工具，去生成和`perf` 工具一起使用的方法映射，但是需要做额外的一些配置。这里的方法大家可以自己探究，为什么不详细的讲这个呢，原因也简单，排查问题的工具多种多样，没必要在一棵树上吊死。\n\n#### jstack\n\n既然 perf top 去查看 JAVA 的调用栈不太方便，我们就直接上 java 提供的 jstack 工具去分析。\n- jstack -l pid > xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式\n- kill -3， jstack 用不了的情况下可以使用 kill -3 pid 的形式，堆栈会输出在系统日志中。\n\n具体的操作步骤:\n1. `top -Hp $pid` 找到占用 CPU 的具体线程\n2. `jstack -l $pid > /tmp/$pid.jstack` 或者 `kill -3 $pid`将 java 进程的堆栈情况输出的日志中，然后根据 `top -Hp` 看到的线程信息在输出的堆栈日志中进行查找（`top -Hp` 输出的是 10 进制的 id，`jstack` 输出的是 16 进制的，在查找时注意进制转换）\n\n我们看下上面 java 程序的堆栈的信息:\n``` Lua\n2024-08-16 15:15:40\nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):\n\n\"Attach Listener\" #35 daemon prio=9 os_prio=0 tid=0x00007f52b4001000 nid=0x71f4 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"DestroyJavaVM\" #34 prio=5 os_prio=0 tid=0x00007f53e0009800 nid=0x1693 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Thread-1\" #25 prio=5 os_prio=0 tid=0x00007f53e015a800 nid=0x16d9 runnable [0x00007f52f64e3000]\n   java.lang.Thread.State: RUNNABLE\n\tat sun.misc.Unsafe.getObjectVolatile(Native Method)\n\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:755)\n\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:938)\n\tat java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:267)\n\tat java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)\n\tat java.time.ZoneRegion.ofId(ZoneRegion.java:120)\n\tat java.time.ZoneId.of(ZoneId.java:411)\n\tat java.time.ZoneId.of(ZoneId.java:359)\n\tat java.time.ZoneId.of(ZoneId.java:315)\n\tat java.util.TimeZone.toZoneId(TimeZone.java:556)\n\tat java.time.ZoneId.systemDefault(ZoneId.java:274)\n\tat java.time.Clock.systemDefaultZone(Clock.java:178)\n\tat java.time.LocalDateTime.now(LocalDateTime.java:180)\n\tat Main$1.run(Main.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Thread-0\" #24 prio=5 os_prio=0 tid=0x00007f53e0159000 nid=0x16d8 runnable [0x00007f52f65e4000]\n   java.lang.Thread.State: RUNNABLE\n\tat sun.misc.Unsafe.getObjectVolatile(Native Method)\n\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:755)\n\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:938)\n\tat java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:267)\n\tat java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)\n\tat java.time.ZoneRegion.ofId(ZoneRegion.java:120)\n\tat java.time.ZoneId.of(ZoneId.java:411)\n\tat java.time.ZoneId.of(ZoneId.java:359)\n\tat java.time.ZoneId.of(ZoneId.java:315)\n\tat java.util.TimeZone.toZoneId(TimeZone.java:556)\n\tat java.time.ZoneId.systemDefault(ZoneId.java:274)\n\tat java.time.Clock.systemDefaultZone(Clock.java:178)\n\tat java.time.LocalDateTime.now(LocalDateTime.java:180)\n\tat Main$1.run(Main.java:12)\n\tat java.lang.Thread.run(Thread.java:748)\n\n   Locked ownable synchronizers:\n\t- None\n --- 10 个 thread\n\n\"Service Thread\" #23 daemon prio=9 os_prio=0 tid=0x00007f53e0143800 nid=0x16d6 runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"C2 CompilerThread1\" #6 daemon prio=9 os_prio=0 tid=0x00007f53e010e000 nid=0x16c5 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n --- 一大堆 C2 CompilerThread\n\n\"C2 CompilerThread0\" #5 daemon prio=9 os_prio=0 tid=0x00007f53e010b000 nid=0x16c4 waiting on condition [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Signal Dispatcher\" #4 daemon prio=9 os_prio=0 tid=0x00007f53e0109800 nid=0x16c3 runnable [0x0000000000000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Finalizer\" #3 daemon prio=8 os_prio=0 tid=0x00007f53e00d8800 nid=0x16c2 in Object.wait() [0x00007f52f7bfa000]\n   java.lang.Thread.State: WAITING (on object monitor)\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x000000008021a5e8> (a java.lang.ref.ReferenceQueue$Lock)\n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)\n\t- locked <0x000000008021a5e8> (a java.lang.ref.ReferenceQueue$Lock)\n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)\n\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"Reference Handler\" #2 daemon prio=10 os_prio=0 tid=0x00007f53e00d3800 nid=0x16c1 in Object.wait() [0x00007f52f7cfb000]\n   java.lang.Thread.State: WAITING (on object monitor)\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x0000000080218d38> (a java.lang.ref.Reference$Lock)\n\tat java.lang.Object.wait(Object.java:502)\n\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n\t- locked <0x0000000080218d38> (a java.lang.ref.Reference$Lock)\n\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\n   Locked ownable synchronizers:\n\t- None\n\n\"VM Thread\" os_prio=0 tid=0x00007f53e00ca000 nid=0x16c0 runnable\n\n\"GC task thread#0 (ParallelGC)\" os_prio=0 tid=0x00007f53e001f000 nid=0x1694 runnable\n\n--- 一大堆 GC task thread\n\n\"VM Periodic Task Thread\" os_prio=0 tid=0x00007f53e0146000 nid=0x16d7 waiting on condition\n\nJNI global references: 202\n```\n我们通过 top -Hp 的信息就可以快速定位到 Thread-[0-9] 这几个线程，而每个线程的调用栈都是 `java.time.LocalDateTime.now`, 也说明了这个方法在不停消耗 CPU。（但是 jstack 只能捕获短时间或者瞬时的堆栈信息，没法处理长时间的，所以我们在获取时可以多打印几次或者使用其他方法）\n\n至于 jstack 的详细用法，请参考我的另一篇博客：[java问题定位](https://baixiaozhou.github.io/2024/08/13/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/)\n\n除此之外，还有非常多的分析工具，pstack\\gstack\\strace\\gdb等等，大家可以自行探索使用\n\n#### 火焰图\n\n上面我们介绍了很多操作的命令和方法，那么有没有一种比较直观的方式能够直接看到各种方法执行的耗时比重等情况呢？火焰图就是为了解决这种情况而生的。\n\n火焰图的分类有很多，常用的包括:\n1. CPU 火焰图 (CPU Flame Graph)\n\t-\t描述：展示 CPU 在不同方法上的消耗情况，显示每个方法调用所占用的 CPU 时间。\n\t-\t用途：用于分析 CPU 性能瓶颈，识别哪些方法消耗了最多的 CPU 资源。\n\t-\t应用：Java、C++ 等多种编程语言的性能分析。\n2. 内存火焰图 (Memory Flame Graph)\n\t- 描述：展示内存分配情况，显示每个方法调用分配的内存量。\n    - 用途：用于检测内存泄漏、过度内存分配问题，帮助优化内存使用。\n\t- 应用：常用于分析内存密集型应用，如 Java 应用的堆内存分析。\n3. I/O 火焰图 (I/O Flame Graph)\n\t-\t描述：展示 I/O 操作的耗时情况，显示不同方法的 I/O 操作占用的时间。\n\t-\t用途：用于分析应用程序的 I/O 性能，识别慢速或频繁的 I/O 操作。\n\t-\t应用：数据库查询、文件系统操作、网络通信等场景的性能调优。\n\n我们这里通过 [async-profiler](https://github.com/async-profiler/async-profiler) 对文章上面的java压测程序进行抓取(这个工具只能抓 java 的)\n\n```\ntar -xzf async-profiler-3.0-linux-x64.tar.gz\ncd async-profiler-3.0-linux-x64/bin\n./asprof -d 60 pid -f /tmp/javastress.html\n```\n我们用浏览器打开生成的 html 文件，可以看到如下的火焰图信息（可以在网页进行点击，查看更细节的方法）\n{% image /images/javafire.png java 程序的火焰图, fancybox:true %}\n<!-- ![java 程序的火焰图](../images/javafire.png) -->\n\n这样看起来就比 jstack这些信息更加直观一点。\n\n## 负载飙升\n\n### 负载的定义以及如何查看负载\n\n我们先看下系统负载的官方描述:\n```\nSystem load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in arunnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access,eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs ina  system,  so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.\n```\n\n系统负载平均值表示处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。处于不可中断状态的进程正在等待某些 I/O 访问，例如等待磁盘。这里的核心概念就是 loadavg 这个数值体现了某些特定状态进程的数量。\n\n那引申出两个问题:\n1. 进程的状态有哪些？ 如何在 Linux 上查看进程状态\n2. 可运行和不可中断状态的进程具体含义是什么\n\n查看的方式，我们可以通过 ps 命令进行查看，比如通过`ps -auxf`, 我么可以看到有一列为 `STAT`,这列就代表该进程的状态:\n\n{% image /images/psauxf.png 进程状态 fancybox:true %}\n\n进程的状态和具体含义:\n- D    uninterruptible sleep (usually IO)\n- R    running or runnable (on run queue)\n- S    interruptible sleep (waiting for an event to complete)\n- T    stopped by job control signal\n- t    stopped by debugger during the tracing\n- W    paging (not valid since the 2.6.xx kernel)\n- X    dead (should never be seen) \n- Z    defunct (\"zombie\") process, terminated but not reaped by its parent\n\n这里我们看到处于不可中断的状态的进程和正在运行的进程分别为 `D` 和 `R`,换个说法，也就是说造成负载升高的原因也就是这两个状态的进程引起的。\n\n（插个题外话，按照官方的说法，X 状态的进程应该是不应该被看到的， 但是之前在腾讯云做ES的时候，偶然间碰到了一次，当时还截了个图用做留念😂，但是没有捕获到具体的信息）\n\n负载的指标可以通过 `top` 以及 `uptime` 指令获取\n```\n23:35:00 up 1 day, 46 min,  1 user,  load average: 49.16, 18.35, 7.87\n```\n这里展示了 loadavg 的三个数值: 分别代表的含义是 1min、5min、15min 的系统平均负载\n\n那我们如何判断系统的负载是高是低呢？\n\n这里一般有个经验值，我们一般和 CPU 和核心数进行对比，一般负载在 CPU 核心的 70% 左右以及以下，对系统一般没什么影响，超过 70%，系统可能收到影响。但是这里还需要注意的一点就是，负载的比例在 70% 以下时不一定代表系统就没问题，举个简单的例子，如果一个系统上基本上没有业务在运行，那么负载基本上就在零点几左右，那么这种情况下，负载有升高不一定是合理的（后面举一个简单的例子）\n\n### 如何让系统负载飙高\n\n#### 纯计算任务对负载的影响\n\n既然说正在运行的进程会引起负载的变化，那么跑一些程序，让程序不停运行，那么自然而然就能构造出持续运行的进程了。\n我这里找了三台机器(64C)，用我的压测工具先跑一些纯 CPU 的运算，然后观察下效果：\n\n测试分为三组，测试前关闭不必要的服务和进程:\n1. 10 并发 30min\n   -  `nohup ./sysstress cpu --cpu-number 10 --duration 30m > /dev/null 2>&1`\n2. 30 并发 30min\n   - `nohup ./sysstress cpu --cpu-number 30 --duration 30m > /dev/null 2>&1`\n3. 60 并发 30min\n   - `nohup ./sysstress cpu --cpu-number 60 --duration 30m > /dev/null 2>&1`\n\n效果如下:\n{% image /images/load10.png 10并发负载, fancybox:true %}\n{% image /images/load30.png 30并发负载, fancybox:true %}\n{% image /images/load60.png 60并发负载, fancybox:true %}\n<!-- ![10并发负载](../images/load10.png)\n![30并发负载](../images/load30.png)\n![60并发负载](../images/load60.png) -->\n\n从上述测试过程中，我们可以发现，在纯运算这种场景下，并发的量基本上和负载是对应的。也就是说随着 CPU的使用量 上涨，负载也会不断变高。\n\n#### 磁盘 IO 对负载的影响\n\n在刚才的例子中，我们看到了纯运算对负载的影响（R 进程的代表），然后在关于 D 进程的说明中，我们可以看到有一个比较明显的说明 `(usually IO)` ,即通常是 IO 引起的，那么接下来我们通过磁盘 IO 来测试一下\n\n测试分为三组，测试前关闭不必要的服务和进程:\n1. 10 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 10 -d 15m > /dev/null 2>&1 &`\n2. 30 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 30 -d 15m > /dev/null 2>&1 &`\n3. 60 并发 15min\n   - `nohup ./sysstress io --operation read --filepath test.access.log -p 60 -d 15m > /dev/null 2>&1 &`\n\n效果如下:\n\n{% image /images/ioload10.png 10并发负载 fancybox:true %}\n{% image /images/ioload30.png 30并发负载 fancybox:true %}\n{% image /images/ioload60.png 60并发负载 fancybox:true %}\n\n我们也顺便看一下，60 并发下 CPU 的情况:\n\n{% image /images/io60c.png 60并发系统整体情况 fancybox:true %}\n\n这里我们可以观察到，系统的 CPU 基本上已经跑满了。us 和 sy 都占的比较多，但是这种读取非常有可能走到缓存中，我们想测绕过缓存，可以通过 DIRECT 的方式。\n\n但是上面的例子其实也证明了一件事，IO 的操作也是会导致负载产生飙升。\n\n那么问题来了，磁盘IO 和 CPU 操作都会导致系统负载飙升，那么负载飙升一定会是这两个原因吗？答案也是未必的，因为上述我们曾经提到过 D 状态的进程，到目前为止我们好像还没介绍过，那么我们来继续模拟，既然 D 状态的进程是 IO 操作引起的，普通的磁盘读写 IO 很难模拟，那我们就换个 IO 场景继续模拟 -- 网络 IO。\n\n#### 通过网络 IO 模拟 D 状态进程观察负载影响\n\n这里直接上一个模拟方法:\n- A 机器开启 NFS Server\n- B 机器作为客户端进行挂载\n- 断开网络\n- 疯狂 df -h\n\n详细的操作步骤:\n```\n# 安装 Centos\nsudo yum install nfs-utils\n\n# 服务端配置\nsudo mkdir -p /mnt/nfs_share\nsudo chown nobody:nogroup /mnt/nfs_share\nsudo chmod 755 /mnt/nfs_share\n## 打开 /etc/exports 配置，添加一行来定义共享目录及其权限。例如，将 /mnt/nfs_share 共享给网络 192.168.1.0/24，并提供读写权限：\n/mnt/nfs_share 192.168.1.0/24(rw,sync,no_subtree_check)\n\n## 启动 NFS\nsudo exportfs -a\nsudo systemctl restart nfs-kernel-server\nsudo systemctl enable nfs-kernel-server\n\n# 客户端配置\nsudo mkdir -p /mnt/nfs_client\nsudo mount -t nfs 192.168.1.100(server ip):/mnt/nfs_share /mnt/nfs_client\n## 验证\ndf -h /mnt/nfs_client\n\n# 断网模拟(客户端)\niptables -I INPUT -s serverip -j DROP\n\n# 持续(疯狂)执行：\ndu -sh /mnt/nfs_client\n```\n因为网络已经断掉，所以`du -sh /mnt/nfs_client`,而且这个程序没有自动退出或者报错，这样就导致程序无法顺利执行下去，继而阻塞住就变成了 D 状态的进程。\n\n基于这种模拟方法大家可以自行测试下，笔者之前做过一个场景，将一个两核心的 CPU负载干到了 200 多，但是因为**这种情况下更多是阻塞在网络中，所以此时的负载虽高，并不一定影响系统运行**。\n\n当然这只是其中一个例子，笔者曾经也因为见过 ping 操作阻塞导致的负载飙升，所以这种场景是多种多样的😂，大家有更多的例子也可以在下方留言，共同学习进步。\n\n\n### 负载飙升如何排查\n基于上面的例子和场景模拟，我们其实应该已经有一套基本的排查方法了，下面这张图是我个人的一些总结(图还会不断完善)\n\n{% image /images/loadhigh.png  负载高排查导图 fancybox:true %}\n","slug":"线上问题排查方法汇总","published":1,"updated":"2024-08-19T09:12:29.361Z","_id":"clzzd33n10003x4ic61n6cz2g","comments":1,"layout":"post","photos":[],"content":"<span id=\"more\"></span>\n\n<ul>\n<li><a href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</a></li>\n<li><a href=\"#cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">CPU使用率飙升</a><ul>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%A9cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">如何让CPU使用率飙升</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%92%8C%E5%8F%91%E7%8E%B0cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">如何判断和发现CPU使用率飙升</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E9%A3%99%E5%8D%87%E7%9A%84%E6%A0%B9%E6%BA%90\">如何确定CPU飙升的根源</a><ul>\n<li><a href=\"#perf%E5%91%BD%E4%BB%A4\">perf命令</a></li>\n<li><a href=\"#jstack\">jstack</a></li>\n<li><a href=\"#%E7%81%AB%E7%84%B0%E5%9B%BE\">火焰图</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87\">负载飙升</a><ul>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%B4%9F%E8%BD%BD\">负载的定义以及如何查看负载</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%A3%99%E9%AB%98\">如何让系统负载飙高</a><ul>\n<li><a href=\"#%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D\">纯计算任务对负载的影响</a></li>\n<li><a href=\"#%E7%A3%81%E7%9B%98-io-%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D\">磁盘 IO 对负载的影响</a></li>\n<li><a href=\"#%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C-io-%E6%A8%A1%E6%8B%9F-d-%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E8%A7%82%E5%AF%9F%E8%B4%9F%E8%BD%BD%E5%BD%B1%E5%93%8D\">通过网络 IO 模拟 D 状态进程观察负载影响</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5\">负载飙升如何排查</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在很多文章中，每当提到去解决线上问题的时候，大部分的处理方式就是登录环境，哐哐各种敲命令。操作本身没什么问题，但是对于很多人而言，我觉得这种做法其实是本末倒置的，过于在乎去快速抓住重点问题，而忽略了从全局去看问题。那么如果最开始不去操作各种命令，那应该干什么呢？</p>\n<p><em><strong>看监控！！！！</strong></em></p>\n<p>首先不要觉得这个是废话，对于很多场景来说，业务规模是不断变化的，有的时候并发超过了极限的性能，那么这种情况下都没有必要去后台进行各种查询。举个简单的例子，假如说某套业务系统，本身只能支持 500 并发，现在实际上的量到了 2000，导致线上各种内存、CPU、负载的告警，这种情况下还有必要去后台敲<code>top</code>、<code>free</code>吗？答案当然是否定的，这种情况下，就需要考虑对业务系统进行快速的扩容等。</p>\n<p>看监控的意义在于尽可能的找到更多的性能瓶颈或者异常的点，从全局出发，对系统当前存在的问题和异常点有全面的了解。</p>\n<p>监控系统多种多样，从较早的 zabbix 到现在比较流行的prometheus+grafana（举两个常用的例子），对于系统业务都有比较完善的监控，可以帮助我们更加具体的了解到系统运行全貌。如果你对这些都不喜欢，那么你自己写一个监控系统也没什么问题。</p>\n<p>当我们看完监控之后（假设你真的看了），接下来进入实际操作环节，我会从这些指标的详细含义出发，然后尽可能地将各种处理方式分享给大家。</p>\n<h2 id=\"CPU使用率飙升\"><a href=\"#CPU使用率飙升\" class=\"headerlink\" title=\"CPU使用率飙升\"></a>CPU使用率飙升</h2><h3 id=\"如何让CPU使用率飙升\"><a href=\"#如何让CPU使用率飙升\" class=\"headerlink\" title=\"如何让CPU使用率飙升\"></a>如何让CPU使用率飙升</h3><p>这个问题其实很简单，只要有计算任务一直存在，让 CPU 一直处于繁忙之中，那么 CPU 必然飙升。我们可以通过一系列的工具去模拟这个情况。</p>\n<p><a href=\"https://github.com/baixiaozhou/SysStress\">github SysStress</a> 这是我自己用 golang 写的压测工具(还在开发中，可以点个 star 让我更有动力😂)</p>\n<p>使用方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sysstress cpu --cpu-number 10 --duration 10m</span><br></pre></td></tr></table></figure>\n<p>这个就是模拟占用 10 核心的 CPU 并持续 10min，当然大家也可以用其他的压测工具，比如<code>stress-ng</code></p>\n<h3 id=\"如何判断和发现CPU使用率飙升\"><a href=\"#如何判断和发现CPU使用率飙升\" class=\"headerlink\" title=\"如何判断和发现CPU使用率飙升\"></a>如何判断和发现CPU使用率飙升</h3><p>首先我们先看一下，跟 CPU 使用率相关的有哪些指标。我们通过 <code>top</code> 命令就可以看到具体的信息</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/top.png\" alt=\"top\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">top</span></div></div>\n<!-- ![top](../images/top.png) -->\n<p>这些输出中有一行是 <code>%Cpu(s)</code>, 这行展示了 CPU 的整体使用情况，是一个百分比的形式，我们详细阐述下这几个字段的含义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">us, user    : time running un-niced user processes   未降低优先级的用户进程所占用的时间</span><br><span class=\"line\">sy, system  : time running kernel processes          内核进程所占用的时间</span><br><span class=\"line\">ni, nice    : time running niced user processes      降低优先级的用户进程所占用的时间</span><br><span class=\"line\">id, idle    : time spent in the kernel idle handler  空闲的时间</span><br><span class=\"line\">wa, IO-wait : time waiting for I/O completion        等待 I/O 操作完成所花费的时间</span><br><span class=\"line\">hi : time spent servicing hardware interrupts        处理硬件中断所花费的时间</span><br><span class=\"line\">si : time spent servicing software interrupts        处理软件中断所花费的时间</span><br><span class=\"line\">st : time stolen from this vm by the hypervisor      被虚拟机管理程序从此虚拟机中窃取的时间</span><br></pre></td></tr></table></figure>\n<p>在这些指标中，一般关注的比较多的就是 us、sy、id、wa（其他几个指标很高的情况我个人目前基本上没有遇到过）</p>\n<p>上述指标反映了系统整体的 CPU 情况。而程序在操作系统中实际上是以一个个的进程存在的，那我们如何确定到占用 CPU 高的进程呢？让我们的目光从 top 的头部信息往下移动，下面就展示了详细的进程信息</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/top-process.png\" alt=\"top-process\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">top-process</span></div></div>\n<!-- ![top-process](../images/top-process.png) -->\n\n<p>这些程序默认是按照 CPU 的使用率从高到底进行排序的，当然你也可以通过在<code>top</code>的时候输入<code>P</code>进行排序，这样我们就可以看到系统中消耗 CPU 资源的详细进程信息</p>\n<p>上面是我通过 <code>./sysstress cpu --cpu-number 10 --duration 10m</code> 压测程序跑出来的，可以看到这里的 sysstress 程序占用了 1002 的 %CPU，也就是说基本上是 10 个核心，那我们跑一个更高的，将<code>--cpu-number</code>加到 60 看看发生了什么</p>\n<!-- ![stress-cpu](../images/stress-cpu.png) -->\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/stress-cpu.png\" alt=\"stress-cpu\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">stress-cpu</span></div></div>\n\n<p>我们可以看到这次%CPU打到了 6000，那很多人就好奇我日常的程序跑到多高算高呢？</p>\n<p>这里我们需要明确一点，现在的服务器绝大部分都是多核心 CPU（1C2G这种自己用来玩的忽略），CPU 的核心数决定了我们程序在同一时间能够执行多少个线程，也就是说，这个高不高是相对于机器配置而言的。如果你的机器只有 16C，那么单个进程占用的 %CPU 到 1000，那么其实已经算是比较高了。如果是 256C 的CPU（土豪级配置），那么单个进程占用的 %CPU 到 6000，对于系统的稳定性影响就没有那么大了。</p>\n<p>上述我们说的情况是进程占用 CPU 对整个系统的影响，那么进程占用的 CPU 对系统的影响不大就代表这个程序一定没有问题吗？答案显然是未必的。</p>\n<p>我们还是要回归到业务本身，如果进程的 CPU 占用在业务变动不大的情况下，发生了异常波动，或者正常情况下业务不会消耗这么高的 CPU，那么我们就需要继续排查了。</p>\n<h3 id=\"如何确定CPU飙升的根源\"><a href=\"#如何确定CPU飙升的根源\" class=\"headerlink\" title=\"如何确定CPU飙升的根源\"></a>如何确定CPU飙升的根源</h3><p>这个问题的 核心是 CPU 上在运行什么东西。 多核心CPU 下，每个核心都可以执行不同的程序，我们如何确定一个进程中那些方法在消耗 CPU 呢？从而引申下面详细的问题:</p>\n<ol>\n<li>程序的调用栈是什么样的？</li>\n<li>调用栈信息中哪些是需要关注的，那些是可以忽略的？</li>\n<li>热点函数是什么？</li>\n</ol>\n<p>老话说得好，”工欲善其事，必先利其器”, 我们需要这些东西，就必须了解到什么样的工具可以拿到上面我提到的一些信息。接下来我将通过常用的后端语言：<code>golang</code> 和 <code>java</code> 为例构造一些高 CPU 的程序来进行展示。</p>\n<h4 id=\"perf命令\"><a href=\"#perf命令\" class=\"headerlink\" title=\"perf命令\"></a>perf命令</h4><p><strong>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。</strong></p>\n<p>安装:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install perf   #Centos</span><br></pre></td></tr></table></figure>\n<p>安装完成后，我们可以首先看下 <code>perf</code>的用法，这里不展开具体用法，只列出我平常使用的几个命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top        System profiling tool.               #对系统性能进行实时分析。</span><br><span class=\"line\">record     Run a command and record its profile into perf.data     #收集采样信息</span><br><span class=\"line\">report     Read perf.data (created by perf record) and display the profile  #分析采样信息，和record配合使用</span><br></pre></td></tr></table></figure>\n<p>record 和 report 的使用更多在于 dump 当前环境的信息用于后续分析，如果在自己环境上测试，可以用 top 进行一些简单的实时分析（类似于 top 命令）。</p>\n<p>还是用之前的压测工具，我们模拟一个 10 核心的 10min 的压测场景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./sysstress cpu --cpu-number 10 --duration 10m &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<p>执行这个语句，让压测程序在后台执行，然后我们通过<code>perf top</code>查看具体的情况（可以通过-p 指定 pid）</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/perftop.png\" alt=\"perf top,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">perf top,</span></div></div>\n<!-- ![perf top](../images/perftop.png) -->\n\n<p>从截图的信息中我们可以看到占用资源最多的一些方法，包括 sysstress 进程的各种方法(从图片中基本上就可以确定高消耗的方法在哪里)以及底层的 <code>__vdso_clock_gettime</code>, 那再结合压测工具的代码分析下:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">burnCpu</span><span class=\"params\">(wg *sync.WaitGroup, start time.Time, durSec <span class=\"type\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t_ = <span class=\"number\">1</span> * <span class=\"number\">1</span></span><br><span class=\"line\">\t\tnow := time.Now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> now.Sub(start) &gt; time.Duration(durSec)*time.Second &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是方法的核心，其实就是做无意义的计算，外加时间的判断，超过 duration 就结束。这样和上面的 perf top 信息就能对应起来。</p>\n<p>然后我们用 java 写一个同样的程序，再看看 <code>perf top</code>的情况:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/javaperftop.png\" alt=\"perf top,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">perf top,</span></div></div>\n<!-- ![perf top](../images/javaperftop.png) -->\n<p>从这一大段显示来看，是不是看的一脸懵逼，很难发现到底是什么程序在占用CPU 资源。大家可以看一下源程序:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                        Math.sin(Math.random());</span><br><span class=\"line\">                        <span class=\"type\">LocalDateTime</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> LocalDateTime.now();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的程序也是非常简单，启动 10 个线程，做一个无意义的数学运算，然后获取当前时间。从这段代码中是不是很难和上面<code>perf top</code>的显示关联起来？ 原因也非常简单， 像Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。那我们好能通过 perf 去看到 java 相关的堆栈吗？答案是可以的。</p>\n<p>可以借助 <a href=\"https://github.com/jvm-profiling-tools/perf-map-agent\">perf-map-agent</a> 这样的开源工具，去生成和<code>perf</code> 工具一起使用的方法映射，但是需要做额外的一些配置。这里的方法大家可以自己探究，为什么不详细的讲这个呢，原因也简单，排查问题的工具多种多样，没必要在一棵树上吊死。</p>\n<h4 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h4><p>既然 perf top 去查看 JAVA 的调用栈不太方便，我们就直接上 java 提供的 jstack 工具去分析。</p>\n<ul>\n<li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li>\n<li>kill -3， jstack 用不了的情况下可以使用 kill -3 pid 的形式，堆栈会输出在系统日志中。</li>\n</ul>\n<p>具体的操作步骤:</p>\n<ol>\n<li><code>top -Hp $pid</code> 找到占用 CPU 的具体线程</li>\n<li><code>jstack -l $pid &gt; /tmp/$pid.jstack</code> 或者 <code>kill -3 $pid</code>将 java 进程的堆栈情况输出的日志中，然后根据 <code>top -Hp</code> 看到的线程信息在输出的堆栈日志中进行查找（<code>top -Hp</code> 输出的是 10 进制的 id，<code>jstack</code> 输出的是 16 进制的，在查找时注意进制转换）</li>\n</ol>\n<p>我们看下上面 java 程序的堆栈的信息:</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2024</span><span class=\"number\">-08</span><span class=\"number\">-16</span> <span class=\"number\">15</span>:<span class=\"number\">15</span>:<span class=\"number\">40</span></span><br><span class=\"line\">Full thread <span class=\"built_in\">dump</span> Java HotSpot(TM) <span class=\"number\">64</span>-Bit Server VM (<span class=\"number\">25.221</span>-b11 mixed mode):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Attach Listener&quot;</span> #<span class=\"number\">35</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f52b4001000</span> nid=<span class=\"number\">0x71f4</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;DestroyJavaVM&quot;</span> #<span class=\"number\">34</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0009800</span> nid=<span class=\"number\">0x1693</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Thread-1&quot;</span> #<span class=\"number\">25</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e015a800</span> nid=<span class=\"number\">0x16d9</span> runnable [<span class=\"number\">0x00007f52f64e3000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\tat sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class=\"number\">755</span>)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class=\"number\">938</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class=\"number\">267</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class=\"number\">227</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class=\"number\">120</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">315</span>)</span><br><span class=\"line\">\tat java.util.TimeZone.toZoneId(TimeZone.java:<span class=\"number\">556</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.systemDefault(ZoneId.java:<span class=\"number\">274</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.Clock.systemDefaultZone(Clock.java:<span class=\"number\">178</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.LocalDateTime.now(LocalDateTime.java:<span class=\"number\">180</span>)</span><br><span class=\"line\">\tat Main$<span class=\"number\">1.</span>run(Main.java:<span class=\"number\">12</span>)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Thread-0&quot;</span> #<span class=\"number\">24</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0159000</span> nid=<span class=\"number\">0x16d8</span> runnable [<span class=\"number\">0x00007f52f65e4000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\tat sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class=\"number\">755</span>)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class=\"number\">938</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class=\"number\">267</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class=\"number\">227</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class=\"number\">120</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">315</span>)</span><br><span class=\"line\">\tat java.util.TimeZone.toZoneId(TimeZone.java:<span class=\"number\">556</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.systemDefault(ZoneId.java:<span class=\"number\">274</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.Clock.systemDefaultZone(Clock.java:<span class=\"number\">178</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.LocalDateTime.now(LocalDateTime.java:<span class=\"number\">180</span>)</span><br><span class=\"line\">\tat Main$<span class=\"number\">1.</span>run(Main.java:<span class=\"number\">12</span>)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"> <span class=\"comment\">--- 10 个 thread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Service Thread&quot;</span> #<span class=\"number\">23</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0143800</span> nid=<span class=\"number\">0x16d6</span> runnable [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;C2 CompilerThread1&quot;</span> #<span class=\"number\">6</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e010e000</span> nid=<span class=\"number\">0x16c5</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"> <span class=\"comment\">--- 一大堆 C2 CompilerThread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;C2 CompilerThread0&quot;</span> #<span class=\"number\">5</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e010b000</span> nid=<span class=\"number\">0x16c4</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Signal Dispatcher&quot;</span> #<span class=\"number\">4</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0109800</span> nid=<span class=\"number\">0x16c3</span> runnable [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Finalizer&quot;</span> #<span class=\"number\">3</span> daemon prio=<span class=\"number\">8</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00d8800</span> nid=<span class=\"number\">0x16c2</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f52f7bfa000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;<span class=\"number\">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">144</span>)</span><br><span class=\"line\">\t- locked &lt;<span class=\"number\">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">165</span>)</span><br><span class=\"line\">\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class=\"number\">216</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Reference Handler&quot;</span> #<span class=\"number\">2</span> daemon prio=<span class=\"number\">10</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00d3800</span> nid=<span class=\"number\">0x16c1</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f52f7cfb000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;<span class=\"number\">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:<span class=\"number\">502</span>)</span><br><span class=\"line\">\tat java.lang.ref.Reference.tryHandlePending(Reference.java:<span class=\"number\">191</span>)</span><br><span class=\"line\">\t- locked &lt;<span class=\"number\">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class=\"number\">153</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;VM Thread&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00ca000</span> nid=<span class=\"number\">0x16c0</span> runnable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e001f000</span> nid=<span class=\"number\">0x1694</span> runnable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--- 一大堆 GC task thread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0146000</span> nid=<span class=\"number\">0x16d7</span> waiting on condition</span><br><span class=\"line\"></span><br><span class=\"line\">JNI global references: <span class=\"number\">202</span></span><br></pre></td></tr></table></figure>\n<p>我们通过 top -Hp 的信息就可以快速定位到 Thread-[0-9] 这几个线程，而每个线程的调用栈都是 <code>java.time.LocalDateTime.now</code>, 也说明了这个方法在不停消耗 CPU。（但是 jstack 只能捕获短时间或者瞬时的堆栈信息，没法处理长时间的，所以我们在获取时可以多打印几次或者使用其他方法）</p>\n<p>至于 jstack 的详细用法，请参考我的另一篇博客：<a href=\"https://baixiaozhou.github.io/2024/08/13/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/\">java问题定位</a></p>\n<p>除此之外，还有非常多的分析工具，pstack\\gstack\\strace\\gdb等等，大家可以自行探索使用</p>\n<h4 id=\"火焰图\"><a href=\"#火焰图\" class=\"headerlink\" title=\"火焰图\"></a>火焰图</h4><p>上面我们介绍了很多操作的命令和方法，那么有没有一种比较直观的方式能够直接看到各种方法执行的耗时比重等情况呢？火焰图就是为了解决这种情况而生的。</p>\n<p>火焰图的分类有很多，常用的包括:</p>\n<ol>\n<li>CPU 火焰图 (CPU Flame Graph)<ul>\n<li>   描述：展示 CPU 在不同方法上的消耗情况，显示每个方法调用所占用的 CPU 时间。</li>\n<li>   用途：用于分析 CPU 性能瓶颈，识别哪些方法消耗了最多的 CPU 资源。</li>\n<li>   应用：Java、C++ 等多种编程语言的性能分析。</li>\n</ul>\n</li>\n<li>内存火焰图 (Memory Flame Graph)<ul>\n<li>描述：展示内存分配情况，显示每个方法调用分配的内存量。</li>\n<li>用途：用于检测内存泄漏、过度内存分配问题，帮助优化内存使用。</li>\n<li>应用：常用于分析内存密集型应用，如 Java 应用的堆内存分析。</li>\n</ul>\n</li>\n<li>I&#x2F;O 火焰图 (I&#x2F;O Flame Graph)<ul>\n<li>   描述：展示 I&#x2F;O 操作的耗时情况，显示不同方法的 I&#x2F;O 操作占用的时间。</li>\n<li>   用途：用于分析应用程序的 I&#x2F;O 性能，识别慢速或频繁的 I&#x2F;O 操作。</li>\n<li>   应用：数据库查询、文件系统操作、网络通信等场景的性能调优。</li>\n</ul>\n</li>\n</ol>\n<p>我们这里通过 <a href=\"https://github.com/async-profiler/async-profiler\">async-profiler</a> 对文章上面的java压测程序进行抓取(这个工具只能抓 java 的)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzf async-profiler-3.0-linux-x64.tar.gz</span><br><span class=\"line\">cd async-profiler-3.0-linux-x64/bin</span><br><span class=\"line\">./asprof -d 60 pid -f /tmp/javastress.html</span><br></pre></td></tr></table></figure>\n<p>我们用浏览器打开生成的 html 文件，可以看到如下的火焰图信息（可以在网页进行点击，查看更细节的方法）</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/javafire.png\" alt=\"java 程序的火焰图,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">java 程序的火焰图,</span></div></div>\n<!-- ![java 程序的火焰图](../images/javafire.png) -->\n\n<p>这样看起来就比 jstack这些信息更加直观一点。</p>\n<h2 id=\"负载飙升\"><a href=\"#负载飙升\" class=\"headerlink\" title=\"负载飙升\"></a>负载飙升</h2><h3 id=\"负载的定义以及如何查看负载\"><a href=\"#负载的定义以及如何查看负载\" class=\"headerlink\" title=\"负载的定义以及如何查看负载\"></a>负载的定义以及如何查看负载</h3><p>我们先看下系统负载的官方描述:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in arunnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access,eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs ina  system,  so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.</span><br></pre></td></tr></table></figure>\n\n<p>系统负载平均值表示处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。处于不可中断状态的进程正在等待某些 I&#x2F;O 访问，例如等待磁盘。这里的核心概念就是 loadavg 这个数值体现了某些特定状态进程的数量。</p>\n<p>那引申出两个问题:</p>\n<ol>\n<li>进程的状态有哪些？ 如何在 Linux 上查看进程状态</li>\n<li>可运行和不可中断状态的进程具体含义是什么</li>\n</ol>\n<p>查看的方式，我们可以通过 ps 命令进行查看，比如通过<code>ps -auxf</code>, 我么可以看到有一列为 <code>STAT</code>,这列就代表该进程的状态:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/psauxf.png\" alt=\"进程状态\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">进程状态</span></div></div>\n\n<p>进程的状态和具体含义:</p>\n<ul>\n<li>D    uninterruptible sleep (usually IO)</li>\n<li>R    running or runnable (on run queue)</li>\n<li>S    interruptible sleep (waiting for an event to complete)</li>\n<li>T    stopped by job control signal</li>\n<li>t    stopped by debugger during the tracing</li>\n<li>W    paging (not valid since the 2.6.xx kernel)</li>\n<li>X    dead (should never be seen) </li>\n<li>Z    defunct (“zombie”) process, terminated but not reaped by its parent</li>\n</ul>\n<p>这里我们看到处于不可中断的状态的进程和正在运行的进程分别为 <code>D</code> 和 <code>R</code>,换个说法，也就是说造成负载升高的原因也就是这两个状态的进程引起的。</p>\n<p>（插个题外话，按照官方的说法，X 状态的进程应该是不应该被看到的， 但是之前在腾讯云做ES的时候，偶然间碰到了一次，当时还截了个图用做留念😂，但是没有捕获到具体的信息）</p>\n<p>负载的指标可以通过 <code>top</code> 以及 <code>uptime</code> 指令获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23:35:00 up 1 day, 46 min,  1 user,  load average: 49.16, 18.35, 7.87</span><br></pre></td></tr></table></figure>\n<p>这里展示了 loadavg 的三个数值: 分别代表的含义是 1min、5min、15min 的系统平均负载</p>\n<p>那我们如何判断系统的负载是高是低呢？</p>\n<p>这里一般有个经验值，我们一般和 CPU 和核心数进行对比，一般负载在 CPU 核心的 70% 左右以及以下，对系统一般没什么影响，超过 70%，系统可能收到影响。但是这里还需要注意的一点就是，负载的比例在 70% 以下时不一定代表系统就没问题，举个简单的例子，如果一个系统上基本上没有业务在运行，那么负载基本上就在零点几左右，那么这种情况下，负载有升高不一定是合理的（后面举一个简单的例子）</p>\n<h3 id=\"如何让系统负载飙高\"><a href=\"#如何让系统负载飙高\" class=\"headerlink\" title=\"如何让系统负载飙高\"></a>如何让系统负载飙高</h3><h4 id=\"纯计算任务对负载的影响\"><a href=\"#纯计算任务对负载的影响\" class=\"headerlink\" title=\"纯计算任务对负载的影响\"></a>纯计算任务对负载的影响</h4><p>既然说正在运行的进程会引起负载的变化，那么跑一些程序，让程序不停运行，那么自然而然就能构造出持续运行的进程了。<br>我这里找了三台机器(64C)，用我的压测工具先跑一些纯 CPU 的运算，然后观察下效果：</p>\n<p>测试分为三组，测试前关闭不必要的服务和进程:</p>\n<ol>\n<li>10 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 10 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n<li>30 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 30 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n<li>60 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 60 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n</ol>\n<p>效果如下:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load10.png\" alt=\"10并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">10并发负载,</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load30.png\" alt=\"30并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">30并发负载,</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load60.png\" alt=\"60并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发负载,</span></div></div>\n<!-- ![10并发负载](../images/load10.png)\n![30并发负载](../images/load30.png)\n![60并发负载](../images/load60.png) -->\n\n<p>从上述测试过程中，我们可以发现，在纯运算这种场景下，并发的量基本上和负载是对应的。也就是说随着 CPU的使用量 上涨，负载也会不断变高。</p>\n<h4 id=\"磁盘-IO-对负载的影响\"><a href=\"#磁盘-IO-对负载的影响\" class=\"headerlink\" title=\"磁盘 IO 对负载的影响\"></a>磁盘 IO 对负载的影响</h4><p>在刚才的例子中，我们看到了纯运算对负载的影响（R 进程的代表），然后在关于 D 进程的说明中，我们可以看到有一个比较明显的说明 <code>(usually IO)</code> ,即通常是 IO 引起的，那么接下来我们通过磁盘 IO 来测试一下</p>\n<p>测试分为三组，测试前关闭不必要的服务和进程:</p>\n<ol>\n<li>10 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 10 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n<li>30 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 30 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n<li>60 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 60 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n</ol>\n<p>效果如下:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload10.png\" alt=\"10并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">10并发负载</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload30.png\" alt=\"30并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">30并发负载</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload60.png\" alt=\"60并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发负载</span></div></div>\n\n<p>我们也顺便看一下，60 并发下 CPU 的情况:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/io60c.png\" alt=\"60并发系统整体情况\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发系统整体情况</span></div></div>\n\n<p>这里我们可以观察到，系统的 CPU 基本上已经跑满了。us 和 sy 都占的比较多，但是这种读取非常有可能走到缓存中，我们想测绕过缓存，可以通过 DIRECT 的方式。</p>\n<p>但是上面的例子其实也证明了一件事，IO 的操作也是会导致负载产生飙升。</p>\n<p>那么问题来了，磁盘IO 和 CPU 操作都会导致系统负载飙升，那么负载飙升一定会是这两个原因吗？答案也是未必的，因为上述我们曾经提到过 D 状态的进程，到目前为止我们好像还没介绍过，那么我们来继续模拟，既然 D 状态的进程是 IO 操作引起的，普通的磁盘读写 IO 很难模拟，那我们就换个 IO 场景继续模拟 – 网络 IO。</p>\n<h4 id=\"通过网络-IO-模拟-D-状态进程观察负载影响\"><a href=\"#通过网络-IO-模拟-D-状态进程观察负载影响\" class=\"headerlink\" title=\"通过网络 IO 模拟 D 状态进程观察负载影响\"></a>通过网络 IO 模拟 D 状态进程观察负载影响</h4><p>这里直接上一个模拟方法:</p>\n<ul>\n<li>A 机器开启 NFS Server</li>\n<li>B 机器作为客户端进行挂载</li>\n<li>断开网络</li>\n<li>疯狂 df -h</li>\n</ul>\n<p>详细的操作步骤:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装 Centos</span><br><span class=\"line\">sudo yum install nfs-utils</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端配置</span><br><span class=\"line\">sudo mkdir -p /mnt/nfs_share</span><br><span class=\"line\">sudo chown nobody:nogroup /mnt/nfs_share</span><br><span class=\"line\">sudo chmod 755 /mnt/nfs_share</span><br><span class=\"line\">## 打开 /etc/exports 配置，添加一行来定义共享目录及其权限。例如，将 /mnt/nfs_share 共享给网络 192.168.1.0/24，并提供读写权限：</span><br><span class=\"line\">/mnt/nfs_share 192.168.1.0/24(rw,sync,no_subtree_check)</span><br><span class=\"line\"></span><br><span class=\"line\">## 启动 NFS</span><br><span class=\"line\">sudo exportfs -a</span><br><span class=\"line\">sudo systemctl restart nfs-kernel-server</span><br><span class=\"line\">sudo systemctl enable nfs-kernel-server</span><br><span class=\"line\"></span><br><span class=\"line\"># 客户端配置</span><br><span class=\"line\">sudo mkdir -p /mnt/nfs_client</span><br><span class=\"line\">sudo mount -t nfs 192.168.1.100(server ip):/mnt/nfs_share /mnt/nfs_client</span><br><span class=\"line\">## 验证</span><br><span class=\"line\">df -h /mnt/nfs_client</span><br><span class=\"line\"></span><br><span class=\"line\"># 断网模拟(客户端)</span><br><span class=\"line\">iptables -I INPUT -s serverip -j DROP</span><br><span class=\"line\"></span><br><span class=\"line\"># 持续(疯狂)执行：</span><br><span class=\"line\">du -sh /mnt/nfs_client</span><br></pre></td></tr></table></figure>\n<p>因为网络已经断掉，所以<code>du -sh /mnt/nfs_client</code>,而且这个程序没有自动退出或者报错，这样就导致程序无法顺利执行下去，继而阻塞住就变成了 D 状态的进程。</p>\n<p>基于这种模拟方法大家可以自行测试下，笔者之前做过一个场景，将一个两核心的 CPU负载干到了 200 多，但是因为<strong>这种情况下更多是阻塞在网络中，所以此时的负载虽高，并不一定影响系统运行</strong>。</p>\n<p>当然这只是其中一个例子，笔者曾经也因为见过 ping 操作阻塞导致的负载飙升，所以这种场景是多种多样的😂，大家有更多的例子也可以在下方留言，共同学习进步。</p>\n<h3 id=\"负载飙升如何排查\"><a href=\"#负载飙升如何排查\" class=\"headerlink\" title=\"负载飙升如何排查\"></a>负载飙升如何排查</h3><p>基于上面的例子和场景模拟，我们其实应该已经有一套基本的排查方法了，下面这张图是我个人的一些总结(图还会不断完善)</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/loadhigh.png\" alt=\"负载高排查导图\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">负载高排查导图</span></div></div>\n","excerpt":"","more":"<ul>\n<li><a href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</a></li>\n<li><a href=\"#cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">CPU使用率飙升</a><ul>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%A9cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">如何让CPU使用率飙升</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%92%8C%E5%8F%91%E7%8E%B0cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E9%A3%99%E5%8D%87\">如何判断和发现CPU使用率飙升</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Acpu%E9%A3%99%E5%8D%87%E7%9A%84%E6%A0%B9%E6%BA%90\">如何确定CPU飙升的根源</a><ul>\n<li><a href=\"#perf%E5%91%BD%E4%BB%A4\">perf命令</a></li>\n<li><a href=\"#jstack\">jstack</a></li>\n<li><a href=\"#%E7%81%AB%E7%84%B0%E5%9B%BE\">火焰图</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87\">负载飙升</a><ul>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%B4%9F%E8%BD%BD\">负载的定义以及如何查看负载</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%A3%99%E9%AB%98\">如何让系统负载飙高</a><ul>\n<li><a href=\"#%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D\">纯计算任务对负载的影响</a></li>\n<li><a href=\"#%E7%A3%81%E7%9B%98-io-%E5%AF%B9%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%BD%B1%E5%93%8D\">磁盘 IO 对负载的影响</a></li>\n<li><a href=\"#%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C-io-%E6%A8%A1%E6%8B%9F-d-%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E8%A7%82%E5%AF%9F%E8%B4%9F%E8%BD%BD%E5%BD%B1%E5%93%8D\">通过网络 IO 模拟 D 状态进程观察负载影响</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B4%9F%E8%BD%BD%E9%A3%99%E5%8D%87%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5\">负载飙升如何排查</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在很多文章中，每当提到去解决线上问题的时候，大部分的处理方式就是登录环境，哐哐各种敲命令。操作本身没什么问题，但是对于很多人而言，我觉得这种做法其实是本末倒置的，过于在乎去快速抓住重点问题，而忽略了从全局去看问题。那么如果最开始不去操作各种命令，那应该干什么呢？</p>\n<p><em><strong>看监控！！！！</strong></em></p>\n<p>首先不要觉得这个是废话，对于很多场景来说，业务规模是不断变化的，有的时候并发超过了极限的性能，那么这种情况下都没有必要去后台进行各种查询。举个简单的例子，假如说某套业务系统，本身只能支持 500 并发，现在实际上的量到了 2000，导致线上各种内存、CPU、负载的告警，这种情况下还有必要去后台敲<code>top</code>、<code>free</code>吗？答案当然是否定的，这种情况下，就需要考虑对业务系统进行快速的扩容等。</p>\n<p>看监控的意义在于尽可能的找到更多的性能瓶颈或者异常的点，从全局出发，对系统当前存在的问题和异常点有全面的了解。</p>\n<p>监控系统多种多样，从较早的 zabbix 到现在比较流行的prometheus+grafana（举两个常用的例子），对于系统业务都有比较完善的监控，可以帮助我们更加具体的了解到系统运行全貌。如果你对这些都不喜欢，那么你自己写一个监控系统也没什么问题。</p>\n<p>当我们看完监控之后（假设你真的看了），接下来进入实际操作环节，我会从这些指标的详细含义出发，然后尽可能地将各种处理方式分享给大家。</p>\n<h2 id=\"CPU使用率飙升\"><a href=\"#CPU使用率飙升\" class=\"headerlink\" title=\"CPU使用率飙升\"></a>CPU使用率飙升</h2><h3 id=\"如何让CPU使用率飙升\"><a href=\"#如何让CPU使用率飙升\" class=\"headerlink\" title=\"如何让CPU使用率飙升\"></a>如何让CPU使用率飙升</h3><p>这个问题其实很简单，只要有计算任务一直存在，让 CPU 一直处于繁忙之中，那么 CPU 必然飙升。我们可以通过一系列的工具去模拟这个情况。</p>\n<p><a href=\"https://github.com/baixiaozhou/SysStress\">github SysStress</a> 这是我自己用 golang 写的压测工具(还在开发中，可以点个 star 让我更有动力😂)</p>\n<p>使用方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./sysstress cpu --cpu-number 10 --duration 10m</span><br></pre></td></tr></table></figure>\n<p>这个就是模拟占用 10 核心的 CPU 并持续 10min，当然大家也可以用其他的压测工具，比如<code>stress-ng</code></p>\n<h3 id=\"如何判断和发现CPU使用率飙升\"><a href=\"#如何判断和发现CPU使用率飙升\" class=\"headerlink\" title=\"如何判断和发现CPU使用率飙升\"></a>如何判断和发现CPU使用率飙升</h3><p>首先我们先看一下，跟 CPU 使用率相关的有哪些指标。我们通过 <code>top</code> 命令就可以看到具体的信息</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/top.png\" alt=\"top\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">top</span></div></div>\n<!-- ![top](../images/top.png) -->\n<p>这些输出中有一行是 <code>%Cpu(s)</code>, 这行展示了 CPU 的整体使用情况，是一个百分比的形式，我们详细阐述下这几个字段的含义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">us, user    : time running un-niced user processes   未降低优先级的用户进程所占用的时间</span><br><span class=\"line\">sy, system  : time running kernel processes          内核进程所占用的时间</span><br><span class=\"line\">ni, nice    : time running niced user processes      降低优先级的用户进程所占用的时间</span><br><span class=\"line\">id, idle    : time spent in the kernel idle handler  空闲的时间</span><br><span class=\"line\">wa, IO-wait : time waiting for I/O completion        等待 I/O 操作完成所花费的时间</span><br><span class=\"line\">hi : time spent servicing hardware interrupts        处理硬件中断所花费的时间</span><br><span class=\"line\">si : time spent servicing software interrupts        处理软件中断所花费的时间</span><br><span class=\"line\">st : time stolen from this vm by the hypervisor      被虚拟机管理程序从此虚拟机中窃取的时间</span><br></pre></td></tr></table></figure>\n<p>在这些指标中，一般关注的比较多的就是 us、sy、id、wa（其他几个指标很高的情况我个人目前基本上没有遇到过）</p>\n<p>上述指标反映了系统整体的 CPU 情况。而程序在操作系统中实际上是以一个个的进程存在的，那我们如何确定到占用 CPU 高的进程呢？让我们的目光从 top 的头部信息往下移动，下面就展示了详细的进程信息</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/top-process.png\" alt=\"top-process\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">top-process</span></div></div>\n<!-- ![top-process](../images/top-process.png) -->\n\n<p>这些程序默认是按照 CPU 的使用率从高到底进行排序的，当然你也可以通过在<code>top</code>的时候输入<code>P</code>进行排序，这样我们就可以看到系统中消耗 CPU 资源的详细进程信息</p>\n<p>上面是我通过 <code>./sysstress cpu --cpu-number 10 --duration 10m</code> 压测程序跑出来的，可以看到这里的 sysstress 程序占用了 1002 的 %CPU，也就是说基本上是 10 个核心，那我们跑一个更高的，将<code>--cpu-number</code>加到 60 看看发生了什么</p>\n<!-- ![stress-cpu](../images/stress-cpu.png) -->\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/stress-cpu.png\" alt=\"stress-cpu\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">stress-cpu</span></div></div>\n\n<p>我们可以看到这次%CPU打到了 6000，那很多人就好奇我日常的程序跑到多高算高呢？</p>\n<p>这里我们需要明确一点，现在的服务器绝大部分都是多核心 CPU（1C2G这种自己用来玩的忽略），CPU 的核心数决定了我们程序在同一时间能够执行多少个线程，也就是说，这个高不高是相对于机器配置而言的。如果你的机器只有 16C，那么单个进程占用的 %CPU 到 1000，那么其实已经算是比较高了。如果是 256C 的CPU（土豪级配置），那么单个进程占用的 %CPU 到 6000，对于系统的稳定性影响就没有那么大了。</p>\n<p>上述我们说的情况是进程占用 CPU 对整个系统的影响，那么进程占用的 CPU 对系统的影响不大就代表这个程序一定没有问题吗？答案显然是未必的。</p>\n<p>我们还是要回归到业务本身，如果进程的 CPU 占用在业务变动不大的情况下，发生了异常波动，或者正常情况下业务不会消耗这么高的 CPU，那么我们就需要继续排查了。</p>\n<h3 id=\"如何确定CPU飙升的根源\"><a href=\"#如何确定CPU飙升的根源\" class=\"headerlink\" title=\"如何确定CPU飙升的根源\"></a>如何确定CPU飙升的根源</h3><p>这个问题的 核心是 CPU 上在运行什么东西。 多核心CPU 下，每个核心都可以执行不同的程序，我们如何确定一个进程中那些方法在消耗 CPU 呢？从而引申下面详细的问题:</p>\n<ol>\n<li>程序的调用栈是什么样的？</li>\n<li>调用栈信息中哪些是需要关注的，那些是可以忽略的？</li>\n<li>热点函数是什么？</li>\n</ol>\n<p>老话说得好，”工欲善其事，必先利其器”, 我们需要这些东西，就必须了解到什么样的工具可以拿到上面我提到的一些信息。接下来我将通过常用的后端语言：<code>golang</code> 和 <code>java</code> 为例构造一些高 CPU 的程序来进行展示。</p>\n<h4 id=\"perf命令\"><a href=\"#perf命令\" class=\"headerlink\" title=\"perf命令\"></a>perf命令</h4><p><strong>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。</strong></p>\n<p>安装:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install perf   #Centos</span><br></pre></td></tr></table></figure>\n<p>安装完成后，我们可以首先看下 <code>perf</code>的用法，这里不展开具体用法，只列出我平常使用的几个命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top        System profiling tool.               #对系统性能进行实时分析。</span><br><span class=\"line\">record     Run a command and record its profile into perf.data     #收集采样信息</span><br><span class=\"line\">report     Read perf.data (created by perf record) and display the profile  #分析采样信息，和record配合使用</span><br></pre></td></tr></table></figure>\n<p>record 和 report 的使用更多在于 dump 当前环境的信息用于后续分析，如果在自己环境上测试，可以用 top 进行一些简单的实时分析（类似于 top 命令）。</p>\n<p>还是用之前的压测工具，我们模拟一个 10 核心的 10min 的压测场景</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./sysstress cpu --cpu-number 10 --duration 10m &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<p>执行这个语句，让压测程序在后台执行，然后我们通过<code>perf top</code>查看具体的情况（可以通过-p 指定 pid）</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/perftop.png\" alt=\"perf top,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">perf top,</span></div></div>\n<!-- ![perf top](../images/perftop.png) -->\n\n<p>从截图的信息中我们可以看到占用资源最多的一些方法，包括 sysstress 进程的各种方法(从图片中基本上就可以确定高消耗的方法在哪里)以及底层的 <code>__vdso_clock_gettime</code>, 那再结合压测工具的代码分析下:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">burnCpu</span><span class=\"params\">(wg *sync.WaitGroup, start time.Time, durSec <span class=\"type\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t_ = <span class=\"number\">1</span> * <span class=\"number\">1</span></span><br><span class=\"line\">\t\tnow := time.Now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> now.Sub(start) &gt; time.Duration(durSec)*time.Second &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是方法的核心，其实就是做无意义的计算，外加时间的判断，超过 duration 就结束。这样和上面的 perf top 信息就能对应起来。</p>\n<p>然后我们用 java 写一个同样的程序，再看看 <code>perf top</code>的情况:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/javaperftop.png\" alt=\"perf top,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">perf top,</span></div></div>\n<!-- ![perf top](../images/javaperftop.png) -->\n<p>从这一大段显示来看，是不是看的一脸懵逼，很难发现到底是什么程序在占用CPU 资源。大家可以看一下源程序:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                        Math.sin(Math.random());</span><br><span class=\"line\">                        <span class=\"type\">LocalDateTime</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> LocalDateTime.now();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的程序也是非常简单，启动 10 个线程，做一个无意义的数学运算，然后获取当前时间。从这段代码中是不是很难和上面<code>perf top</code>的显示关联起来？ 原因也非常简单， 像Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。那我们好能通过 perf 去看到 java 相关的堆栈吗？答案是可以的。</p>\n<p>可以借助 <a href=\"https://github.com/jvm-profiling-tools/perf-map-agent\">perf-map-agent</a> 这样的开源工具，去生成和<code>perf</code> 工具一起使用的方法映射，但是需要做额外的一些配置。这里的方法大家可以自己探究，为什么不详细的讲这个呢，原因也简单，排查问题的工具多种多样，没必要在一棵树上吊死。</p>\n<h4 id=\"jstack\"><a href=\"#jstack\" class=\"headerlink\" title=\"jstack\"></a>jstack</h4><p>既然 perf top 去查看 JAVA 的调用栈不太方便，我们就直接上 java 提供的 jstack 工具去分析。</p>\n<ul>\n<li>jstack -l pid &gt; xxx.txt 需要注意的是，linux系统中往往会用不同的用户去执行不同的程序，此时可能需要通过sudu -u xxx jstack的形式</li>\n<li>kill -3， jstack 用不了的情况下可以使用 kill -3 pid 的形式，堆栈会输出在系统日志中。</li>\n</ul>\n<p>具体的操作步骤:</p>\n<ol>\n<li><code>top -Hp $pid</code> 找到占用 CPU 的具体线程</li>\n<li><code>jstack -l $pid &gt; /tmp/$pid.jstack</code> 或者 <code>kill -3 $pid</code>将 java 进程的堆栈情况输出的日志中，然后根据 <code>top -Hp</code> 看到的线程信息在输出的堆栈日志中进行查找（<code>top -Hp</code> 输出的是 10 进制的 id，<code>jstack</code> 输出的是 16 进制的，在查找时注意进制转换）</li>\n</ol>\n<p>我们看下上面 java 程序的堆栈的信息:</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2024</span><span class=\"number\">-08</span><span class=\"number\">-16</span> <span class=\"number\">15</span>:<span class=\"number\">15</span>:<span class=\"number\">40</span></span><br><span class=\"line\">Full thread <span class=\"built_in\">dump</span> Java HotSpot(TM) <span class=\"number\">64</span>-Bit Server VM (<span class=\"number\">25.221</span>-b11 mixed mode):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Attach Listener&quot;</span> #<span class=\"number\">35</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f52b4001000</span> nid=<span class=\"number\">0x71f4</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;DestroyJavaVM&quot;</span> #<span class=\"number\">34</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0009800</span> nid=<span class=\"number\">0x1693</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Thread-1&quot;</span> #<span class=\"number\">25</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e015a800</span> nid=<span class=\"number\">0x16d9</span> runnable [<span class=\"number\">0x00007f52f64e3000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\tat sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class=\"number\">755</span>)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class=\"number\">938</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class=\"number\">267</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class=\"number\">227</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class=\"number\">120</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">315</span>)</span><br><span class=\"line\">\tat java.util.TimeZone.toZoneId(TimeZone.java:<span class=\"number\">556</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.systemDefault(ZoneId.java:<span class=\"number\">274</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.Clock.systemDefaultZone(Clock.java:<span class=\"number\">178</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.LocalDateTime.now(LocalDateTime.java:<span class=\"number\">180</span>)</span><br><span class=\"line\">\tat Main$<span class=\"number\">1.</span>run(Main.java:<span class=\"number\">12</span>)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Thread-0&quot;</span> #<span class=\"number\">24</span> prio=<span class=\"number\">5</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0159000</span> nid=<span class=\"number\">0x16d8</span> runnable [<span class=\"number\">0x00007f52f65e4000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\tat sun.misc.Unsafe.getObjectVolatile(Native Method)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.tabAt(ConcurrentHashMap.java:<span class=\"number\">755</span>)</span><br><span class=\"line\">\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:<span class=\"number\">938</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:<span class=\"number\">267</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:<span class=\"number\">227</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneRegion.ofId(ZoneRegion.java:<span class=\"number\">120</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.of(ZoneId.java:<span class=\"number\">315</span>)</span><br><span class=\"line\">\tat java.util.TimeZone.toZoneId(TimeZone.java:<span class=\"number\">556</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.ZoneId.systemDefault(ZoneId.java:<span class=\"number\">274</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.Clock.systemDefaultZone(Clock.java:<span class=\"number\">178</span>)</span><br><span class=\"line\">\tat java.<span class=\"built_in\">time</span>.LocalDateTime.now(LocalDateTime.java:<span class=\"number\">180</span>)</span><br><span class=\"line\">\tat Main$<span class=\"number\">1.</span>run(Main.java:<span class=\"number\">12</span>)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"> <span class=\"comment\">--- 10 个 thread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Service Thread&quot;</span> #<span class=\"number\">23</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0143800</span> nid=<span class=\"number\">0x16d6</span> runnable [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;C2 CompilerThread1&quot;</span> #<span class=\"number\">6</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e010e000</span> nid=<span class=\"number\">0x16c5</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"> <span class=\"comment\">--- 一大堆 C2 CompilerThread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;C2 CompilerThread0&quot;</span> #<span class=\"number\">5</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e010b000</span> nid=<span class=\"number\">0x16c4</span> waiting on condition [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Signal Dispatcher&quot;</span> #<span class=\"number\">4</span> daemon prio=<span class=\"number\">9</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0109800</span> nid=<span class=\"number\">0x16c3</span> runnable [<span class=\"number\">0x0000000000000000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Finalizer&quot;</span> #<span class=\"number\">3</span> daemon prio=<span class=\"number\">8</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00d8800</span> nid=<span class=\"number\">0x16c2</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f52f7bfa000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;<span class=\"number\">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">144</span>)</span><br><span class=\"line\">\t- locked &lt;<span class=\"number\">0x000000008021a5e8</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.<span class=\"built_in\">remove</span>(ReferenceQueue.java:<span class=\"number\">165</span>)</span><br><span class=\"line\">\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class=\"number\">216</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Reference Handler&quot;</span> #<span class=\"number\">2</span> daemon prio=<span class=\"number\">10</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00d3800</span> nid=<span class=\"number\">0x16c1</span> <span class=\"keyword\">in</span> Object.wait() [<span class=\"number\">0x00007f52f7cfb000</span>]</span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)</span><br><span class=\"line\">\t- waiting on &lt;<span class=\"number\">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:<span class=\"number\">502</span>)</span><br><span class=\"line\">\tat java.lang.ref.Reference.tryHandlePending(Reference.java:<span class=\"number\">191</span>)</span><br><span class=\"line\">\t- locked &lt;<span class=\"number\">0x0000000080218d38</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class=\"line\">\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class=\"number\">153</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   Locked ownable synchronizers:</span><br><span class=\"line\">\t- None</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;VM Thread&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e00ca000</span> nid=<span class=\"number\">0x16c0</span> runnable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e001f000</span> nid=<span class=\"number\">0x1694</span> runnable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--- 一大堆 GC task thread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class=\"number\">0</span> tid=<span class=\"number\">0x00007f53e0146000</span> nid=<span class=\"number\">0x16d7</span> waiting on condition</span><br><span class=\"line\"></span><br><span class=\"line\">JNI global references: <span class=\"number\">202</span></span><br></pre></td></tr></table></figure>\n<p>我们通过 top -Hp 的信息就可以快速定位到 Thread-[0-9] 这几个线程，而每个线程的调用栈都是 <code>java.time.LocalDateTime.now</code>, 也说明了这个方法在不停消耗 CPU。（但是 jstack 只能捕获短时间或者瞬时的堆栈信息，没法处理长时间的，所以我们在获取时可以多打印几次或者使用其他方法）</p>\n<p>至于 jstack 的详细用法，请参考我的另一篇博客：<a href=\"https://baixiaozhou.github.io/2024/08/13/JAVA%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/\">java问题定位</a></p>\n<p>除此之外，还有非常多的分析工具，pstack\\gstack\\strace\\gdb等等，大家可以自行探索使用</p>\n<h4 id=\"火焰图\"><a href=\"#火焰图\" class=\"headerlink\" title=\"火焰图\"></a>火焰图</h4><p>上面我们介绍了很多操作的命令和方法，那么有没有一种比较直观的方式能够直接看到各种方法执行的耗时比重等情况呢？火焰图就是为了解决这种情况而生的。</p>\n<p>火焰图的分类有很多，常用的包括:</p>\n<ol>\n<li>CPU 火焰图 (CPU Flame Graph)<ul>\n<li>   描述：展示 CPU 在不同方法上的消耗情况，显示每个方法调用所占用的 CPU 时间。</li>\n<li>   用途：用于分析 CPU 性能瓶颈，识别哪些方法消耗了最多的 CPU 资源。</li>\n<li>   应用：Java、C++ 等多种编程语言的性能分析。</li>\n</ul>\n</li>\n<li>内存火焰图 (Memory Flame Graph)<ul>\n<li>描述：展示内存分配情况，显示每个方法调用分配的内存量。</li>\n<li>用途：用于检测内存泄漏、过度内存分配问题，帮助优化内存使用。</li>\n<li>应用：常用于分析内存密集型应用，如 Java 应用的堆内存分析。</li>\n</ul>\n</li>\n<li>I&#x2F;O 火焰图 (I&#x2F;O Flame Graph)<ul>\n<li>   描述：展示 I&#x2F;O 操作的耗时情况，显示不同方法的 I&#x2F;O 操作占用的时间。</li>\n<li>   用途：用于分析应用程序的 I&#x2F;O 性能，识别慢速或频繁的 I&#x2F;O 操作。</li>\n<li>   应用：数据库查询、文件系统操作、网络通信等场景的性能调优。</li>\n</ul>\n</li>\n</ol>\n<p>我们这里通过 <a href=\"https://github.com/async-profiler/async-profiler\">async-profiler</a> 对文章上面的java压测程序进行抓取(这个工具只能抓 java 的)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xzf async-profiler-3.0-linux-x64.tar.gz</span><br><span class=\"line\">cd async-profiler-3.0-linux-x64/bin</span><br><span class=\"line\">./asprof -d 60 pid -f /tmp/javastress.html</span><br></pre></td></tr></table></figure>\n<p>我们用浏览器打开生成的 html 文件，可以看到如下的火焰图信息（可以在网页进行点击，查看更细节的方法）</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/javafire.png\" alt=\"java 程序的火焰图,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">java 程序的火焰图,</span></div></div>\n<!-- ![java 程序的火焰图](../images/javafire.png) -->\n\n<p>这样看起来就比 jstack这些信息更加直观一点。</p>\n<h2 id=\"负载飙升\"><a href=\"#负载飙升\" class=\"headerlink\" title=\"负载飙升\"></a>负载飙升</h2><h3 id=\"负载的定义以及如何查看负载\"><a href=\"#负载的定义以及如何查看负载\" class=\"headerlink\" title=\"负载的定义以及如何查看负载\"></a>负载的定义以及如何查看负载</h3><p>我们先看下系统负载的官方描述:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in arunnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access,eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs ina  system,  so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.</span><br></pre></td></tr></table></figure>\n\n<p>系统负载平均值表示处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么正在使用 CPU，要么正在等待使用 CPU。处于不可中断状态的进程正在等待某些 I&#x2F;O 访问，例如等待磁盘。这里的核心概念就是 loadavg 这个数值体现了某些特定状态进程的数量。</p>\n<p>那引申出两个问题:</p>\n<ol>\n<li>进程的状态有哪些？ 如何在 Linux 上查看进程状态</li>\n<li>可运行和不可中断状态的进程具体含义是什么</li>\n</ol>\n<p>查看的方式，我们可以通过 ps 命令进行查看，比如通过<code>ps -auxf</code>, 我么可以看到有一列为 <code>STAT</code>,这列就代表该进程的状态:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/psauxf.png\" alt=\"进程状态\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">进程状态</span></div></div>\n\n<p>进程的状态和具体含义:</p>\n<ul>\n<li>D    uninterruptible sleep (usually IO)</li>\n<li>R    running or runnable (on run queue)</li>\n<li>S    interruptible sleep (waiting for an event to complete)</li>\n<li>T    stopped by job control signal</li>\n<li>t    stopped by debugger during the tracing</li>\n<li>W    paging (not valid since the 2.6.xx kernel)</li>\n<li>X    dead (should never be seen) </li>\n<li>Z    defunct (“zombie”) process, terminated but not reaped by its parent</li>\n</ul>\n<p>这里我们看到处于不可中断的状态的进程和正在运行的进程分别为 <code>D</code> 和 <code>R</code>,换个说法，也就是说造成负载升高的原因也就是这两个状态的进程引起的。</p>\n<p>（插个题外话，按照官方的说法，X 状态的进程应该是不应该被看到的， 但是之前在腾讯云做ES的时候，偶然间碰到了一次，当时还截了个图用做留念😂，但是没有捕获到具体的信息）</p>\n<p>负载的指标可以通过 <code>top</code> 以及 <code>uptime</code> 指令获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23:35:00 up 1 day, 46 min,  1 user,  load average: 49.16, 18.35, 7.87</span><br></pre></td></tr></table></figure>\n<p>这里展示了 loadavg 的三个数值: 分别代表的含义是 1min、5min、15min 的系统平均负载</p>\n<p>那我们如何判断系统的负载是高是低呢？</p>\n<p>这里一般有个经验值，我们一般和 CPU 和核心数进行对比，一般负载在 CPU 核心的 70% 左右以及以下，对系统一般没什么影响，超过 70%，系统可能收到影响。但是这里还需要注意的一点就是，负载的比例在 70% 以下时不一定代表系统就没问题，举个简单的例子，如果一个系统上基本上没有业务在运行，那么负载基本上就在零点几左右，那么这种情况下，负载有升高不一定是合理的（后面举一个简单的例子）</p>\n<h3 id=\"如何让系统负载飙高\"><a href=\"#如何让系统负载飙高\" class=\"headerlink\" title=\"如何让系统负载飙高\"></a>如何让系统负载飙高</h3><h4 id=\"纯计算任务对负载的影响\"><a href=\"#纯计算任务对负载的影响\" class=\"headerlink\" title=\"纯计算任务对负载的影响\"></a>纯计算任务对负载的影响</h4><p>既然说正在运行的进程会引起负载的变化，那么跑一些程序，让程序不停运行，那么自然而然就能构造出持续运行的进程了。<br>我这里找了三台机器(64C)，用我的压测工具先跑一些纯 CPU 的运算，然后观察下效果：</p>\n<p>测试分为三组，测试前关闭不必要的服务和进程:</p>\n<ol>\n<li>10 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 10 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n<li>30 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 30 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n<li>60 并发 30min<ul>\n<li><code>nohup ./sysstress cpu --cpu-number 60 --duration 30m &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n</li>\n</ol>\n<p>效果如下:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load10.png\" alt=\"10并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">10并发负载,</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load30.png\" alt=\"30并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">30并发负载,</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/load60.png\" alt=\"60并发负载,\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发负载,</span></div></div>\n<!-- ![10并发负载](../images/load10.png)\n![30并发负载](../images/load30.png)\n![60并发负载](../images/load60.png) -->\n\n<p>从上述测试过程中，我们可以发现，在纯运算这种场景下，并发的量基本上和负载是对应的。也就是说随着 CPU的使用量 上涨，负载也会不断变高。</p>\n<h4 id=\"磁盘-IO-对负载的影响\"><a href=\"#磁盘-IO-对负载的影响\" class=\"headerlink\" title=\"磁盘 IO 对负载的影响\"></a>磁盘 IO 对负载的影响</h4><p>在刚才的例子中，我们看到了纯运算对负载的影响（R 进程的代表），然后在关于 D 进程的说明中，我们可以看到有一个比较明显的说明 <code>(usually IO)</code> ,即通常是 IO 引起的，那么接下来我们通过磁盘 IO 来测试一下</p>\n<p>测试分为三组，测试前关闭不必要的服务和进程:</p>\n<ol>\n<li>10 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 10 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n<li>30 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 30 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n<li>60 并发 15min<ul>\n<li><code>nohup ./sysstress io --operation read --filepath test.access.log -p 60 -d 15m &gt; /dev/null 2&gt;&amp;1 &amp;</code></li>\n</ul>\n</li>\n</ol>\n<p>效果如下:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload10.png\" alt=\"10并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">10并发负载</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload30.png\" alt=\"30并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">30并发负载</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/ioload60.png\" alt=\"60并发负载\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发负载</span></div></div>\n\n<p>我们也顺便看一下，60 并发下 CPU 的情况:</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/io60c.png\" alt=\"60并发系统整体情况\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">60并发系统整体情况</span></div></div>\n\n<p>这里我们可以观察到，系统的 CPU 基本上已经跑满了。us 和 sy 都占的比较多，但是这种读取非常有可能走到缓存中，我们想测绕过缓存，可以通过 DIRECT 的方式。</p>\n<p>但是上面的例子其实也证明了一件事，IO 的操作也是会导致负载产生飙升。</p>\n<p>那么问题来了，磁盘IO 和 CPU 操作都会导致系统负载飙升，那么负载飙升一定会是这两个原因吗？答案也是未必的，因为上述我们曾经提到过 D 状态的进程，到目前为止我们好像还没介绍过，那么我们来继续模拟，既然 D 状态的进程是 IO 操作引起的，普通的磁盘读写 IO 很难模拟，那我们就换个 IO 场景继续模拟 – 网络 IO。</p>\n<h4 id=\"通过网络-IO-模拟-D-状态进程观察负载影响\"><a href=\"#通过网络-IO-模拟-D-状态进程观察负载影响\" class=\"headerlink\" title=\"通过网络 IO 模拟 D 状态进程观察负载影响\"></a>通过网络 IO 模拟 D 状态进程观察负载影响</h4><p>这里直接上一个模拟方法:</p>\n<ul>\n<li>A 机器开启 NFS Server</li>\n<li>B 机器作为客户端进行挂载</li>\n<li>断开网络</li>\n<li>疯狂 df -h</li>\n</ul>\n<p>详细的操作步骤:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装 Centos</span><br><span class=\"line\">sudo yum install nfs-utils</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端配置</span><br><span class=\"line\">sudo mkdir -p /mnt/nfs_share</span><br><span class=\"line\">sudo chown nobody:nogroup /mnt/nfs_share</span><br><span class=\"line\">sudo chmod 755 /mnt/nfs_share</span><br><span class=\"line\">## 打开 /etc/exports 配置，添加一行来定义共享目录及其权限。例如，将 /mnt/nfs_share 共享给网络 192.168.1.0/24，并提供读写权限：</span><br><span class=\"line\">/mnt/nfs_share 192.168.1.0/24(rw,sync,no_subtree_check)</span><br><span class=\"line\"></span><br><span class=\"line\">## 启动 NFS</span><br><span class=\"line\">sudo exportfs -a</span><br><span class=\"line\">sudo systemctl restart nfs-kernel-server</span><br><span class=\"line\">sudo systemctl enable nfs-kernel-server</span><br><span class=\"line\"></span><br><span class=\"line\"># 客户端配置</span><br><span class=\"line\">sudo mkdir -p /mnt/nfs_client</span><br><span class=\"line\">sudo mount -t nfs 192.168.1.100(server ip):/mnt/nfs_share /mnt/nfs_client</span><br><span class=\"line\">## 验证</span><br><span class=\"line\">df -h /mnt/nfs_client</span><br><span class=\"line\"></span><br><span class=\"line\"># 断网模拟(客户端)</span><br><span class=\"line\">iptables -I INPUT -s serverip -j DROP</span><br><span class=\"line\"></span><br><span class=\"line\"># 持续(疯狂)执行：</span><br><span class=\"line\">du -sh /mnt/nfs_client</span><br></pre></td></tr></table></figure>\n<p>因为网络已经断掉，所以<code>du -sh /mnt/nfs_client</code>,而且这个程序没有自动退出或者报错，这样就导致程序无法顺利执行下去，继而阻塞住就变成了 D 状态的进程。</p>\n<p>基于这种模拟方法大家可以自行测试下，笔者之前做过一个场景，将一个两核心的 CPU负载干到了 200 多，但是因为<strong>这种情况下更多是阻塞在网络中，所以此时的负载虽高，并不一定影响系统运行</strong>。</p>\n<p>当然这只是其中一个例子，笔者曾经也因为见过 ping 操作阻塞导致的负载飙升，所以这种场景是多种多样的😂，大家有更多的例子也可以在下方留言，共同学习进步。</p>\n<h3 id=\"负载飙升如何排查\"><a href=\"#负载飙升如何排查\" class=\"headerlink\" title=\"负载飙升如何排查\"></a>负载飙升如何排查</h3><p>基于上面的例子和场景模拟，我们其实应该已经有一套基本的排查方法了，下面这张图是我个人的一些总结(图还会不断完善)</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"/images/loadhigh.png\" alt=\"负载高排查导图\" data-fancybox=\"true\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">负载高排查导图</span></div></div>"}],"PostAsset":[],"PostCategory":[{"post_id":"clzzd33n00001x4ic3em03qw9","category_id":"clzzd33n20004x4ic8hf5bwi8","_id":"clzzd33n30009x4ic6n0a0fxu"},{"post_id":"clzzd33n10003x4ic61n6cz2g","category_id":"clzzd33n20004x4ic8hf5bwi8","_id":"clzzd33n3000cx4ic06e47xl2"}],"PostTag":[{"post_id":"clzzd33n00001x4ic3em03qw9","tag_id":"clzzd33n20005x4ic7t8l3d37","_id":"clzzd33n3000bx4iceuw287ni"},{"post_id":"clzzd33n00001x4ic3em03qw9","tag_id":"clzzd33n30008x4ic4niqay0n","_id":"clzzd33n3000dx4ica4zn3nd8"},{"post_id":"clzzd33n10003x4ic61n6cz2g","tag_id":"clzzd33n30008x4ic4niqay0n","_id":"clzzd33n4000hx4ic3g26ewoi"},{"post_id":"clzzd33n10003x4ic61n6cz2g","tag_id":"clzzd33n3000ex4icbaa196l5","_id":"clzzd33n4000ix4ic4lfv3g2m"},{"post_id":"clzzd33n10003x4ic61n6cz2g","tag_id":"clzzd33n4000fx4ic3vjt7c6j","_id":"clzzd33n4000jx4ic9lqy98xf"},{"post_id":"clzzd33n10003x4ic61n6cz2g","tag_id":"clzzd33n4000gx4ic4qq7cm4f","_id":"clzzd33n4000kx4ic3noz3odq"}],"Tag":[{"name":"JAVA","_id":"clzzd33n20005x4ic7t8l3d37"},{"name":"Linux","_id":"clzzd33n30008x4ic4niqay0n"},{"name":"Java","_id":"clzzd33n3000ex4icbaa196l5"},{"name":"Golang","_id":"clzzd33n4000fx4ic3vjt7c6j"},{"name":"commands","_id":"clzzd33n4000gx4ic4qq7cm4f"}]}}